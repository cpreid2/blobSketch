<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>blobSketch version 1.5</title>

	<!-- Prevent FOUC (Flash of Unstyled Content) -->
	<style>
		html { visibility: hidden; opacity: 0; }
	</style>

	<style>
	/* ---------- Desktop defaults: 3D Game Console ---------- */

/* 1. Base / Reset */
body {
  margin: 0;
  padding: 14px 14px 100px;
  font-family: "Courier New", monospace;
  background:
    radial-gradient(ellipse at 50% 15%, #403830 0%, #2a2420 55%, #181412 100%);
  color: #000;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  overflow: hidden;
  perspective: 1600px;
  perspective-origin: 50% 25%;
}


/* 2. Outer console shell — 3D plastic body */
.window {
  width: 780px;
  margin: 0;
  position: relative;
  background:
    linear-gradient(178deg,
      #f0ead8 0%,
      #e8e0cc 15%,
      #e2dbc8 40%,
      #d5ceb8 70%,
      #cac2aa 100%);
  border-radius: 26px 26px 22px 22px;
  padding: 8px 8px 10px;
  border: 3px solid;
  border-color: #ece5d3 #a8a090 #706850 #bab29a;
  box-shadow:
    1px 1px 0 0 #ccc4ac,
    2px 2px 0 0 #c5bda5,
    3px 3px 0 0 #beb69e,
    4px 4px 0 0 #b7af97,
    5px 5px 0 0 #b0a890,
    6px 6px 0 0 #a9a189,
    7px 7px 0 0 #a29a82,
    8px 8px 0 0 #9b937b,
    9px 9px 0 0 #948c74,
    10px 10px 0 0 #8d856d,
    11px 11px 0 0 #867e66,
    12px 12px 0 0 #7f775f,
    4px 16px 40px rgba(0,0,0,0.5),
    8px 24px 70px rgba(0,0,0,0.3),
    inset 0 2px 3px rgba(255,255,255,0.6),
    inset 0 -2px 5px rgba(0,0,0,0.15);
}

/* Console front face bevel overlay */
.window::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 26px 26px 22px 22px;
  background:
    linear-gradient(180deg,
      rgba(255,255,255,0.15) 0%,
      rgba(255,255,255,0.03) 30%,
      transparent 50%,
      rgba(0,0,0,0.04) 80%,
      rgba(0,0,0,0.1) 100%);
  pointer-events: none;
  z-index: 1;
}

/* Subtle plastic grain texture overlay */
.window::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 26px 26px 22px 22px;
  background-image:
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 1px,
      rgba(0,0,0,0.015) 1px,
      rgba(0,0,0,0.015) 2px
    ),
    repeating-linear-gradient(
      90deg,
      transparent,
      transparent 1px,
      rgba(0,0,0,0.01) 1px,
      rgba(0,0,0,0.01) 2px
    );
  pointer-events: none;
  z-index: 0;
}


/* 3. Title-bar — molded ridge on console top */
.title-bar {
  background:
    linear-gradient(180deg,
      #e0d8c4 0%,
      #d3cbb7 30%,
      #c8c0aa 100%);
  border-bottom: 3px solid #5a5444;
  padding: 5px 10px;
  display: flex;
  gap: 12px;
  align-items: center;
  position: relative;
  z-index: 2000;
  border-radius: 14px 14px 4px 4px;
  box-shadow:
    inset 0 2px 2px rgba(255,255,255,0.5),
    inset 0 -2px 4px rgba(0,0,0,0.2),
    0 2px 4px rgba(0,0,0,0.15);
  border-top: 2px solid #ece5d3;
}


.menu-bar {
  display: flex;
  gap: 16px;
}

.menu-bar span {
  font-weight: bold;
  cursor: pointer;
  position: relative;
  color: #3a352e;
  text-shadow:
    0 1px 0 rgba(255,255,255,0.45),
    0 -1px 0 rgba(0,0,0,0.08);
  letter-spacing: 0.3px;
}

.menu-bar span:hover {
  text-decoration: underline;
}

/* dropdowns — 3D raised panel */
.submenu {
  display: none;
  position: absolute;
  top: 22px;
  left: 0;
  background:
    linear-gradient(180deg, #f8f2e4 0%, #ede6d2 100%);
  border: 2px solid;
  border-color: #d8d0bc #7a7264 #5a5444 #9a9280;
  padding: 4px;
  flex-direction: column;
  gap: 4px;
  z-index: 999;
  border-radius: 6px;
  box-shadow:
    3px 4px 8px rgba(0,0,0,0.4),
    inset 0 1px 1px rgba(255,255,255,0.5);
}

.submenu span {
  display: block;
  padding: 2px 6px;
  cursor: pointer;
}

.submenu span:hover {
  background:
    linear-gradient(180deg, #e8e0cc 0%, #d8d0bc 100%);
  border-radius: 3px;
}

#exportSubmenu {
  width: 160px;
}
#fileSubmenu {
  width: 200px;
}

/* Title-bar right-side actions */
.title-actions {
  margin-left: auto;
  display: flex;
  gap: 6px;
}

.reset-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 24px;
  padding: 0 8px;
  font-weight: bold;
  font-size: 18px;
  cursor: pointer;
  user-select: none;
  border-radius: 6px;
  background:
    linear-gradient(180deg, #faf6ec 0%, #e8e0cc 100%);
  border: 2px solid;
  border-color: #d0c8b4 #8a8270 #6a6250 #a8a090;
  box-shadow:
    1px 2px 3px rgba(0,0,0,0.35),
    inset 0 1px 1px rgba(255,255,255,0.7);
  transition: all 0.1s ease;
}

.reset-icon:hover {
  background:
    linear-gradient(180deg, #f0e8d4 0%, #ddd5c0 100%);
}

.reset-icon:active {
  background:
    linear-gradient(180deg, #d5ceb8 0%, #e0d8c4 100%);
  box-shadow:
    inset 0 2px 4px rgba(0,0,0,0.3);
  border-color: #6a6250 #a8a090 #d0c8b4 #8a8270;
}

/* 4. Workspace Layout */
.content {
  display: flex;
  gap: 18px;
  margin-top: 14px;
  margin-left: 10px;
  margin-right: 8px;
  position: relative;
}

/* Molding seam groove — horizontal parting line */
.content::before {
  content: "";
  position: absolute;
  top: -8px;
  left: 14px;
  right: 14px;
  height: 1px;
  background: rgba(0,0,0,0.12);
  box-shadow: 0 1px 0 rgba(255,255,255,0.35);
  pointer-events: none;
}

/* 4-A Left console panel — recessed 3D bay */
.toolbar {
  width: 180px;
  border-right: none;
  background:
    linear-gradient(180deg, #cac3b0 0%, #d8d1c0 40%, #cec7b4 100%);
  padding: 10px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 10px;
  border-radius: 14px;
  border: 3px solid;
  border-color: #6a6250 #a09880 #c0b8a0 #7a7260;
  box-shadow:
    inset 0 3px 8px rgba(0,0,0,0.4),
    inset 0 -1px 2px rgba(255,255,255,0.3),
    inset 3px 0 6px rgba(0,0,0,0.15),
    inset -2px 0 4px rgba(0,0,0,0.08),
    0 1px 0 rgba(255,255,255,0.3);
}

/* 4-B Panel sections — raised sub-panels */
.toolbar-section {
  border-radius: 8px;
  background:
    linear-gradient(180deg, #f5eeda 0%, #e8e0cc 100%);
  border: 2px solid;
  border-color: #e8e0cc #9a9280 #7a7260 #c0b8a0;
  padding: 8px;
  margin: 0;
  box-shadow:
    1px 2px 3px rgba(0,0,0,0.25),
    inset 0 1px 1px rgba(255,255,255,0.5);
  display: flex;
  flex-direction: column;
}




.toolbar-section h4 {
  margin: 0 0 4px;
  font-size: 13px;
  font-weight: bold;
  text-align: left;
  background:
    linear-gradient(180deg, #4a4a4a 0%, #2c2c2c 100%);
  color: #e8e0cc;
  border-radius: 4px;
  padding: 3px 6px;
  border: 1px solid;
  border-color: #5a5a5a #1a1a1a #0a0a0a #3a3a3a;
  box-shadow:
    inset 0 1px 1px rgba(255,255,255,0.15),
    0 1px 2px rgba(0,0,0,0.3);
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  letter-spacing: 0.5px;
}

.toolbar-section .icon-group {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;          /* NEW: center horizontally */
  align-items: center;              /* NEW: center vertically in the section */
  flex: 1;                          /* take remaining height so centering is obvious */
}

/* Edit tools neon outline when active group is engaged - removed red highlight */

/* 4-C Icon buttons — physical 3D console buttons */
.icon {
  width: 34px;
  height: 34px;
  border: 2px solid;
  border-color: #e8e0d0 #8a8270 #5a5444 #a8a090;
  background:
    linear-gradient(145deg, #fdfaf4 0%, #f0e8d4 40%, #e0d8c4 100%);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  user-select: none;
  font-weight: normal;
  position: relative;
  border-radius: 8px;
  box-shadow:
    2px 3px 5px rgba(0,0,0,0.4),
    0 1px 2px rgba(0,0,0,0.2),
    inset 0 1px 2px rgba(255,255,255,0.8),
    inset 0 -1px 1px rgba(0,0,0,0.1);
  overflow: visible;
  transition: all 0.08s ease;
}

.icon img {
  width: 100%;
  height: 100%;
  border-radius: inherit;
}

/* Active icon: keep ON badge but allow rim tweak if desired */
#iconFill.icon-active {
  background: linear-gradient(145deg, #d8d8d8 0%, #c0c0c0 100%);
  font-weight: bold;
}

/* “ON” label */
.icon.icon-active::after {
  content: "ON";
  position: absolute;
  top: -8px;
  right: -8px;
  background: radial-gradient(circle at 40% 35%, #ffff40, #e6d400);
  color: #000;
  font-size: 10px;
  font-weight: bold;
  border: 1px solid #8a8000;
  padding: 2px 4px;
  border-radius: 4px;
  box-shadow: 1px 1px 3px rgba(0,0,0,0.4), 0 0 6px rgba(255,230,0,0.4);
  z-index: 1555;
}

/* Pressed / active state — button depresses into console */
.icon:active {
  box-shadow:
    inset 2px 3px 5px rgba(0,0,0,0.4),
    inset 0 1px 2px rgba(0,0,0,0.2);
  background:
    linear-gradient(145deg, #ddd5c0 0%, #e8e0cc 100%);
  border-color: #5a5444 #a8a090 #e8e0d0 #8a8270;
}

/* Keyboard focus */
.icon:focus-visible {
  outline: 3px solid #ffbf00;
}

/* small tooltip under icons */
.icon[data-label]::before {
  content: attr(data-label);
  position: absolute;
  bottom: -24px;
  left: 50%;
  translate: -50% 0;
  font: 12px "Courier New", monospace;
  background: #000;
  color: #fff;
  padding: 2px 6px;
  border-radius: 4px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity .15s;
  z-index: 10000;
}

.icon:hover::before,
.icon:focus-visible::before {
  opacity: 1;
}

/* 4-D Shape settings mini-panel */
.shape-settings {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.shape-settings label {
  font-size: 12px;
  text-align: center;
  display: block;
  color: #2a2520;
  text-shadow: 0 1px 0 rgba(255,255,255,0.4);
}

.shape-settings input[type="color"],
.shape-settings input[type="number"] {
  margin-top: 2px;
  width: 40px;
  min-width: 0;
  border: 2px solid;
  border-color: #6a6250 #a8a090 #c0b8a0 #7a7260;
  border-radius: 4px;
  box-shadow:
    inset 0 1px 3px rgba(0,0,0,0.25),
    0 1px 0 rgba(255,255,255,0.3);
}

.window.ipad input[type="color"] {
  border: 1px solid;
  padding: 0;
}

/* 5. Main Drawing Area — deep screen bay */
.main-area {
  flex: 1;
  padding: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

/* Screen bezel — deep inset frame */
.main-area::before {
  content: "";
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border-radius: 14px;
  background:
    linear-gradient(180deg, #2a2520 0%, #3a352e 40%, #2a2520 100%);
  box-shadow:
    inset 0 3px 10px rgba(0,0,0,0.6),
    inset 0 -2px 6px rgba(255,255,255,0.08),
    inset 4px 0 8px rgba(0,0,0,0.3),
    inset -4px 0 8px rgba(0,0,0,0.3);
  border: 3px solid;
  border-color: #1a1815 #4a4438 #5a5448 #2a2820;
  z-index: 0;
  pointer-events: none;
}

/* Screen wrapper — CRT-style recessed display */
#glCanvas {
  width: 500px;
  height: 500px;
  border-radius: 8px;
  border: 3px solid #111;
  display: block;
  margin: 0 auto 8px;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-user-drag: none;
  touch-action: none;
  position: relative;
  z-index: 1;
  box-shadow:
    0 0 0 4px #2a2520,
    0 0 0 7px #4a4438,
    0 0 0 9px #1a1815,
    inset 0 0 20px rgba(0,0,0,0.3),
    0 0 15px rgba(0,0,0,0.4),
    0 0 30px rgba(0,0,0,0.2),
    0 0 40px rgba(80,120,200,0.08),
    0 0 60px rgba(80,120,200,0.05);
}


/* 6. Bottom Slider Panel — 3D lower control bay */
.bottom-panel {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  border-top: none;
  padding: 6px 8px;
  background:
    linear-gradient(180deg, #cac3b0 0%, #d5ceb8 30%, #cac3b0 100%);
  text-align: center;
  border-radius: 14px;
  margin-top: 16px;
  border: 3px solid;
  border-color: #6a6250 #a09880 #c0b8a0 #7a7260;
  box-shadow:
    inset 0 3px 8px rgba(0,0,0,0.35),
    inset 0 -1px 2px rgba(255,255,255,0.3),
    inset 3px 0 5px rgba(0,0,0,0.1),
    inset -2px 0 4px rgba(0,0,0,0.08),
    0 1px 0 rgba(255,255,255,0.3);
}

/* Drum Pad Styles — 3D rubber pads */
.drum-pad {
  width: 120px;
  height: 120px;
  border-radius: 14px;
  border: 2px solid;
  border-color: #e8e0d0 #7a7264 #5a5444 #a0988a;
  background:
    linear-gradient(145deg, #faf6ec 0%, #e8e0cc 50%, #d8d0bc 100%);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 18px;
  user-select: none;
  position: relative;
  box-shadow:
    3px 4px 8px rgba(0,0,0,0.35),
    1px 2px 3px rgba(0,0,0,0.2),
    inset 0 2px 3px rgba(255,255,255,0.6),
    inset 0 -1px 2px rgba(0,0,0,0.1);
  transition: all 0.1s ease;
}

.drum-pad:hover {
  transform: translateY(-1px);
  box-shadow:
    4px 5px 10px rgba(0,0,0,0.4),
    2px 3px 4px rgba(0,0,0,0.2),
    inset 0 2px 3px rgba(255,255,255,0.6),
    inset 0 -1px 2px rgba(0,0,0,0.1);
}

.drum-pad:active {
  transform: translateY(2px);
  box-shadow:
    inset 2px 3px 6px rgba(0,0,0,0.35),
    inset 0 1px 2px rgba(0,0,0,0.2);
  border-color: #5a5444 #a0988a #e8e0d0 #7a7264;
}

.drum-pad.active {
  background: #ffd700;
  animation: drumPadPulse 0.3s ease-out;
}

@keyframes drumPadPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.drum-pad-label {
  font-family: "Courier New", monospace;
  color: #000;
  text-align: center;
}

#sliders > div {
  display: flex;
  align-items: center;
  margin: 8px 0;
}

/* labels — embossed console labels */
#sliders label {
  width: 250px;
  text-align: center;
  margin-right: 8px;
  color: #2a2520;
  font-weight: 700;
  letter-spacing: 0.8px;
  text-shadow:
    0 1px 0 rgba(255,255,255,0.4),
    0 -1px 0 rgba(0,0,0,0.1);
}

#sliders label span {
  display: inline-block;
  font-weight: bold;
  vertical-align: middle;
}

/* range track + thumb: physical fader grooves */
input[type="range"] {
  -webkit-appearance: none;
  width: 300px;
  height: 12px;
  border-radius: 6px;
  background:
    linear-gradient(180deg, #b8b0a0 0%, #d0c8b8 50%, #c0b8a8 100%);
  border: 2px solid;
  border-color: #6a6250 #a8a090 #c0b8a0 #7a7260;
  box-shadow:
    inset 0 2px 4px rgba(0,0,0,0.35),
    inset 0 -1px 1px rgba(255,255,255,0.3),
    0 1px 0 rgba(255,255,255,0.2);
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 28px;
  background:
    linear-gradient(180deg, #7a7268 0%, #5a5448 50%, #4a4238 100%);
  border: 2px solid;
  border-color: #8a8278 #3a3630 #2a2620 #5a5448;
  border-radius: 4px;
  cursor: pointer;
  margin-top: -10px;
  box-shadow:
    1px 2px 4px rgba(0,0,0,0.45),
    inset 0 1px 1px rgba(255,255,255,0.2),
    inset 0 -1px 1px rgba(0,0,0,0.2);
}

input[type="range"]::-moz-range-thumb {
  width: 18px;
  height: 26px;
  background:
    linear-gradient(180deg, #7a7268 0%, #5a5448 50%, #4a4238 100%);
  border: 2px solid;
  border-color: #8a8278 #3a3630 #2a2620 #5a5448;
  border-radius: 4px;
  cursor: pointer;
  box-shadow:
    1px 2px 4px rgba(0,0,0,0.45),
    inset 0 1px 1px rgba(255,255,255,0.2),
    inset 0 -1px 1px rgba(0,0,0,0.2);
}

/* 7. Dialogs & Modals (desktop look, keep behavior) */
.dialog-backdrop {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.4);
  justify-content: center;
  align-items: center;
  z-index: 5000;
}

.dialog-content {
  background:
    linear-gradient(180deg, #f5eeda 0%, #e8e0cc 100%);
  border: 3px solid;
  border-color: #d0c8b8 #6a6250 #4a4238 #8a8270;
  padding: 16px;
  min-width: 200px;
  text-align: center;
  box-shadow:
    4px 6px 16px rgba(0,0,0,0.45),
    1px 2px 4px rgba(0,0,0,0.25),
    inset 0 1px 2px rgba(255,255,255,0.5);
  font-family: "Courier New", monospace;
  border-radius: 10px;
}

.dialog-content button {
  margin-top: 12px;
  font-family: inherit;
  cursor: pointer;
  border-radius: 6px;
  border: 2px solid;
  border-color: #d0c8b4 #7a7264 #5a5444 #a0988a;
  background:
    linear-gradient(180deg, #faf6ec 0%, #e0d8c4 100%);
  box-shadow:
    1px 2px 3px rgba(0,0,0,0.3),
    inset 0 1px 1px rgba(255,255,255,0.5);
  transition: all 0.1s ease;
}

.dialog-content button:active {
  background:
    linear-gradient(180deg, #d5ceb8 0%, #e0d8c4 100%);
  box-shadow:
    inset 1px 2px 3px rgba(0,0,0,0.3);
  border-color: #5a5444 #a0988a #d0c8b4 #7a7264;
}

/* Appearance Dialog Styles */
.appearance-dialog {
  min-width: 500px;
  max-width: 600px;
}

.appearance-dialog-content {
  display: flex;
  gap: 24px;
  margin: 16px 0;
}

.appearance-controls {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0;
}

.appearance-section {
  padding-bottom: 4px;
}

.appearance-control-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.appearance-control-group label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
}

.appearance-checkbox-row {
  display: flex;
  gap: 20px;
  margin-bottom: 4px;
}

.appearance-checkbox-label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  cursor: pointer;
}

.appearance-checkbox-label input[type="checkbox"] {
  cursor: pointer;
}

.appearance-control-group input[type="range"] {
  width: 100%;
}

.appearance-preview {
  flex: 0 0 220px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.appearance-preview h4 {
  margin: 0;
  font-size: 14px;
}

#appearancePreviewCanvas {
  border: 2px solid;
  border-color: #6a6250 #a8a090 #c0b8a0 #7a7260;
  border-radius: 4px;
  background: #fff;
  box-shadow:
    inset 0 1px 3px rgba(0,0,0,0.2),
    1px 2px 4px rgba(0,0,0,0.2);
}

.appearance-dialog-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 16px;
}

.appearance-dialog-buttons button {
  margin-top: 0;
  padding: 6px 16px;
}

/* 8. Splash Overlay */
#splashOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  cursor: pointer;
}

#splashOverlay img {
  max-width: 50%;
  max-height: 50%;
  pointer-events: none;
  margin-bottom: 50px;
  border: 2px solid #000;
  border-radius: 6px;
  padding: 0px;
}

.splashText {
  font-family: "Courier New", monospace;
  font-size: 18px;
  font-weight: bold;
  color: #1a1612;
  background:
    linear-gradient(180deg, #e8e0cc 0%, #d3cbb7 100%);
  padding: 8px 14px;
  border: 2px solid;
  border-color: #d8d0bc #7a7264 #5a5444 #a0988a;
  box-shadow:
    2px 3px 6px rgba(0,0,0,0.4),
    inset 0 1px 1px rgba(255,255,255,0.5);
  border-radius: 6px;
  user-select: none;
  text-shadow: 0 1px 0 rgba(255,255,255,0.4);
}

/* 9. Help Icon & Tooltip */
.inline-icon {
  width: 16px;
  height: 16px;
  vertical-align: middle;
  margin: 0 4px;
}

.help-icon-container {
  position: relative;
  display: inline-block;
}

.help-icon {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background:
    radial-gradient(circle at 40% 35%, #e8e0d0, #c0b8a4);
  border: 1px solid #6a6250;
  color: #2a2520;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  line-height: 20px;
  cursor: help;
  user-select: none;
  box-shadow:
    1px 1px 2px rgba(0,0,0,0.3),
    inset 0 1px 1px rgba(255,255,255,0.5);
}

.help-tooltip {
  display: none;
  position: absolute;
  bottom: 20px;
  left: 0;
  min-width: 120px;
  background:
    linear-gradient(180deg, #f8f2e4 0%, #ede6d2 100%);
  color: #1a1612;
  border: 2px solid;
  border-color: #d0c8b8 #7a7264 #5a5444 #a0988a;
  padding: 4px 6px;
  font-size: 12px;
  box-shadow:
    2px 3px 8px rgba(0,0,0,0.4),
    inset 0 1px 1px rgba(255,255,255,0.5);
  border-radius: 4px;
  z-index: 999999;
}

.help-icon-container:hover .help-tooltip {
  display: block;
  z-index: 99999;
}

/* 10. Cursor Modes (unchanged behavior) */
canvas {
	-webkit-user-select: none;
	user-select: none;
	-webkit-touch-callout: none;
}

.canvas-blob-mode {
  cursor: url("images/pencil.png"), auto;
}
.canvas-line-mode {
  cursor: url("images/pencil.png"), auto;
}
.canvas-circle-mode {
  cursor: url("images/CircleCursor.png"), auto;
}
.canvas-attractor-mode,
.canvas-repulsor-mode {
  cursor: url("images/pencil.png"), auto;
}
.canvas-particle-mode {
  cursor: crosshair;
}
.canvas-drag-mode {
  cursor: url("images/glove.png"), auto;
}
.canvas-pin-mode {
  cursor: url("images/PinCursor.png"), auto;
}
.canvas-slicing-mode {
  cursor: url("images/trim.png"), auto;
}
.canvas-freeze-mode {
  cursor: url("images/FreezeCursor.png"), auto;
}
.canvas-delete-mode {
  cursor: url("images/DeleteCursor.png"), auto;
}

#iconSlice {
    display: none !important;
}

/* 11. Mobile-only Warning (kept as-is) */
#mobileWarning {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #fff;
  color: #000;
  font-family: sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  z-index: 10000;
  padding: 20px;
}

/* 12. Toast notifications (keep placement, recolor) */
#toastStack {
  position: absolute;
  top: 48px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
  pointer-events: none;
  z-index: 2000;
}

.toast {
  font: 14px "Courier New", monospace;
  background:
    linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
  color: #e8e0cc;
  padding: 6px 10px;
  border-radius: 6px;
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity .2s, transform .2s;
  border: 1px solid #4a4a4a;
  box-shadow:
    2px 3px 8px rgba(0,0,0,0.5),
    inset 0 1px 1px rgba(255,255,255,0.1);
}

.toast.show {
  opacity: .9;
  transform: translateY(0);
}

/* 13. Guided tour highlight (unchanged) */
#tourOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, .55);
  z-index: 3000;
  pointer-events: none;
}

#tourTip {
  position: fixed;
  z-index: 3001;
  max-width: 320px;
  font: 13px "Courier New", monospace;
  background:
    linear-gradient(180deg, #f5eeda 0%, #e8e0cc 100%);
  color: #1a1612;
  border: 2px solid;
  border-color: #d0c8b8 #7a7264 #5a5444 #a0988a;
  border-radius: 8px;
  padding: 10px 12px;
  box-shadow:
    3px 4px 10px rgba(0,0,0,0.4),
    inset 0 1px 1px rgba(255,255,255,0.5);
}

#tourCtrls {
  margin-top: 8px;
  text-align: right;
}

#tourCtrls button {
  font: inherit;
  margin-left: 4px;
  cursor: pointer;
}

.tour-highlight {
  outline: 3px solid #ffe600 !important;
  box-shadow: 0 0 8px 3px #ffe600 !important;
}

/* 14. Presets gallery (frame matches console) */
.presets-gallery {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 12px;
  padding: 4px;
  max-height: 60vh;
  overflow-y: auto;
}

.preset-card {
  aspect-ratio: 1/1;
  background: #fafafa;
  border: 2px solid;
  border-color: #d0c8b8 #7a7264 #5a5444 #a0988a;
  box-shadow:
    2px 3px 6px rgba(0,0,0,0.35),
    inset 0 1px 1px rgba(255,255,255,0.4);
  position: relative;
  transition: transform .15s, box-shadow .15s;
  border-radius: 4px;
  overflow: hidden;
}

.preset-card:hover {
  transform: translateY(-2px);
  box-shadow:
    3px 5px 10px rgba(0,0,0,0.4),
    inset 0 1px 1px rgba(255,255,255,0.4);
}

.preset-card:active {
  transform: translateY(1px);
  box-shadow:
    1px 1px 3px rgba(0,0,0,0.3);
}

.preset-card img,
.preset-card svg {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.preset-card figcaption {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, .58);
  color: #fff;
  font: 12px "Courier New", monospace;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 4px;
  opacity: 0;
  transition: opacity .15s;
}

.preset-card:hover figcaption {
  opacity: 1;
}

.preset-card.card-selected {
  outline: 3px solid #ffe600;
  box-shadow: 0 0 10px 3px #ffe600;
  transform: none;
}

/* ---------- 3D Console Accent Details ---------- */

/* Subtle parting line / mold seam around the console */
.content {
  position: relative;
}

/* (vent grille removed) */

/* (brand emboss removed) */

/* Smooth hover lift for entire console */
.window {
  transition: transform 0.3s ease;
}

/* ---------- Fullscreen Mode Styles ---------- */
body.fullscreen-mode {
  padding: 0;
  overflow: hidden;
  background: #1a1a1a;
}

body.fullscreen-mode .window {
  width: 100%;
  height: 100vh;
  max-width: none;
  margin: 0;
  padding: 0;
  border-radius: 0;
  border: none;
  box-shadow: none;
  background: #1a1a1a;
  display: flex;
  flex-direction: column;
  transform: none;
}

body.fullscreen-mode .window::before,
body.fullscreen-mode .window::after {
  display: none;
}

body.fullscreen-mode .main-area::before {
  display: none;
}

body.fullscreen-mode .toolbar::after,
body.fullscreen-mode .bottom-panel::after {
  display: none;
}

body.fullscreen-mode .title-bar::after {
  display: none;
}

body.fullscreen-mode .content::before {
  display: none;
}

body.fullscreen-mode {
  perspective: none;
  background: #1a1a1a;
}

body.fullscreen-mode .title-bar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10000;
  background: rgba(30, 30, 30, 0.95);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 0;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  padding: 8px 16px;
}

/* White text for menu items in fullscreen */
body.fullscreen-mode .title-bar .menu-bar span {
  color: #ffffff;
}

body.fullscreen-mode .title-bar .menu-bar span:hover {
  color: #ffffff;
  text-decoration: underline;
}

body.fullscreen-mode .title-bar .submenu span {
  color: #000000; /* Keep submenu items black for readability */
}

body.fullscreen-mode .title-bar .submenu span:hover {
  color: #000000;
}

body.fullscreen-mode .content {
  flex: 1;
  margin: 0;
  padding: 0;
  display: block;
  position: relative;
  overflow: hidden;
}

body.fullscreen-mode .main-area {
  position: absolute;
  top: 48px; /* Account for title bar height */
  left: 0;
  right: 0;
  bottom: 0;
  padding: 0;
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #1a1a1a;
}

body.fullscreen-mode #glCanvas {
  width: 100vw !important;
  height: calc(100vh - 48px) !important; /* Subtract title bar height */
  max-width: 100vw;
  max-height: calc(100vh - 48px);
  border: none;
  border-radius: 0;
  box-shadow: none;
  background: #1a1a1a;
  margin: 0;
}

/* Draggable Floating Panels */
body.fullscreen-mode .toolbar,
body.fullscreen-mode .bottom-panel {
  position: fixed;
  z-index: 9999;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  border-radius: 16px;
  padding: 16px;
  cursor: move;
  user-select: none;
  transition: box-shadow 0.2s ease, opacity 0.3s ease, transform 0.3s ease;
}

/* Dialogs should appear above panels in fullscreen mode */
body.fullscreen-mode .dialog-backdrop {
  z-index: 10001 !important;
}

body.fullscreen-mode .toolbar {
  width: 200px;
  min-width: 180px;
  max-width: 400px;
  left: 20px;
  top: 60px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  overflow-x: hidden;
  padding-top: 36px; /* Extra space at top for minimize button */
}

body.fullscreen-mode .toolbar:hover {
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
}

body.fullscreen-mode .toolbar.dragging {
  cursor: grabbing;
  opacity: 0.9;
}

body.fullscreen-mode .bottom-panel {
  width: auto;
  min-width: 500px;
  max-width: 800px;
  right: 20px;
  bottom: 20px;
  padding: 20px;
  padding-top: 36px; /* Extra space at top for minimize button */
}

body.fullscreen-mode .bottom-panel:hover {
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
}

body.fullscreen-mode .bottom-panel.dragging {
  cursor: grabbing;
  opacity: 0.9;
}

/* Panel Header for Dragging */
body.fullscreen-mode .toolbar::before,
body.fullscreen-mode .bottom-panel::before {
  content: "⋮⋮";
  display: block;
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(0, 0, 0, 0.3);
  font-size: 18px;
  line-height: 1;
  cursor: grab;
  user-select: none;
}

body.fullscreen-mode .toolbar::before {
  top: 4px;
}

body.fullscreen-mode .toolbar.dragging::before,
body.fullscreen-mode .bottom-panel.dragging::before {
  cursor: grabbing;
}

/* Panel Hide/Dock Functionality - Only in fullscreen mode */
.panel-hide-btn {
  display: none; /* Hidden by default */
}

body.fullscreen-mode .panel-hide-btn {
  display: flex; /* Show only in fullscreen mode */
  position: absolute;
  top: 8px;
  right: 8px;
  width: 24px;
  height: 24px;
  border: none;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: rgba(0, 0, 0, 0.6);
  z-index: 10;
  transition: background 0.2s ease;
}

body.fullscreen-mode .panel-hide-btn:hover {
  background: rgba(0, 0, 0, 0.2);
}

/* Film strip panel minimize button - white for visibility on dark background */
body.fullscreen-mode .filmstrip-panel .panel-hide-btn {
  background: rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

body.fullscreen-mode .filmstrip-panel .panel-hide-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  color: #fff;
  border-color: rgba(255, 255, 255, 0.5);
}

body.fullscreen-mode .filmstrip-panel .panel-hide-btn.panel-restore {
  background: rgba(255, 255, 255, 0.25);
  color: #fff;
  border-color: rgba(255, 255, 255, 0.4);
}

body.fullscreen-mode .toolbar.panel-hidden,
body.fullscreen-mode .bottom-panel.panel-hidden,
body.fullscreen-mode .filmstrip-panel.panel-hidden {
  width: 40px !important;
  height: 40px !important;
  min-width: 40px !important;
  max-width: 40px !important;
  padding: 8px !important;
  overflow: hidden;
  opacity: 0.5;
  transition: all 0.3s ease;
}

body.fullscreen-mode .toolbar.panel-hidden .toolbar-section,
body.fullscreen-mode .toolbar.panel-hidden .toolbar-section *,
body.fullscreen-mode .bottom-panel.panel-hidden #sliders,
body.fullscreen-mode .bottom-panel.panel-hidden #sliders *,
body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-header,
body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-header *,
body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-container,
body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-container * {
  display: none !important;
}

body.fullscreen-mode .toolbar.panel-hidden::before,
body.fullscreen-mode .bottom-panel.panel-hidden::before,
body.fullscreen-mode .filmstrip-panel.panel-hidden::before {
  display: none;
}

body.fullscreen-mode .panel-hide-btn.panel-restore {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 32px;
  height: 32px;
  background: rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  font-size: 18px;
}

body.fullscreen-mode .panel-hide-btn.panel-restore:hover {
  background: rgba(0, 0, 0, 0.25);
}

/* Film strip panel restore button - white for visibility */
body.fullscreen-mode .filmstrip-panel .panel-hide-btn.panel-restore {
  background: rgba(255, 255, 255, 0.3);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.4);
}

body.fullscreen-mode .filmstrip-panel .panel-hide-btn.panel-restore:hover {
  background: rgba(255, 255, 255, 0.4);
  border-color: rgba(255, 255, 255, 0.6);
}

/* Hide title bar menu in fullscreen (optional - or keep it minimal) */
body.fullscreen-mode .menu-bar {
  opacity: 0.7;
}

body.fullscreen-mode .menu-bar:hover {
  opacity: 1;
}

/* Fullscreen icon active state */
#fullscreenIcon.active {
  background-color: #3b82f6;
  color: #000;
  border-color: #3b82f6;
}

/* Sound FX toggle icon */
#sfxToggle {
  font-size: 16px;
  transition: background-color 0.2s ease, transform 0.15s ease;
}
#sfxToggle:active {
  transform: scale(0.92);
}
#sfxToggle.sfx-on {
  background:
    linear-gradient(180deg, #d4edda 0%, #b8dcc2 100%);
  border-color: #28a745;
  box-shadow:
    1px 2px 4px rgba(0,0,0,0.3),
    inset 0 1px 2px rgba(255,255,255,0.5),
    0 0 8px rgba(40, 167, 69, 0.25);
}

/* ---------- Dark Canvas – slider track & text overrides ---------- */
body.dark-canvas input[type="range"] {
  background: rgba(255, 255, 255, 0.25) !important;
  border-color: rgba(255, 255, 255, 0.35) !important;
}

/* ---------- Presentation Mode Styles ---------- */
body.presentation-mode .toolbar,
body.presentation-mode .bottom-panel,
body.presentation-mode .window .title-bar,
body.presentation-mode .panel-toggle {
  display: none !important;
}

/* Presentation mode instruction overlay */
#presentationModeInstruction {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1000000 !important;
  font-size: 48px;
  font-weight: bold;
  color: #ffffff;
  text-align: center;
  text-shadow:
    0 0 10px rgba(0, 0, 0, 0.8),
    0 0 20px rgba(0, 0, 0, 0.6),
    2px 2px 4px rgba(0, 0, 0, 0.9);
  pointer-events: none;
  user-select: none;
  font-family: "Courier New", monospace;
  background: rgba(0, 0, 0, 0.7);
  padding: 30px 60px;
  border-radius: 20px;
  border: 3px solid #ffffff;
  box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
  display: none;
  animation: presentationModeFlash 1s ease-in-out infinite;
}

@keyframes presentationModeFlash {
  0%, 100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  50% {
    opacity: 0.7;
    transform: translate(-50%, -50%) scale(1.05);
  }
}

body.presentation-mode #presentationModeInstruction.showing {
  display: block !important;
}

/* Presentation mode exit button (iPad) — small X in top-right corner */
#presentationExitBtn {
  position: fixed;
  top: 18px;
  right: 18px;
  z-index: 1000001;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.45);
  color: #fff;
  font-size: 22px;
  line-height: 1;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}
body.presentation-mode #presentationExitBtn.showing {
  display: flex !important;
  opacity: 0.55;
  pointer-events: auto;
}
body.presentation-mode #presentationExitBtn:hover,
body.presentation-mode #presentationExitBtn:active {
  opacity: 1;
  background: rgba(0,0,0,0.7);
}

/* Smooth transitions */
body.fullscreen-mode .toolbar,
body.fullscreen-mode .bottom-panel {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* Scrollbar styling for floating panels */
body.fullscreen-mode .toolbar::-webkit-scrollbar {
  width: 8px;
}

body.fullscreen-mode .toolbar::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
}

body.fullscreen-mode .toolbar::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

body.fullscreen-mode .toolbar::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

/* Film Strip Panel - Right Side (Fullscreen Only) */
.filmstrip-panel {
  display: none; /* Hidden by default */
}

body.fullscreen-mode.filmstrip-unlocked .filmstrip-panel {
  display: flex;
  flex-direction: column;
  position: fixed;
  right: 20px;
  top: 60px;
  width: 280px;
  min-width: 250px;
  max-width: 350px;
  height: auto;
  max-height: calc(100vh - 80px); /* Stop growing at bottom of viewport */
  z-index: 9999;
  background: rgba(20, 20, 20, 0.95);
  backdrop-filter: blur(20px);
  border: 2px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  border-radius: 16px;
  padding: 16px;
  padding-top: 36px;
  cursor: move;
  user-select: none;
  transition: box-shadow 0.2s ease, opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease;
}

body.fullscreen-mode .filmstrip-panel:hover {
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
}

body.fullscreen-mode .filmstrip-panel.dragging {
  cursor: grabbing;
  opacity: 0.9;
}

body.fullscreen-mode .filmstrip-panel::before {
  content: "⋮⋮";
  display: block;
  position: absolute;
  top: 4px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.4);
  font-size: 18px;
  line-height: 1;
  cursor: grab;
  user-select: none;
}

body.fullscreen-mode .filmstrip-panel.dragging::before {
  cursor: grabbing;
}

.filmstrip-header {
  margin-bottom: 12px;
}

.filmstrip-header h4 {
  color: #fff;
  margin: 0 0 10px 0;
  font-size: 14px;
  font-weight: bold;
  text-align: center;
}

.filmstrip-journey {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 4px;
  margin-bottom: 10px;
  font-size: 11px;
  color: rgba(255, 255, 255, 0.7);
  text-align: center;
}

.filmstrip-journey span {
  line-height: 1.2;
}

.filmstrip-controls {
  display: flex;
  gap: 8px;
  justify-content: center;
  flex-wrap: wrap;
}

.filmstrip-btn {
  width: 36px;
  height: 36px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
  user-select: none;
}

.filmstrip-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
  transform: scale(1.1);
}

.filmstrip-btn:active {
  transform: scale(0.95);
}

.filmstrip-btn.play-btn {
  background: rgba(76, 175, 80, 0.3);
  border-color: rgba(76, 175, 80, 0.6);
}

.filmstrip-btn.play-btn:hover {
  background: rgba(76, 175, 80, 0.5);
  border-color: rgba(76, 175, 80, 0.8);
}

.filmstrip-btn.record-btn {
  background: rgba(220, 53, 69, 0.3);
  border-color: rgba(220, 53, 69, 0.6);
}

.filmstrip-btn.record-btn:hover {
  background: rgba(220, 53, 69, 0.5);
  border-color: rgba(220, 53, 69, 0.8);
}

.filmstrip-btn.record-btn.recording {
  background: rgba(220, 53, 69, 0.7);
  border-color: rgba(220, 53, 69, 1);
  animation: pulse-red 1s infinite;
}

@keyframes pulse-red {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.filmstrip-container {
  position: relative;
  flex: 0 0 auto;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  /* Fixed height for 3 frames: 3 frames * (150px height + 8px gap) + 40px padding = 514px */
  height: 514px;
  min-height: 514px;
  max-height: 514px;
  display: flex;
  flex-direction: column;
}

/* Collapsed state for playback - single frame view */
body.fullscreen-mode .filmstrip-panel.playing {
  width: 250px;
  min-width: 250px;
  max-width: 250px;
  transition: width 0.3s ease, min-width 0.3s ease, max-width 0.3s ease;
}

body.fullscreen-mode .filmstrip-panel.playing .filmstrip-container {
  height: 200px;
  min-height: 200px;
  max-height: 200px;
  transition: height 0.3s ease, min-height 0.3s ease, max-height 0.3s ease;
}

body.fullscreen-mode .filmstrip-panel.playing .filmstrip-frames {
  display: none;
}

/* Ensure frames are visible when not playing */
body.fullscreen-mode .filmstrip-panel:not(.playing) .filmstrip-frames {
  display: flex;
}

body.fullscreen-mode .filmstrip-panel.playing .filmstrip-window {
  display: none;
}

.filmstrip-single-frame {
  display: none;
  width: 100%;
  height: 100%;
  object-fit: contain;
  background: #fff;
  border-radius: 8px;
}

body.fullscreen-mode .filmstrip-panel.playing .filmstrip-single-frame {
  display: block;
  border: 3px solid #ffd700;
  box-shadow:
    0 0 30px rgba(255, 215, 0, 0.8),
    inset 0 0 30px rgba(255, 215, 0, 0.3);
}

body.fullscreen-mode .filmstrip-panel.playing .filmstrip-single-frame {
  display: block;
}

.filmstrip-window {
  display: none; /* Hidden by default, only shown when needed */
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 200px;
  height: 150px;
  border: 3px solid #ffd700;
  border-radius: 4px;
  box-shadow:
    0 0 20px rgba(255, 215, 0, 0.6),
    inset 0 0 20px rgba(255, 215, 0, 0.2);
  z-index: 10;
  pointer-events: none;
  background: rgba(255, 215, 0, 0.05);
}

.filmstrip-frames {
  position: relative;
  width: 100%;
  min-height: 0; /* Allow shrinking */
  overflow-y: auto;
  overflow-x: hidden;
  padding: 20px 12px 20px 0; /* Extra right padding for scrollbar */
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  transition: transform 0.1s linear;
  /* Ensure scrollbar is always visible when content overflows */
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.7) rgba(0, 0, 0, 0.5);
}

/* Container height is fixed at 3 frames, no need for dynamic resizing */

.filmstrip-frames::-webkit-scrollbar {
  width: 10px;
}

.filmstrip-frames::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.4);
  border-radius: 5px;
  margin: 10px 0;
}

.filmstrip-frames::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.6);
  border-radius: 5px;
  border: 1px solid rgba(0, 0, 0, 0.3);
  min-height: 30px;
}

.filmstrip-frames::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.8);
}

.filmstrip-frames::-webkit-scrollbar-thumb:active {
  background: rgba(255, 255, 255, 0.9);
}

.filmstrip-frame {
  position: relative;
  width: 200px;
  height: 150px;
  background: #000;
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  overflow: visible;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.filmstrip-frame-delete {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 24px;
  height: 24px;
  background: rgba(255, 0, 0, 0.8);
  border: 2px solid #fff;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  color: #fff;
  z-index: 20;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
  user-select: none;
}

.filmstrip-frame:hover .filmstrip-frame-delete {
  opacity: 1;
}

.filmstrip-frame-delete:hover {
  background: rgba(255, 0, 0, 1);
  transform: scale(1.1);
}

.filmstrip-frame-delete:active {
  transform: scale(0.9);
}

.filmstrip-frame:hover {
  border-color: rgba(255, 255, 255, 0.5);
  transform: scale(1.05);
  z-index: 5;
}

.filmstrip-frame.active {
  border-color: #ffd700;
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.filmstrip-frame img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  background: #fff;
}

.filmstrip-frame-number {
  position: absolute;
  bottom: 4px;
  right: 4px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 10px;
  font-weight: bold;
}

body.fullscreen-mode .filmstrip-panel.panel-hidden {
  width: 40px !important;
  height: 40px !important;
  min-width: 40px !important;
  max-width: 40px !important;
  padding: 8px !important;
  overflow: hidden;
  opacity: 0.5;
  transition: all 0.3s ease;
}

body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-header,
body.fullscreen-mode .filmstrip-panel.panel-hidden .filmstrip-container {
  display: none !important;
}

body.fullscreen-mode .filmstrip-panel.panel-hidden::before {
  display: none;
}

		/* ---------- iPad overrides (full ipad.css wrapped; no transformation) ---------- */
		@supports (-webkit-touch-callout: none) {
			@media (hover: none) and (pointer: coarse) {

				/* =========================================================
 BlobSketch CSS — Modern iPad Full-Screen Layout
 ========================================================= */

				/* ------------------ 0. Tokens / Theme ------------------ */
				:root {
					/* Modern palette */
					--bg: #ffffff;
					--panel: rgba(255, 255, 255, 0.95);
					--panel-2: rgba(255, 255, 255, 0.9);
					--panel-glass: rgba(255, 255, 255, 0.1);
					--panel-glass-border: rgba(255, 255, 255, 0.2);
					--text: #1a1a1a;
					--muted: #6b7280;
					--accent: #3b82f6;
					--accent-hover: #2563eb;
					--border: rgba(0, 0, 0, 0.08);
					--shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
					--shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
					--shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
					--shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.2);
					--backdrop-blur: blur(20px);
					--backdrop-blur-strong: blur(24px);

					/* Sizing */
					--radius-sm: 8px;
					--radius-md: 12px;
					--radius-lg: 16px;
					--radius-xl: 20px;
					--gap-1: 8px;
					--gap-2: 12px;
					--gap-3: 16px;

					/* Icon */
					--icon-size: 44px;

					/* Panel widths */
					--panel-left-width: calc(var(--icon-size) + var(--gap-2) * 2); /* Single icon width */
					--panel-bottom-height: 200px; /* Increased to fit all sliders */

					/* Z-index */
					--z-submenu: 100900;
					--z-dialog: 2000;
					--z-splash: 9999;
					--z-panel: 100;
					--z-toggle: 200;
				}

				/* ------------------ 1. Base / Reset ------------------ */
				* {
					box-sizing: border-box;
				}

				html,
				body {
					height: 100%;
					overflow: hidden;
				}

				body {
					margin: 0;
					padding: 0;
					background: var(--bg);
					perspective: none;
					color: var(--text);
					font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
				}

				img {
					max-width: 100%;
					display: block;
				}

				button {
					font: inherit;
					cursor: pointer;
				}

				/* Prevent gesture scrolling on canvas-driven apps where needed */
				#glCanvas {
					-webkit-user-select: none;
					-moz-user-select: none;
					user-select: none;
					-webkit-user-drag: none;
					touch-action: none;
				}

				/* ------------------ 2. App Shell ------------------ */
				.window {
					width: min(1100px, 96vw);
					margin: 28px auto;
					background: var(--panel);
					border: 1px solid var(--border);
					border-radius: 14px;
					box-shadow: 0 12px 28px rgba(0, 0, 0, 0.10);
					position: relative;
					overflow: clip;
				}

				.title-bar {
					height: 48px;
					padding: 8px 12px;
					display: flex;
					align-items: center;
					gap: 12px;
					background: linear-gradient(180deg, #ffffff, #f5f6f8);
					border-bottom: 1px solid var(--border);
				}

				.menu-bar {
					display: flex;
					gap: 16px;
				}

				.menu-bar span {
					font-weight: 600;
					cursor: pointer;
					position: relative;
				}

				.menu-bar span:hover {
					text-decoration: underline;
				}



				.title-actions {
					margin-left: auto;
					/* <-- pushes to the far right */
					display: flex;
					align-items: center;
					gap: 8px;
				}

				/* Make the icons render tightly without extra width */
				.reset-icon {
					display: inline-flex;
					align-items: center;
					justify-content: center;
					width: 32px;
					height: 32px;
					padding: 0;
					margin-left: auto;
					font-weight: bold;
					font-size: 18px;
					user-select: none;
					}

				/* Submenus */
				.submenu {
					display: none;
					position: absolute;
					top: 24px;
					left: 0;
					min-width: 160px;
					background: var(--panel-2);
					border: 1px solid var(--border);
					border-radius: 10px;
					padding: 8px;
					z-index: var(--z-submenu);
				}

				.submenu span {
					display: block;
					padding: 4px 6px;
					border-radius: var(--radius-sm);
					cursor: pointer;
				}

				.submenu span:hover {
					background: rgba(0, 0, 0, .04);
				}

				/* Content columns (Desktop default) */
				.content {
					display: grid;
					grid-template-columns: 260px 1fr;
					gap: var(--gap-3);
					padding: var(--gap-3);
				}

				/* ------------------ 3. Toolbar & Sections ------------------ */
				.toolbar {
					display: flex;
					flex-direction: column;
					gap: var(--gap-3);
					background: transparent;
					border: 0;
					padding: 0;
				}

				.toolbar-section {
					background: var(--panel-2);
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					padding: 10px;
				}

				.toolbar-section h4 {
					margin: 0 0 8px;
					font-size: 12px;
					font-weight: 600;
					color: var(--muted);
				}

				.toolbar-section .icon-group {
					display: flex;
					flex-wrap: wrap;
					gap: var(--gap-1);
				}

				/* Edit tools "glow" when active group is engaged - removed red highlight */
				#editToolsSection.edit-on {
					/* Red highlight removed */
				}

				/* ------------------ 4. Icons ------------------ */
				.icon {
					width: var(--icon-size);
					height: var(--icon-size);
					display: flex;
					align-items: center;
					justify-content: center;
					border-radius: var(--radius-md);
					border: 1px solid rgba(0, 0, 0, 0.12);
					background: #f7f8fa;
					/* light tile */
					box-shadow:
						0 1px 0 rgba(255, 255, 255, 0.7) inset,
						0 8px 18px rgba(0, 0, 0, 0.08);
					transition: transform .12s ease;
					position: relative;
					user-select: none;
				}

				.icon:hover {
					transform: translateY(-1px);
				}

				.icon img {
					width: 100%;
					height: 100%;
					object-fit: contain;
					border-radius: inherit;
					filter: none;
					position: relative;
					z-index: 0;
					/* preserve dark glyphs */
				}

				/* Active icon rim */
				.icon.icon-active {
					background: #ffffff;
					border-color: rgba(37, 99, 235, 0.35);
					box-shadow:
						0 0 0 1px rgba(37, 99, 235, 0.18) inset,
						0 10px 22px rgba(37, 99, 235, 0.12);
				}

				/* Optional “ON” badge */
				.icon.icon-active::after {
					content: "ON";
					position: absolute;
					top: -10px;
					right: -6px;
					font-size: 8px;
					font-weight: 700;
					color: #000;
					background: #ff0;
					border: 1px solid #000;
					border-radius: 4px;
					padding: 2px 4px;
					box-shadow: 2px 2px 0 #000;
					z-index: 100;
				}

				/* Tooltip label under icon (on hover/focus) */
				.icon[data-label]::before {
					content: attr(data-label);
					position: absolute;
					bottom: -24px;
					left: 50%;
					transform: translateX(-50%);
					font: 12px "Courier New", monospace;
					color: #fff;
					background: #111317;
					border: 1px solid rgba(255, 255, 255, 0.18);
					padding: 2px 6px;
					border-radius: var(--radius-sm);
					white-space: nowrap;
					pointer-events: none;
					opacity: 0;
					transition: opacity .15s;
					z-index: 10000;
				}

				.icon:hover::before,
				.icon:focus-visible::before {
					opacity: 1;
				}

				/* iPad: Tooltip to the right of icon - allow overflow onto canvas */
				.window.ipad .icon[data-label]::before {
					position: fixed;
					bottom: auto;
					display: none;
					top: auto;
					transform: translateY(-50%);
					margin-left: 0px;
					white-space: nowrap;
					z-index: -1; /* Higher than panel z-index to appear on top of canvas */
					/* Keep absolute positioning but ensure parent allows overflow */
				}

				/* Ensure icon container allows tooltip overflow */
				.window.ipad .icon-group {
					overflow: visible;
				}

				.window.ipad .toolbar-section {
					overflow: visible;
				}

				.icon:focus-visible {
					outline: 2px solid var(--accent);
					outline-offset: 2px;
				}

				/* ------------------ 5. Main Drawing Area ------------------ */
				.main-area {
					background: var(--panel);
					padding: 8px;
					border-radius: var(--radius-lg);
					display: flex;
					flex-direction: column;
					align-items: center;
				}

				#glCanvas {
					width: 500px;
					height: 500px;
					background: #fff;
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					display: block;
					margin-bottom: 16px;
				}

				/* ------------------ 6. Bottom Sliders Panel ------------------ */
				.bottom-panel {
					background: var(--panel);
					border-top: 1px solid var(--border);
					padding: 10px 12px;
					text-align: start;
					display: flex;
					flex-direction: column;
					align-items: stretch;
					justify-content: flex-start;
					/* was inheriting center from the base rule */
				}

				#sliders {
					display: grid;
					align-content: start;
					/* prevents “sag” inside a tall panel */
					gap: var(--gap-2);
				}

				/* One row per control: label | (optional help) | input */
				#sliders>div {
					display: grid;
					grid-template-columns: max-content max-content 1fr;
					align-items: center;
					/* top-align in grid cells */
					column-gap: 10px;
				}

				/* Keep the info "i" a fixed square and stop stretching */
				#sliders .help-icon-container {
					justify-self: start;
				}

				#sliders .help-icon {
					width: 16px;
					height: 16px;
					line-height: 16px;
				}

				#sliders label {
					width: 220px;
					text-align: right;
					color: var(--muted);
					white-space: nowrap;
				}

				/* Shape-settings: Color + Size side by side */
				.shape-settings {
					display: flex;
					align-items: center;
					gap: 8px;
					flex-direction: row;
					flex-wrap: nowrap;
					/* keep them on one row */
				}

				.shape-settings label {
					margin: 0;
					font-size: 12px;
					white-space: nowrap;
					/* prevent wrapping */
					text-align: left;
					display: inline-block;
				}

				.shape-settings input[type="color"],
				.shape-settings input[type="number"] {
					margin-top: 0;
					width: auto;
					min-width: 60px;
					/* avoids collapse on iPad */
				}

				/* iPad override: still side by side */
				.window.ipad .shape-settings {
					flex-wrap: nowrap;
				}

				/* Range input */
				input[type="range"] {
					-webkit-appearance: none;
					width: 100%;
					height: 8px;
					background: #fff;
					border: 1px solid var(--border);
					border-radius: 999px;

				}

				input[type="range"]::-webkit-slider-thumb {
					-webkit-appearance: none;
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: var(--accent);
					border: none;
					margin-top: -5px;
				}

				input[type="range"]::-moz-range-thumb {
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: var(--accent);
					border: none;
				}

				/* ------------------ 7. Overlays / Dialogs / Toasts ------------------ */
				.dialog-backdrop {
					display: none;
					position: fixed;
					inset: 0;
					background: rgba(0, 0, 0, .55);
					justify-content: center;
					align-items: center;
					z-index: var(--z-dialog);
				}

				.dialog-content {
					background: var(--panel-2);
					color: var(--text);
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					padding: 16px;
					min-width: 200px;
					text-align: center;
					box-shadow: 0 16px 40px rgba(0, 0, 0, .5);
				}

				/* Splash */
				#splashOverlay {
					position: absolute;
					inset: 0;
					background-color: rgba(255, 255, 255, 0.8);
					display: none;
					/* hidden by default; toggle via JS */
					flex-direction: column;
					align-items: center;
					justify-content: center;
					z-index: var(--z-splash);
					cursor: pointer;
				}

				#splashOverlay img {
					max-width: 50%;
					max-height: 50%;
					margin-bottom: 50px;
					border: 2px solid #000;
					border-radius: var(--radius-sm);
				}

				/* Help tooltip bubble */
				.help-icon-container {
					position: relative;
					display: inline-block;
					z-index:9999;
				}

				.help-icon {
					width: 16px;
					height: 16px;
					line-height: 16px;
					text-align: center;
					border-radius: 50%;
					background: #e6e7ea;
					border: 1px solid #000;
					color: #000;
					font-size: 12px;
					font-weight: bold;
					user-select: none;
					cursor: help;
				}

				.help-tooltip {
					display: none;
					position: absolute;
					bottom: 20px;
					left: 0;
					min-width: 120px;
					padding: 4px;
					font-size: 12px;
					color: var(--text);
					background: var(--panel-2);
					border: 1px solid var(--border);
					box-shadow: 0 12px 28px rgba(0, 0, 0, .35);
					z-index: var(--z-splash);
				}

				.help-icon-container:hover .help-tooltip {
					display: block;
					z-index: 99999;
				}

				/* Toasts */
				#toastStack {
					position: absolute;
					top: 48px;
					right: 10px;
					display: flex;
					flex-direction: column;
					gap: 8px;
					align-items: flex-end;
					pointer-events: none;
					z-index: 2000;
				}

				.toast {
					font: 14px "Courier New", monospace;
					background: #0f1115;
					color: #fff;
					border: 1px solid var(--border);
					border-radius: 10px;
					padding: 6px 10px;
					opacity: 0;
					transform: translateY(-8px);
					transition: opacity .2s, transform .2s;
				}

				.toast.show {
					opacity: .9;
					transform: translateY(0);
				}

				/* Guided tour */
				#tourOverlay {
					position: fixed;
					inset: 0;
					background: rgba(0, 0, 0, .55);
					z-index: 3000;
					pointer-events: none;
				}

				#tourTip {
					position: fixed;
					z-index: 3001;
					max-width: 320px;
					background: #fff;
					color: #000;
					border: 2px solid #000;
					border-radius: var(--radius-sm);
					padding: 10px 12px;
					box-shadow: 4px 4px 0 #000;
					font: 13px "Courier New", monospace;
				}

				#tourCtrls {
					margin-top: 8px;
					text-align: right;
				}

				#tourCtrls button {
					margin-left: 4px;
				}

				.tour-highlight {
					outline: 3px solid #ffe600 !important;
					box-shadow: 0 0 8px 3px #ffe600 !important;
				}

				/* Presets gallery */
				.presets-gallery {
					display: grid;
					grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
					gap: 12px;
					padding: 4px;
					max-height: 60vh;
					overflow-y: auto;
				}

				.preset-card {
					aspect-ratio: 1/1;
					background: #fafafa;
					border: 2px solid #000;
					box-shadow: 3px 3px 0 #000;
					position: relative;
					transition: transform .15s, box-shadow .15s;
				}

				.preset-card:hover {
					transform: translateY(-3px);
					box-shadow: 5px 5px 0 #000;
				}

				.preset-card:active {
					transform: translateY(0);
				}

				.preset-card img,
				.preset-card svg {
					width: 100%;
					height: 100%;
					object-fit: cover;
					display: block;
				}

				.preset-card figcaption {
					position: absolute;
					inset: 0;
					display: flex;
					align-items: center;
					justify-content: center;
					color: #fff;
					background: rgba(0, 0, 0, .58);
					padding: 4px;
					text-align: center;
					font: 12px "Courier New", monospace;
					opacity: 0;
					transition: opacity .15s;
				}

				.preset-card:hover figcaption {
					opacity: 1;
				}

				.preset-card.card-selected {
					outline: 3px solid #ffe600;
					box-shadow: 0 0 10px 3px #ffe600;
				}

				/* Cursor modes (unchanged) */
				.canvas-blob-mode {
					cursor: url("images/pencil.png"), auto;
				}

				.canvas-line-mode {
					cursor: url("images/pencil.png"), auto;
				}

				.canvas-attractor-mode,
				.canvas-repulsor-mode {
					cursor: url("images/pencil.png"), auto;
				}

				.canvas-particle-mode {
					cursor: crosshair;
				}

				.canvas-circle-mode {
					cursor: url("images/CircleCursor.png"), auto;
				}

				.canvas-drag-mode {
					cursor: url("images/glove.png"), auto;
				}

				.canvas-pin-mode {
					cursor: url("images/PinCursor.png"), auto;
				}

				.canvas-slicing-mode {
					cursor: url("images/trim.png"), auto;
				}

				.canvas-freeze-mode {
					cursor: url("images/FreezeCursor.png"), auto;
				}

				.canvas-delete-mode {
					cursor: url("images/DeleteCursor.png"), auto;
				}

				/* Optional page-wide mobile notice (if you still use it) */
				#mobileWarning {
					position: fixed;
					inset: 0;
					display: none;
					background: #fff;
					color: #000;
					padding: 20px;
					align-items: center;
					justify-content: center;
					text-align: center;
					z-index: 10000;
				}

				/* ------------------ 8. iPad Full-Screen Layout ------------------ */
				.window.ipad {
					width: 100%;
					height: 100dvh;
					margin: 0;
					border-radius: 0;
					border: 0;
					box-shadow: none;
					background: var(--bg);
					position: fixed;
					inset: 0;
					overflow: hidden;
					display: block;
					transform: none;
				}

				.window.ipad::before,
				.window.ipad::after {
					display: none;
				}

				.window.ipad .main-area::before {
					display: none;
				}

				.window.ipad .toolbar::after,
				.window.ipad .bottom-panel::after {
					display: none;
				}

				.window.ipad .title-bar::after {
					display: none;
				}

				.window.ipad .content::before {
					display: none;
				}

				/* Title bar on iPad - compact floating style */
				.window.ipad .title-bar {
					position: fixed;
					top: 0;
					left: 0;
					right: 0;
					height: 44px;
					background: var(--panel-glass);
					backdrop-filter: var(--backdrop-blur-strong);
					-webkit-backdrop-filter: var(--backdrop-blur-strong);
					border-bottom: 1px solid var(--panel-glass-border);
					box-shadow: var(--shadow-md);
					z-index: var(--z-toggle);
					padding: 4px 8px;
					display: flex;
					align-items: center;
					gap: 12px;
				}

				.window.ipad .menu-bar {
					display: flex;
					gap: 12px;
					flex-wrap: wrap;
				}

				.window.ipad .menu-bar span {
					font-size: 13px;
					font-weight: 600;
				}

				.window.ipad .title-actions {
					margin-left: auto;
					display: flex;
					gap: 6px;
				}

			.window.ipad .reset-icon {
				width: 28px;
				height: 28px;
				font-size: 16px;
				border: none;
				box-shadow: none;
				background: transparent;
				border-radius: var(--radius-sm);
			}

				/* Hide fullscreen icon on iPad */
				.window.ipad #fullscreenIcon {
					display: none !important;
				}

				/* Ensure submenus appear above toggle buttons on iPad */
				.window.ipad .submenu {
					z-index: 1000; /* Higher than toggle button (200) */
				}

				/* Full-screen canvas container */
				.window.ipad .content {
					position: absolute;
					top: 44px; /* Below title bar */
					left: 0;
					right: 0;
					bottom: 0;
					display: flex;
					align-items: center;
					justify-content: center;
					padding: 0;
					margin: 0;
				}

				.window.ipad .main-area {
					position: absolute;
					top: 0;
					left: 0;
					right: 0;
					bottom: 0;
					width: 100%;
					height: 100%;
					padding: 0;
					margin: 0;
					background: transparent;
					display: block;
				}

				/* Canvas - full screen, fills entire iPad width */
				.window.ipad #glCanvas {
					position: absolute;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					margin: 0;
					border: none;
					border-radius: 0;
					background: var(--panel);
					display: block;
					/* Width and height controlled by JavaScript fitCanvasForIPad() */
				}

				/* ------------------ Left Toolbar Panel (Slide-out) ------------------ */
				.window.ipad .toolbar {
					position: fixed;
					left: 0;
					top: 44px; /* Below title bar */
					bottom: 0;
					width: calc(var(--icon-size) + var(--gap-2) * 2); /* Single icon width + padding */
					background: var(--panel-glass);
					backdrop-filter: var(--backdrop-blur-strong);
					-webkit-backdrop-filter: var(--backdrop-blur-strong);
					border-right: 1px solid var(--panel-glass-border);
					box-shadow: var(--shadow-xl);
					z-index: var(--z-panel);
					transform: translateX(0); /* Open by default */
					transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
					overflow-y: auto;
					overflow-x: visible; /* Allow tooltips to overflow */
					padding: var(--gap-2);
					display: flex;
					flex-direction: column;
					gap: calc(var(--gap-2) / 2);
					-webkit-overflow-scrolling: touch;
				}

				.window.ipad .toolbar:not(.panel-visible) {
					transform: translateX(-100%);
				}

				.window.ipad .toolbar-section {
					background: transparent;
					border: none;
					border-radius: 0;
					padding: calc(var(--gap-2) / 2) 0;
					margin: 0;
					box-shadow: none;
					border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Visual separator */
				}

				.window.ipad .toolbar-section:last-child {
					border-bottom: none;
				}

				/* Hide headers on iPad */
				.window.ipad .toolbar-section h4 {
					display: none;
				}

				.window.ipad .toolbar-section .icon-group {
					display: flex;
					flex-direction: column;
					gap: var(--gap-1);
					align-items: center;
				}

				.window.ipad .icon,
				.window.ipad .icon img {
					width: var(--icon-size);
					height: var(--icon-size);
				}

				/* ------------------ Bottom Sliders Panel (Slide-up) ------------------ */
				.window.ipad .bottom-panel {
					position: fixed;
					left: 0;
					right: 0;
					bottom: 0;
					height: var(--panel-bottom-height);
					background: var(--panel-glass);
					backdrop-filter: var(--backdrop-blur-strong);
					-webkit-backdrop-filter: var(--backdrop-blur-strong);
					border-top: 1px solid var(--panel-glass-border);
					box-shadow: var(--shadow-xl);
					z-index: var(--z-panel);
					transform: translateY(100%);
					transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
					overflow-y: auto;
					overflow-x: hidden;
					padding: 16px 20px; /* Increased padding on left and right to prevent text overlap */
					display: flex;
					flex-direction: column;
					-webkit-overflow-scrolling: touch;
				}

				/* iPad Drum Pad Styles */
				.window.ipad .drum-pad {
					width: 140px;
					height: 140px;
					border-radius: var(--radius-lg);
					border: 2px solid var(--border);
					background: var(--panel-2);
					box-shadow: var(--shadow-md);
					font-size: 20px;
				}

				.window.ipad .drum-pad:active {
					background: var(--accent);
					color: #fff;
				}

				.window.ipad .drum-pad.active {
					background: #ffd700;
					animation: drumPadPulse 0.3s ease-out;
				}

				.window.ipad .bottom-panel.panel-visible {
					transform: translateY(0);
				}

				.window.ipad #sliders {
					display: flex;
					flex-direction: column;
					gap: 0; /* No gap between sliders */
					width: 100%;
				}

				.window.ipad #sliders > div {
					display: grid;
					grid-template-columns: auto auto 1fr;
					align-items: center;
					column-gap: var(--gap-2);
					padding: 0; /* No padding */
					min-height: 28px; /* Ultra compact row height */
					margin: 0; /* No margin */
				}


				.window.ipad #sliders label {
					font-size: 18px;
					font-weight: 500;
					color: var(--text);
					white-space: nowrap;
					margin: 0;
					min-width: 120px;
					line-height: 1.3;
				}

				.window.ipad #sliders label span {
					font-size: 16px;
					margin-left: 4px;
				}

				/* Modern range sliders */
				.window.ipad input[type="range"] {
					height: 4px;
					background: rgba(0, 0, 0, 0.1);
					border-radius: 999px;
					border: none;
					margin: 0;
					align-self: center;
				}

				.window.ipad input[type="range"]::-webkit-slider-thumb {
					width: 32px; /* Larger thumb for easier grabbing */
					height: 32px; /* Larger thumb for easier grabbing */
					border-radius: 50%;
					background: var(--accent);
					border: 3px solid white;
					box-shadow: var(--shadow-md);
					margin-top: -8px; /* Adjusted for larger thumb */
					transition: all 0.2s ease;
					cursor: grab;

				}

				.window.ipad input[type="range"]::-webkit-slider-thumb:active {
					transform: scale(1.1);
					background: var(--accent-hover);
					cursor: grabbing;
				}

				.window.ipad input[type="range"]::-moz-range-thumb {
					width: 32px; /* Larger thumb for easier grabbing */
					height: 32px; /* Larger thumb for easier grabbing */
					border-radius: 50%;
					background: var(--accent);
					border: 3px solid white;
					box-shadow: var(--shadow-md);
					transition: all 0.2s ease;
					cursor: grab;
				}

				.window.ipad input[type="range"]::-moz-range-thumb:active {
					transform: scale(1.1);
					background: var(--accent-hover);
					cursor: grabbing;
				}

				/* ------------------ Toggle Buttons ------------------ */
				.panel-toggle {
					position: fixed;
					z-index: var(--z-toggle);
					width: 48px;
					height: 48px;
					border-radius: var(--radius-lg);
					background: var(--panel-glass);
					backdrop-filter: var(--backdrop-blur);
					-webkit-backdrop-filter: var(--backdrop-blur);
					border: 1px solid var(--panel-glass-border);
					box-shadow: var(--shadow-lg);
					display: flex;
					align-items: center;
					justify-content: center;
					cursor: pointer;
					transition: all 0.2s ease;
					font-size: 20px;
					color: var(--text);
					user-select: none;
					-webkit-tap-highlight-color: transparent;
					z-index: 100;
				}

				.panel-toggle:active {
					transform: scale(0.95);
				}

				.panel-toggle-left {
					left: calc(var(--panel-left-width) + var(--gap-2)); /* Panel open by default */
					top: calc(44px + var(--gap-2)); /* Below title bar */
					transform: none;
				}

				.panel-toggle-left.panel-visible {
					left: calc(var(--panel-left-width) + var(--gap-2));
				}

				/* When panel is hidden, move toggle button back */
				.window.ipad .toolbar:not(.panel-visible) ~ .panel-toggle-left,
				.window.ipad .toolbar:not(.panel-visible) + * ~ .panel-toggle-left {
					left: var(--gap-2);
				}

				/* Alternative: when panel is hidden, button should be at left edge */
				.window.ipad .panel-toggle-left:not(.panel-visible) {
					left: var(--gap-2) !important;
				}

				.panel-toggle-bottom {
					bottom: var(--gap-2);
					right: var(--gap-2);
				}

				.panel-toggle-bottom.panel-visible {
					bottom: calc(var(--panel-bottom-height) + var(--gap-2));
				}


				/* ------------------ Overlays & Dialogs ------------------ */
				.window.ipad #splashOverlay {
					position: fixed;
					inset: 0;
					z-index: var(--z-splash);
				}

				.window.ipad #toastStack {
					position: fixed;
					top: calc(44px + var(--gap-2)); /* Below title bar */
					right: var(--gap-2);
					z-index: var(--z-toggle);
				}

				.window.ipad .dialog-backdrop {
					position: fixed;
					inset: 0;
					z-index: var(--z-dialog);
				}

				.window.ipad #splashOverlay .splashText {
					display: inline-block;
					padding: 12px 24px;
					margin-top: 16px;
					background: var(--accent);
					color: #fff;
					font-weight: 600;
					border-radius: var(--radius-lg);
					box-shadow: var(--shadow-lg);
					text-align: center;
					font-size: 16px;
				}

				/* Hide mobile warning on iPad */
				.window.ipad ~ #mobileWarning {
					display: none !important;
				}

				/* Help icons */
				.window.ipad #sliders .help-icon-container {
					display: flex;
					align-items: center;
					justify-content: center;
					width: 20px;
					height: 20px;
				}

				.window.ipad #sliders .help-icon {
					width: 16px;
					height: 16px;
					line-height: 16px;
					font-size: 10px;
					background: rgba(0, 0, 0, 0.1);
					border: 1px solid rgba(0, 0, 0, 0.15);
				}

				/* Shape settings in toolbar - narrow vertical layout */
				.window.ipad .shape-settings {
					display: flex;
					flex-direction: column;
					gap: var(--gap-1);
					align-items: center;
				}

				.window.ipad .shape-settings > div {
					display: flex;
					flex-direction: column;
					gap: 4px;
					align-items: center;
					width: 100%;
				}

				.window.ipad .shape-settings label {
					font-size: 10px;
					font-weight: 500;
					color: var(--muted);
					text-align: center;
				}

				.window.ipad .shape-settings input[type="color"],
				.window.ipad .shape-settings input[type="number"] {
					width: var(--icon-size);
					height: var(--icon-size);
					border: 1px solid var(--border);
					border-radius: var(--radius-md);
					padding: 0;
				}

				/* Edit tools glow effect - removed red highlight */

				/* Icon active state */
				.window.ipad .icon.icon-active {
					background: var(--accent);
					color: white;
					border-color: var(--accent);
					box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3), var(--shadow-md);
				}

				.window.ipad .icon.icon-active::after {
					background: #ff0;
					color: #000;
					font-size: 9px;
					padding: 2px 5px;
				}

			}
		}
	</style>

	<!-- Show content once page is loaded -->
	<script>
		window.addEventListener('DOMContentLoaded', function() {
			document.documentElement.style.visibility = 'visible';
			document.documentElement.style.opacity = '1';
		});
	</script>

</head>

<body>
	<div class="window">
		<!-- Splash Overlay -->
		<div id="splashOverlay">
			<img src="images/splash.png" alt="Splash Image" />
			<div class="splashText">Click and Drag to Start Blobbing</div>
		</div>
		<div id="toastStack"></div>
		<div id="presentationModeInstruction" style="display:none;">Press ESC to exit Presentation Mode</div>
		<button id="presentationExitBtn" style="display:none;" aria-label="Exit Presentation Mode">✕</button>
		<div id="tourOverlay" style="display:none;"></div>
		<div id="tourTip" style="display:none;">
			<div id="tourText"></div>
			<div id="tourCtrls">
				<button id="tourPrev">◀ Prev</button>
				<button id="tourNext">Next ▶</button>
				<button id="tourExit">End ✖</button>
			</div>
		</div>
		<!-- Title Bar -->
		<div class="title-bar">
			<div class="menu-bar">
				<span id="menuFile">File
					<div class="submenu" id="fileSubmenu">
						<span id="saveBlobsOption">Save Blobs (JSON)</span>
						<span id="loadBlobsOption">Load Blobs (JSON)</span>
						<span id="presentationModeOption">Presentation Mode</span>
					</div>
				</span>
				<span id="menuExport">Export
					<div class="submenu" id="exportSubmenu">
						<span id="exportSVGOption">SVG</span>
						<span id="exportJPGOption">JPG</span>
					</div>
				</span>
				<span id="menuPresets">Presets</span>
				<span id="menuAbout">About</span>
				<span id="menuHelp">Help</span>
			</div>
			<div class="title-actions">
				<span id="fullscreenIcon" class="reset-icon" title="Full Screen Mode">⛶</span>
				<span id="resetIcon" class="reset-icon" title="Reset Canvas">🗑️</span>
				<span id="notifToggle" class="reset-icon" title="Disable tips" style="display:none;">🔔</span>
				<span id="sfxToggle" class="reset-icon" title="Enable Sound Effects">🔇</span>
			</div>
		</div>

		<!-- Panel Toggle Buttons (iPad only) -->
		<button class="panel-toggle panel-toggle-left" id="toggleToolbar" aria-label="Toggle Tools Panel">☰</button>
		<button class="panel-toggle panel-toggle-bottom" id="toggleSliders" aria-label="Toggle Sliders Panel">⚙</button>

		<!-- Main Content -->
		<div class="content">
			<!-- Toolbar: grouped into Draw Tools, Edit Tools, Canvas Tools, and now Shape Settings -->
			<div class="toolbar">
				<button class="panel-hide-btn" id="hideToolbar" title="Hide Tools Panel">−</button>
				<!-- DRAW TOOLS -->
				<div class="toolbar-section">
					<h4>Draw Tools</h4>
					<div class="icon-group">
						<div class="icon" id="iconBlob" data-label="Blob (Q)">
							<img src="images/blob.png" alt="Blob Mode" />
						</div>
						<div class="icon" id="iconLine" data-label="Line (W)">
							<img src="images/line.png" alt="Line Mode" />
						</div>
						<div class="icon" id="iconCircle" data-label="Circle (E)">
							<img src="images/wrap.png" alt="Circle Mode" />
						</div>
					<div class="icon" id="iconParticle" data-label="Particles (R)">✦</div>
					<div class="icon" id="iconAttractorRepulsor" data-label="Attractor/Repulsor">
						<img src="images/repulse.png" alt="Attractor/Repulsor" style="opacity: 0.7;" />
					</div>
				</div>
				</div>

				<!-- EDIT TOOLS -->
				<div class="toolbar-section" id="editToolsSection">
					<h4>Edit Tools</h4>
					<div class="icon-group">
						<div class="icon" id="iconDrag" data-label="Drag (A)">
							<img src="images/gloveIcon.png" alt="Drag Mode" />
						</div>
						<div class="icon" id="iconFreeze" data-label="Freeze (S)">
							<img src="images/freeze.png" alt="Freeze Mode" />
						</div>
						<div class="icon" id="iconPin" data-label="Pin (D)">
							<img src="images/pin.png" alt="Pin Mode" />
						</div>
						<div id="iconSlice">
						</div>
						<div class="icon" id="iconDelete" data-label="Delete (X)">
							<img src="images/delete.png" alt="Delete">
						</div>
					</div>
				</div>

				<!-- SHAPE SETTINGS (Color, Gap, ΔSize) -->
				<div class="toolbar-section">
					<h4>Shape Settings</h4>
					<div class="shape-settings">
						<div>
							<label for="blobColor">Color</label>
							<input type="color" id="blobColor" value="#0066ff">
						</div>
						<div>
							<label for="radiusAvgInput">Size</label>
							<input type="number" id="radiusAvgInput" min="0.0" max="20" step="0.2" value="5">
						</div>
					</div>
				</div>

				<!-- CANVAS TOOLS -->
				<div class="toolbar-section">
					<h4>Canvas</h4>
					<div class="icon-group">
						<div class="icon" id="iconAppearance" data-label="Appearance">🎨</div>
						<div class="icon" id="iconDiffusion" data-label="High Blob Repel"><img src="images/repel.png" alt="Overlap Guard" /></div>
						<div class="icon" id="iconNoise" data-label="Auto Movement"><img src="images/Lava.png" alt="Auto Movement" /></div>
						<div class="icon" id="iconUndo" data-label="Undo Last Item">⎌</div>
						<div class="icon" id="iconGravity" data-label="Gravity (G)">G</div>
					</div>
				</div>
			</div>

			<!-- Main Drawing Area -->
			<div class="main-area">
				<canvas id="glCanvas" width="500" height="500"></canvas>
			</div>
		</div>

		<!-- Bottom Panel: Sliders -->
		<div class="bottom-panel">
			<button class="panel-hide-btn" id="hideBottomPanel" title="Hide Sliders Panel">−</button>
			<!-- Sliders Panel -->
			<div id="sliders">
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = bigger blobs/lines.
						</div>
					</div>
					<label for="dotScaleSlider" class="slider-label">Blob Size: <span id="dotScaleValue">39%</span></label>
					<input type="range" id="dotScaleSlider" min="0" max="100" value="39" step="0.5">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = more wobble.
						</div>
					</div>
					<label for="dampingSlider">Excitability: <span id="dampingValue">85%</span></label>
					<input type="range" id="dampingSlider" min="0" max="100" value="85" step="0.5">
				</div>
				<div>
	<div class="help-icon-container">
		<span class="help-icon">i</span>
		<div class="help-tooltip">Simulated internal fluid pushing outward. Closed blobs inflate uniformly.</div>
	</div>
	<label for="turgorPressureSlider">Inflation: <span id="turgorPressureValue">0%</span></label>
	<input type="range" id="turgorPressureSlider" min="0" max="100" value="0" step="1">
</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = tighter shapes.
						</div>
					</div>
					<label for="springConstantSlider">Stiffness: <span id="springConstantValue">30%</span></label>
					<input type="range" id="springConstantSlider" min="0" max="100" value="30" step="1">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = more expansion.
						</div>
					</div>
					<label for="repulsionConstantSlider">Chaos: <span id="repulsionConstantValue">10%</span></label>
					<input type="range" id="repulsionConstantSlider" min="0" max="100" value="10" step="1">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Shapes animate faster when higher.
						</div>
					</div>
					<label for="timeStepSlider">Speed: <span id="timeStepValue">47%</span></label>
					<input type="range" id="timeStepSlider" min="0" max="100" value="47" step="1">
				</div>



			</div>
		</div>

		<!-- Film Strip Timeline Panel (Right Side, Fullscreen Only) -->
		<div class="filmstrip-panel" id="filmstripPanel">
			<button class="panel-hide-btn" id="hideFilmstrip" title="Hide Film Strip Panel">−</button>
			<div class="filmstrip-header">
				<h4>Film Strip</h4>
				<div class="filmstrip-journey">
					<span>Select</span>
					<span>></span>
					<span>Capture</span>
					<span>></span>
					<span>Play</span>
					<span>></span>
					<span>Save</span>
				</div>
				<div class="filmstrip-controls">
					<button id="filmstripCrosshairsBtn" class="filmstrip-btn" title="Define Capture Area">➕</button>
					<button id="filmstripCaptureBtn" class="filmstrip-btn" title="Capture Frame">📷</button>
					<button id="filmstripRecordBtn" class="filmstrip-btn record-btn" title="Record Animation">🔴</button>
					<button id="filmstripPlayBtn" class="filmstrip-btn play-btn" title="Play">▶</button>
					<button id="filmstripPauseBtn" class="filmstrip-btn" title="Pause" style="display: none;">⏸</button>
					<button id="filmstripExportBtn" class="filmstrip-btn" title="Export Animation">💾</button>
					<button id="filmstripClearBtn" class="filmstrip-btn" title="Clear All Frames">🗑</button>
				</div>
			</div>
			<div class="filmstrip-container">
				<div class="filmstrip-window"></div>
				<img class="filmstrip-single-frame" id="filmstripSingleFrame" alt="Playing frame">
				<div class="filmstrip-frames" id="filmstripFrames">
					<!-- Frames will be dynamically added here -->
				</div>
			</div>
		</div>

		<!-- ░ EXPORT ANIMATION DIALOG ░ -->
		<div class="dialog-backdrop" id="exportAnimationBackdrop">
			<div class="dialog-content">
				<h3>Export Animation</h3>
				<p style="margin: 12px 0;">Choose export format:</p>
				<div style="display: flex; gap: 12px; justify-content: center; margin-top: 16px;">
					<button id="exportWebMBtn" style="padding: 10px 20px; font-size: 14px;">WebM Video</button>
					<button id="exportSVGBtn" style="padding: 10px 20px; font-size: 14px;">SVG Animation</button>
				</div>
				<button id="exportCancelBtn" style="margin-top: 16px; padding: 8px 16px; font-size: 12px;">Cancel</button>
			</div>
		</div>

		<!-- ░ RECORD FREQUENCY DIALOG ░ -->
		<div class="dialog-backdrop" id="recordFrequencyBackdrop">
			<div class="dialog-content">
				<h3>Record Animation</h3>
				<p style="margin: 12px 0;">Select capture frequency:</p>
				<div style="display: flex; flex-direction: column; gap: 10px; margin-top: 16px;">
					<button id="recordQuarterBtn" style="padding: 10px 20px; font-size: 14px;">Every 1/4 second</button>
					<button id="recordHalfBtn" style="padding: 10px 20px; font-size: 14px;">Every 1/2 second</button>
					<button id="record1sBtn" style="padding: 10px 20px; font-size: 14px;">Every 1 second</button>
					<button id="record5sBtn" style="padding: 10px 20px; font-size: 14px;">Every 5 seconds</button>
					<button id="record10sBtn" style="padding: 10px 20px; font-size: 14px;">Every 10 seconds</button>
				</div>
				<button id="recordCancelBtn" style="margin-top: 16px; padding: 8px 16px; font-size: 12px;">Cancel</button>
			</div>
		</div>

		<!-- ░ ATTRACTOR/REPULSOR TYPE DIALOG ░ -->
		<div class="dialog-backdrop" id="attractorRepulsorBackdrop">
			<div class="dialog-content">
				<h3>Attractor / Repulsor</h3>
				<p style="margin: 12px 0;">Choose type:</p>
				<div style="display: flex; gap: 12px; justify-content: center; margin-top: 16px;">
					<button id="attractorBtn" style="padding: 10px 20px; font-size: 14px; background: rgba(76, 175, 80, 0.3);">Attractor</button>
					<button id="repulsorBtn" style="padding: 10px 20px; font-size: 14px; background: rgba(220, 53, 69, 0.3);">Repulsor</button>
				</div>
				<button id="attractorRepulsorCancelBtn" style="margin-top: 16px; padding: 8px 16px; font-size: 12px;">Cancel</button>
			</div>
		</div>

		<!-- ░ PARTICLE SETTINGS DIALOG ░ -->
		<div class="dialog-backdrop" id="particleSettingsBackdrop">
			<div class="dialog-content">
				<h3>Particle Emitter Settings</h3>
				<div style="margin: 12px 0; text-align: left;">
					<label style="display: block; margin-bottom: 8px;">
						Emit Rate (particles/sec):
						<input type="number" id="particleEmitRate" min="1" max="100" step="1" value="10"
							style="width: 60px; margin-left: 8px;">
					</label>
					<label style="display: block; margin-bottom: 8px;">
						Render Size (px):
						<input type="number" id="particleRenderSize" min="1" max="30" step="0.5" value="4"
							style="width: 60px; margin-left: 8px;">
					</label>
				</div>
				<div style="display: flex; gap: 12px; justify-content: center; margin-top: 16px;">
					<button id="particleSettingsApply" style="padding: 10px 20px; font-size: 14px;">Start Drawing</button>
					<button id="particleSettingsCancel" style="padding: 8px 16px; font-size: 12px;">Cancel</button>
				</div>
			</div>
		</div>

		<!-- ░ PRESETS DIALOG ░ -->
		<div class="dialog-backdrop" id="presetsBackdrop">
			<div class="dialog-content presets-dialog">
				<h3>Select a Preset</h3>

				<div id="presetsGallery" class="presets-gallery">
					<!-- Grid preset card -->
					<div class="preset-card" id="presetGrid">
						<svg viewBox="0 0 100 100" width="100%" height="100%">
							<rect width="100" height="100" fill="#fff" />
							<g stroke="#000" stroke-width="2" fill="none">
								<!-- 5 × 5 grid preview -->
								<circle cx="10" cy="10" r="8" />
								<circle cx="30" cy="10" r="8" />
								<circle cx="50" cy="10" r="8" />
								<circle cx="70" cy="10" r="8" />
								<circle cx="90" cy="10" r="8" />

								<circle cx="10" cy="30" r="8" />
								<circle cx="30" cy="30" r="8" />
								<circle cx="50" cy="30" r="8" />
								<circle cx="70" cy="30" r="8" />
								<circle cx="90" cy="30" r="8" />

								<circle cx="10" cy="50" r="8" />
								<circle cx="30" cy="50" r="8" />
								<circle cx="50" cy="50" r="8" />
								<circle cx="70" cy="50" r="8" />
								<circle cx="90" cy="50" r="8" />

								<circle cx="10" cy="70" r="8" />
								<circle cx="30" cy="70" r="8" />
								<circle cx="50" cy="70" r="8" />
								<circle cx="70" cy="70" r="8" />
								<circle cx="90" cy="70" r="8" />

								<circle cx="10" cy="90" r="8" />
								<circle cx="30" cy="90" r="8" />
								<circle cx="50" cy="90" r="8" />
								<circle cx="70" cy="90" r="8" />
								<circle cx="90" cy="90" r="8" />
							</g>
						</svg>
						<figcaption>Grid of Circles</figcaption>
					</div>
					<div class="preset-card" id="presetBlobGrid">
						<img src="images/grid_of_blobs.png" alt="Grid of Blobs">
						<figcaption>Grid of Blobs</figcaption>
					</div>
					<div class="preset-card" id="presetAnthro">
						<!-- tiny 100×100 PNG or SVG is fine; use any placeholder for now -->
						<img src="images/anthro_blobs.png" alt="Anthro Blobs">
						<figcaption>Blob Face</figcaption>
					</div>
				</div>

				<button id="closePresets">Close</button>
			</div>
		</div>

		<div class="dialog-backdrop" id="gridBackdrop">
			<div class="dialog-content">
				<h3>Grid of Circles</h3>

				<label>Count
					<input type="number" id="gridCount" value="5" min="1" max="12">
				</label><br>

				<label>
					<input type="checkbox" id="autoRadius" checked>
					Fit circles to canvas
				</label><br>

				<div id="radiusRow" style="display:none;">
					<label>Radius
						<input type="number" id="gridRadius" value="20" min="2" max="200">
					</label><br>
				</div>

				<button id="applyGrid">Apply</button>
				<button id="cancelGrid">Cancel</button>
			</div>

		</div>
		<div class="dialog-backdrop" id="blobGridBackdrop">
			<div class="dialog-content">
				<h3>Grid of Blobs</h3>

				<label>Count (rows = cols)
					<input type="number" id="blobGridCount" value="5" min="1" max="10">
				</label><br>

				<label>
					<input type="checkbox" id="blobAutoSize" checked>
					Fit blobs to canvas
				</label><br>

				<div id="blobSizeRow" style="display:none;">
					<label>Base Radius
						<input type="number" id="blobBaseRadius" value="20" min="4" max="120">
					</label><br>
				</div>

				<button id="applyBlobGrid">Apply</button>
				<button id="cancelBlobGrid">Cancel</button>
			</div>
		</div>

		<!-- Modals/Dialogs: About and Help -->
		<div class="dialog-backdrop" id="aboutBackdrop">
			<div class="dialog-content">
				<p>blobSketch version 1.5</p>
				<p>by Colin Reid</p>
				<button id="closeAbout">OK</button>
			</div>
		</div>

		<!-- ░ SAVE / IMPORT OPTION DIALOGS ░ -->
		<div class="dialog-backdrop" id="saveOptionsBackdrop">
			<div class="dialog-content">
				<h3>Save Options</h3>
				<label><input type="checkbox" id="saveIncludeChains" checked> Blobs / Lines</label><br>
				<label><input type="checkbox" id="saveIncludeCircles" checked> Circles</label><br>
				<label><input type="checkbox" id="saveIncludeSettings"> Physics & UI Settings</label><br>
				<button id="confirmSaveBtn">Save</button>
				<button id="cancelSaveBtn">Cancel</button>
			</div>
		</div>

		<div class="dialog-backdrop" id="importOptionsBackdrop">
			<div class="dialog-content">
				<h3>Import Options</h3>
				<label><input type="checkbox" id="importIncludeChains" checked> Blobs / Lines</label><br>
				<label><input type="checkbox" id="importIncludeCircles" checked> Circles</label><br>
				<label><input type="checkbox" id="importIncludeSettings" checked> Physics & UI Settings</label><br>
				<button id="confirmImportBtn">Import</button>
				<button id="cancelImportBtn">Cancel</button>
			</div>
		</div>

		<!-- Appearance Dialog -->
		<div class="dialog-backdrop" id="appearanceBackdrop">
			<div class="dialog-content appearance-dialog">
				<h3>Appearance</h3>
				<div class="appearance-dialog-content">
					<div class="appearance-controls">
						<div class="appearance-section">
							<h4 style="margin: 0 0 12px 0; font-size: 15px; font-weight: 600; color: #333;">Blob Style</h4>

							<div class="appearance-checkbox-row">
								<label class="appearance-checkbox-label">
									<input type="checkbox" id="appearanceOutline" checked>
									<span>Outline</span>
								</label>
								<label class="appearance-checkbox-label">
									<input type="checkbox" id="appearanceFilled" checked>
									<span>Filled</span>
								</label>
							</div>

							<div class="appearance-control-group" id="appearanceOutlineWidthGroup" style="margin-top: 12px;">
								<label for="appearanceOutlineWidth" style="font-size: 12px; color: #666;">Width: <span id="appearanceOutlineWidthValue">4</span></label>
								<input type="range" id="appearanceOutlineWidth" min="1" max="10" value="4" step="1">
							</div>
						</div>

						<div class="appearance-section" id="appearanceTravelingSegmentSection" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
							<div class="appearance-control-group" style="margin-bottom: 0;">
								<label class="appearance-checkbox-label" style="margin-bottom: 12px;">
									<input type="checkbox" id="appearanceTravelingSegment" unchecked>
									<span style="font-weight: 500;">Traveling Segment</span>
								</label>
							</div>

							<div id="appearanceTravelingSegmentControls" style="display: none; margin-top: 8px; padding-left: 24px; border-left: 2px solid #e0e0e0;">
								<div class="appearance-control-group" style="margin-bottom: 10px;">
									<label for="appearanceTravelingSegmentLength" style="font-size: 12px; color: #666;">Length: <span id="appearanceTravelingSegmentLengthValue">50</span>px</label>
									<input type="range" id="appearanceTravelingSegmentLength" min="10" max="200" value="50" step="5">
								</div>

								<div class="appearance-control-group" style="margin-bottom: 0;">
									<label for="appearanceTravelingSegmentSpeed" style="font-size: 12px; color: #666;">Speed: <span id="appearanceTravelingSegmentSpeedValue">100</span> px/s</label>
									<input type="range" id="appearanceTravelingSegmentSpeed" min="10" max="500" value="100" step="10">
								</div>
							</div>
						</div>

						<div class="appearance-section" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
							<h4 style="margin: 0 0 12px 0; font-size: 15px; font-weight: 600; color: #333;">Canvas</h4>

							<div class="appearance-control-group" style="margin-bottom: 12px;">
								<label for="appearanceBackgroundColor" style="font-size: 12px; color: #666; margin-bottom: 6px;">Background Color</label>
								<input type="color" id="appearanceBackgroundColor" value="#bfccab" style="width: 100%; height: 36px; cursor: pointer; border-radius: 4px;">
							</div>

							<div class="appearance-control-group" style="margin-bottom: 0;">
								<label class="appearance-checkbox-label">
									<input type="checkbox" id="appearanceShowGrid" checked>
									<span>Show Grid</span>
								</label>
							</div>
						</div>
					</div>

					<div class="appearance-preview">
						<h4>Preview</h4>
						<canvas id="appearancePreviewCanvas" width="200" height="200"></canvas>
					</div>
				</div>
				<div class="appearance-dialog-buttons">
					<button id="appearanceApplyBtn">Apply</button>
					<button id="appearanceCancelBtn">Cancel</button>
				</div>
			</div>
		</div>

		<!-- ░ REPEL MODE DIALOG ░ -->
		<div class="dialog-backdrop" id="repelModeBackdrop">
			<div class="dialog-content">
				<h3>Blob Repel Mode</h3>
				<p style="margin: 12px 0;">Adjust inter-blob repulsion strength:</p>
				<div style="display: flex; flex-direction: column; gap: 16px; margin-top: 20px; padding: 0 10px;">
					<div style="display: flex; flex-direction: column; gap: 8px;">
						<label for="repelModeSlider" style="font-size: 14px; color: #666; text-align: center;">
							<span id="repelModeLabel">Normal Repel</span>
						</label>
						<input type="range" id="repelModeSlider" min="0" max="2" value="1" step="1" 
							style="width: 100%; height: 8px; cursor: pointer;">
						<div style="display: flex; justify-content: space-between; font-size: 11px; color: #999; margin-top: 4px;">
							<span>No Repel</span>
							<span>Normal</span>
							<span>High Repel</span>
						</div>
					</div>
				</div>
				<div style="display: flex; gap: 10px; justify-content: center; margin-top: 24px;">
					<button id="repelModeApplyBtn" style="padding: 10px 24px; font-size: 14px;">Apply</button>
					<button id="repelModeCancelBtn" style="padding: 10px 24px; font-size: 14px; background: rgba(0,0,0,0.1);">Cancel</button>
				</div>
			</div>
		</div>

		<!-- ░ GRADIENT CURVE EDITOR DIALOG ░ -->
		<div class="dialog-backdrop" id="gradientCurveBackdrop">
			<div class="dialog-content" style="max-width: 600px; text-align: left;">
				<h3>Gradient Curve Editor</h3>
				<p style="margin: 12px 0; font-size: 13px;">
					Adjust the force curve along the gradient path. Left = start, Right = end.
				</p>
				<div style="display: flex; flex-direction: column; gap: 16px; margin-top: 20px;">
					<div style="position: relative; border: 2px solid #4b463f; border-radius: 6px; background: #fff; padding: 16px; box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);">
						<canvas id="gradientCurveCanvas" width="560" height="300" 
							style="width: 100%; height: 300px; cursor: crosshair; display: block; background: #fff; border-radius: 4px; border: 1px solid #4b463f; touch-action: none;"></canvas>
						<div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 11px; color: #666;">
							<span>Start (0%)</span>
							<span>End (100%)</span>
						</div>
					</div>
					<div style="display: flex; gap: 10px; justify-content: center;">
						<button id="gradientCurveResetBtn">Reset to Linear</button>
						<button id="gradientCurveConstantBtn">Constant (Top)</button>
					</div>
					
					<!-- Temporal Morphogenesis Controls -->
					<div style="border: 2px solid #4b463f; border-radius: 6px; background: #f3ecda; padding: 12px; box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);">
						<h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: bold;">Temporal Morphogenesis</h4>
						<div style="display: flex; flex-direction: column; gap: 12px;">
							<div style="display: flex; align-items: center; gap: 12px;">
								<label style="font-size: 13px; min-width: 120px;">Temporal Mode:</label>
								<select id="temporalModeSelect" style="flex: 1; padding: 6px; font-size: 13px; border: 2px solid #4b463f; border-radius: 4px; background: #fff; font-family: inherit;">
									<option value="none">None (Static)</option>
									<option value="oscillate">Oscillate</option>
									<option value="shift">Shift</option>
									<option value="reverse">Reverse Direction</option>
								</select>
							</div>
							
							<div id="temporalControls" style="display: none; flex-direction: column; gap: 12px;">
								<div style="display: flex; align-items: center; gap: 12px;">
									<label style="font-size: 13px; min-width: 120px;">Frequency:</label>
									<input type="range" id="temporalFrequencySlider" min="0.1" max="5.0" step="0.1" value="1.0" style="flex: 1;">
									<span id="temporalFrequencyValue" style="font-size: 13px; min-width: 50px; text-align: right;">1.0 Hz</span>
								</div>
								
								<div id="temporalAmplitudeDiv" style="display: flex; align-items: center; gap: 12px;">
									<label style="font-size: 13px; min-width: 120px;">Amplitude:</label>
									<input type="range" id="temporalAmplitudeSlider" min="0.0" max="1.0" step="0.05" value="0.5" style="flex: 1;">
									<span id="temporalAmplitudeValue" style="font-size: 13px; min-width: 50px; text-align: right;">0.5</span>
								</div>
								
								<div id="shiftDirectionDiv" style="display: none; flex-direction: column; gap: 8px;">
									<div style="display: flex; align-items: center; gap: 12px;">
										<label style="font-size: 13px; min-width: 120px;">Shift Direction:</label>
										<select id="shiftDirectionSelect" style="flex: 1; padding: 6px; font-size: 13px; border: 2px solid #4b463f; border-radius: 4px; background: #fff; font-family: inherit;">
											<option value="forward">Forward</option>
											<option value="backward">Backward</option>
										</select>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div style="display: flex; gap: 10px; justify-content: center; margin-top: 24px;">
					<button id="gradientCurveApplyBtn">Apply</button>
					<button id="gradientCurveCancelBtn">Cancel</button>
				</div>
			</div>
		</div>

		<!-- ░ END DIALOGS ░ -->
	</div>
	<div id="circleInfo" style="
     position:fixed; display:none; z-index:10000;
     pointer-events:none; font:12px 'Courier New',monospace;
     padding:3px 6px; background:#ffffcc;
     border:1px solid #000; box-shadow:3px 3px 0 #000;">
	</div>
	<script>
		 (function () {
    var ua = navigator.userAgent || "";
    var isIPhone = /iPhone|iPod/i.test(ua);

    if (!isIPhone) return;

    document.documentElement.innerHTML = `
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Not Supported on iPhone</title>
        <style>
          :root {
            --bg1: #ffffff;
            --bg2: #e9eef9;
            --fg: #000;
            --border: #000;
          }
          html, body { height: 100%; margin: 0; }
          body {
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(140% 100% at 50% 0%, var(--bg2), var(--bg1) 60%);
            color: var(--fg);
            font: 16px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Courier New", monospace;
          }
          .splash {
            box-sizing: border-box;
            max-width: 640px; width: calc(100% - 40px);
            background: #f3f4f6;
            border: 2px solid var(--border);
            box-shadow: 8px 8px 0 #000;
            border-radius: 10px;
            padding: 22px;
            text-align: center;
          }
          .badge {
            display:inline-block;
            padding: 6px 10px;
            border:2px solid var(--border);
            border-radius:8px;
            background:#fff;
            box-shadow: 3px 3px 0 #000;
            font-weight: 700;
            margin-bottom: 14px;
          }
          h1 {
            margin: 8px 0 6px;
            font-size: 26px;
            letter-spacing: 0.3px;
          }
          p { margin: 8px 0; }
          .hint {
            margin-top: 14px;
            font-size: 14px;
            opacity: 0.9;
          }
          .btn {
            margin-top: 16px;
            display: inline-block;
            padding: 10px 14px;
            background: #2563eb;
            color: #fff;
            text-decoration: none;
            border: 2px solid var(--border);
            border-radius: 8px;
            box-shadow: 3px 3px 0 #000;
            font-weight: 700;
          }
        </style>
      </head>
      <body>
        <div class="splash" role="alert" aria-live="polite">
          <div class="badge">BlobSketch</div>
          <h1>Not supported on iPhone</h1>
          <p>This experience is designed for larger screens.</p>
          <p>Please use an <strong>iPad</strong> or <strong>desktop</strong> browser.</p>
        </div>
      </body>
    `;
    throw new Error("Blocked on iPhone");
  })();

		if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			document.addEventListener("DOMContentLoaded", function() {
				var warningDiv = document.createElement("div");
				warningDiv.id = "mobileWarning";
				warningDiv.innerHTML = '<h1>Desktop or iPad Only</h1><p>This application is best experienced on a desktop or iPad browser. Please switch to a desktop or ipad device.</p>';
				document.body.appendChild(warningDiv);
			});
		}

		document.addEventListener("DOMContentLoaded", () => {

			/* -----------------------------------
			   SHORTCUTS & UTILITIES
			----------------------------------- */
			const $ = id => document.getElementById(id);
			const circleInfo = $("circleInfo");

			// ==== Spatial Hash Setup ====
			const cellSize = 50; // adjust ~ to  max interaction distance
			let spatialHash = new Map();
			const neighborOffsets = [
				[0, 0],
				[1, 0],
				[-1, 0],
				[0, 1],
				[1, 1],
				[-1, 1],
				[0, -1],
				[1, -1],
				[-1, -1]
			];

			function hashKey(cx, cy) {
				// Use numeric key: pack two 16-bit integers into one number
				// Works for coordinates up to ±32767, which is plenty for canvas
				return (cx << 16) | (cy & 0xFFFF);
			}

			function unhashKey(key) {
				return [(key >> 16), (key & 0xFFFF)];
			}

			// PERFORMANCE: Pool of bucket arrays to avoid per-frame allocation
			let _shBucketPool = [];
			let _shBucketPoolIdx = 0;

			function buildSpatialHash() {
				// PERFORMANCE: Only rebuild if needed (when physics is active and positions changed)
				if (!spatialHashCache.needsRebuild) {
					return; // Use existing hash
				}

				// PERFORMANCE: Return existing buckets to pool instead of GC'ing them
				for (const bucket of spatialHash.values()) {
					bucket.length = 0; // Truncate but keep allocation
					if (_shBucketPoolIdx < _shBucketPool.length) {
						_shBucketPool[_shBucketPoolIdx] = bucket;
					} else {
						_shBucketPool.push(bucket);
					}
					_shBucketPoolIdx++;
				}
				spatialHash.clear();
				_shPoolIdx = 0; // Reset point object pool

				const invCS = 1 / cellSize;
				for (let c = 0; c < chains.length; c++) {
					const ch = chains[c].chain;
					const rA = chains[c].baseDotRadius * dotScaleFactor;
					for (let i = 0; i < ch.length; i++) {
						const p = ch[i];
						const cx = (p.x * invCS) | 0;
						const cy = (p.y * invCS) | 0;
						const key = hashKey(cx, cy);
						let bucket = spatialHash.get(key);
						if (bucket === undefined) {
							// PERFORMANCE: Reuse pooled bucket array if available
							if (_shBucketPoolIdx > 0) {
								bucket = _shBucketPool[--_shBucketPoolIdx];
							} else {
								bucket = [];
							}
							spatialHash.set(key, bucket);
						}
						// Pool point objects to avoid per-frame allocation
						let pt;
						if (_shPoolIdx < _shPool.length) {
							pt = _shPool[_shPoolIdx];
							pt.c = c; pt.i = i; pt.p = p; pt.r = rA;
						} else {
							pt = { c, i, p, r: rA };
							_shPool.push(pt);
						}
						_shPoolIdx++;
						bucket.push(pt);
					}
				}

				// Reset bucket pool index for next frame
				_shBucketPoolIdx = 0;
				spatialHashCache.needsRebuild = false;
			}

			// Helper for converting from one numeric range to another
			function mapRange(value, inMin, inMax, outMin, outMax) {
				return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
			}

			const hexToRGBA = hex => {
				if (hex[0] === "#") hex = hex.slice(1);
				const r = parseInt(hex.slice(0, 2), 16) / 255,
					g = parseInt(hex.slice(2, 4), 16) / 255,
					b = parseInt(hex.slice(4, 6), 16) / 255;
				return [r, g, b, 1.0];
			};

			function setDotScale(percent) {
				percent = Math.max(DOT_MIN_PERCENT,
					Math.min(DOT_MAX_PERCENT, percent));

				$("dotScaleSlider").value = percent;
				$("dotScaleValue").textContent = Math.round(percent) + "%";

				dotScaleFactor = mapRange(percent, 0, 100, 0.1, 5);
			}

			/* ---------- toast notifications ---------- */
			let tipsEnabled = false;
			$("notifToggle").onclick = () => {
				tipsEnabled = !tipsEnabled;
				$("notifToggle").textContent = tipsEnabled ? "🔔" : "🔕";
				$("notifToggle").title = tipsEnabled ? "Disable tips" : "Enable tips";
			};
			/* 2 ▸ ensure the bell shows the muted state on first load */
			$("notifToggle").textContent = "🔕";
			$("notifToggle").title = "Enable tips";

			/* ═══════════════════════════════════════════════════════════
			   🔊  B L O B S K E T C H   S O U N D   E N G I N E
			   ═══════════════════════════════════════════════════════════
			   Award-winning procedural audio via Web Audio API.
			   Zero external dependencies. All sounds are synthesized
			   in real-time from oscillators, noise, filters & envelopes.
			   ═══════════════════════════════════════════════════════════ */

			let sfxEnabled = false;
			let audioCtx = null;
			let sfxMasterGain = null;

			// Lazy-init AudioContext on first user gesture (browser policy)
			function ensureAudioCtx() {
				if (!audioCtx) {
					audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					sfxMasterGain = audioCtx.createGain();
					sfxMasterGain.gain.value = 0.35;
					sfxMasterGain.connect(audioCtx.destination);
				}
				if (audioCtx.state === "suspended") audioCtx.resume();
				return audioCtx;
			}

			// Toggle SFX
			$("sfxToggle").onclick = () => {
				sfxEnabled = !sfxEnabled;
				ensureAudioCtx();
				$("sfxToggle").textContent = sfxEnabled ? "🔊" : "🔇";
				$("sfxToggle").title = sfxEnabled ? "Disable Sound Effects" : "Enable Sound Effects";
				$("sfxToggle").classList.toggle("sfx-on", sfxEnabled);
				if (sfxEnabled) SFX.uiConfirm();
			};

			// ── Utility helpers ──────────────────────────────────────

			function createNoiseBuffer(duration = 0.5) {
				const ctx = ensureAudioCtx();
				const len = ctx.sampleRate * duration;
				const buf = ctx.createBuffer(1, len, ctx.sampleRate);
				const data = buf.getChannelData(0);
				for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
				return buf;
			}

			// Pre-built noise buffers (lazily created)
			let _noiseBuf05 = null;
			let _noiseBuf1  = null;
			function getNoise05() { if (!_noiseBuf05) _noiseBuf05 = createNoiseBuffer(0.5); return _noiseBuf05; }
			function getNoise1()  { if (!_noiseBuf1)  _noiseBuf1  = createNoiseBuffer(1.0); return _noiseBuf1; }

			// Throttle helper for continuous sounds (sliders, drawing)
			const _sfxThrottles = {};
			function sfxThrottle(key, ms, fn) {
				const now = performance.now();
				if (_sfxThrottles[key] && now - _sfxThrottles[key] < ms) return;
				_sfxThrottles[key] = now;
				fn();
			}

			// ── THE SOUND LIBRARY ────────────────────────────────────

			// Helper: convert hex color → tonal parameters for blob sounds
			// Maps hue to a pitch offset, filter brightness, and wobble character
			function colorToTone(hex) {
				// Parse hex to RGB
				const r = parseInt(hex.slice(1, 3), 16) / 255;
				const g = parseInt(hex.slice(3, 5), 16) / 255;
				const b = parseInt(hex.slice(5, 7), 16) / 255;
				const max = Math.max(r, g, b), min = Math.min(r, g, b);
				const lum = (max + min) / 2;
				const sat = max === min ? 0 : (lum > 0.5
					? (max - min) / (2 - max - min)
					: (max - min) / (max + min));
				let hue = 0;
				if (max !== min) {
					if (max === r) hue = ((g - b) / (max - min)) % 6;
					else if (max === g) hue = (b - r) / (max - min) + 2;
					else hue = (r - g) / (max - min) + 4;
					hue = Math.round(hue * 60);
					if (hue < 0) hue += 360;
				}
				// Map hue to a base pitch multiplier (pentatonic-ish spread)
				// Red(0)→low, Yellow(60)→bright, Green(120)→mid, Cyan(180)→airy,
				// Blue(240)→deep, Magenta(300)→high
				const hueNorm = hue / 360; // 0..1
				const pitchMult = 0.7 + hueNorm * 0.7; // 0.7x .. 1.4x
				// Brightness affects filter cutoff — bright colors = brighter sound
				const filterMult = 0.6 + lum * 0.9; // 0.6x .. 1.5x
				// Saturation affects wobble intensity — vivid = more wobble
				const wobbleMult = 0.5 + sat * 1.0; // 0.5x .. 1.5x
				return { pitchMult, filterMult, wobbleMult, hue, lum, sat };
			}

			const SFX = {

				/* ▸▸▸ DRAW: BLOB — liquid bubble formation (color-tinted) ◂◂◂ */
				blobDraw(hex) {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;
					const tone = colorToTone(hex || "#0066ff");

					// Underwater bubble rise — pitch tinted by color hue
					const osc1 = ctx.createOscillator();
					osc1.type = "sine";
					const f1 = (110 + Math.random() * 40) * tone.pitchMult;
					osc1.frequency.setValueAtTime(f1, t);
					osc1.frequency.linearRampToValueAtTime(f1 * 2.2, t + 0.08);
					osc1.frequency.exponentialRampToValueAtTime(f1 * 0.7, t + 0.35);

					// Detuned wobble partner for liquid thickness
					const osc2 = ctx.createOscillator();
					osc2.type = "sine";
					const f2 = f1 * 1.02;
					osc2.frequency.setValueAtTime(f2, t);
					osc2.frequency.linearRampToValueAtTime(f2 * 2.2, t + 0.08);
					osc2.frequency.exponentialRampToValueAtTime(f2 * 0.7, t + 0.35);

					// Slow wobble LFO — saturation controls jelly intensity
					const lfo = ctx.createOscillator();
					lfo.type = "sine";
					lfo.frequency.value = (6 + Math.random() * 4) * tone.wobbleMult;
					const lfoGain = ctx.createGain();
					lfoGain.gain.value = 15 * tone.wobbleMult;
					lfo.connect(lfoGain).connect(osc1.frequency);
					lfo.connect(lfoGain).connect(osc2.frequency);

					// Lowpass filter — brightness tinted by color luminance
					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.setValueAtTime(800 * tone.filterMult, t);
					lpf.frequency.exponentialRampToValueAtTime(200 * tone.filterMult, t + 0.3);
					lpf.Q.value = 6;

					// Water-drip noise layer
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const nBpf = ctx.createBiquadFilter();
					nBpf.type = "bandpass";
					nBpf.frequency.setValueAtTime(900 * tone.filterMult, t);
					nBpf.frequency.exponentialRampToValueAtTime(120, t + 0.15);
					nBpf.Q.value = 12;
					const nGain = ctx.createGain();
					nGain.gain.setValueAtTime(0.1, t);
					nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
					noise.connect(nBpf).connect(nGain).connect(sfxMasterGain);

					// Envelope
					const env = ctx.createGain();
					env.gain.setValueAtTime(0, t);
					env.gain.linearRampToValueAtTime(0.3, t + 0.02);
					env.gain.setValueAtTime(0.3, t + 0.06);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.38);

					osc1.connect(lpf);
					osc2.connect(lpf);
					lpf.connect(env).connect(sfxMasterGain);

					osc1.start(t); osc1.stop(t + 0.42);
					osc2.start(t); osc2.stop(t + 0.42);
					lfo.start(t); lfo.stop(t + 0.42);
					noise.start(t); noise.stop(t + 0.2);
				},

				/* ▸▸▸ DRAW: BLOB COMPLETE — liquid "plop" with bubble burst (color-tinted) ◂◂◂ */
				blobComplete(hex) {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;
					const tone = colorToTone(hex || "#0066ff");

					// Deep liquid plop — pitch tinted by color
					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(420 * tone.pitchMult, t);
					osc.frequency.exponentialRampToValueAtTime(55, t + 0.4);

					// Sub-bass body
					const sub = ctx.createOscillator();
					sub.type = "sine";
					sub.frequency.setValueAtTime(210 * tone.pitchMult, t);
					sub.frequency.exponentialRampToValueAtTime(28, t + 0.45);

					// Wobble LFO — saturation controls jelly intensity
					const lfo = ctx.createOscillator();
					lfo.type = "sine";
					lfo.frequency.value = 8 * tone.wobbleMult;
					const lfoG = ctx.createGain();
					lfoG.gain.value = 25 * tone.wobbleMult;
					lfo.connect(lfoG).connect(osc.frequency);

					// Lowpass — brightness tinted by color luminance
					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.setValueAtTime(1200 * tone.filterMult, t);
					lpf.frequency.exponentialRampToValueAtTime(150, t + 0.3);
					lpf.Q.value = 8;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0, t);
					env.gain.linearRampToValueAtTime(0.45, t + 0.01);
					env.gain.setValueAtTime(0.45, t + 0.05);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

					// Bubble burst noise — filter tinted by color
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(1400 * tone.filterMult, t);
					bpf.frequency.exponentialRampToValueAtTime(180, t + 0.12);
					bpf.Q.value = 14;
					const nEnv = ctx.createGain();
					nEnv.gain.setValueAtTime(0.18, t);
					nEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
					noise.connect(bpf).connect(nEnv).connect(sfxMasterGain);

					osc.connect(lpf);
					sub.connect(env);
					lpf.connect(env);
					env.connect(sfxMasterGain);

					osc.start(t); osc.stop(t + 0.55);
					sub.start(t); sub.stop(t + 0.55);
					lfo.start(t); lfo.stop(t + 0.55);
					noise.start(t); noise.stop(t + 0.15);
				},

				/* ▸▸▸ DRAW: LINE — wobbly elastic stretch ◂◂◂ */
				lineDraw() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "sawtooth";
					osc.frequency.setValueAtTime(200 + Math.random() * 100, t);

					// Vibrato LFO
					const lfo = ctx.createOscillator();
					lfo.type = "sine";
					lfo.frequency.value = 12 + Math.random() * 8;
					const lfoGain = ctx.createGain();
					lfoGain.gain.value = 30;
					lfo.connect(lfoGain).connect(osc.frequency);

					// Low-pass for warmth
					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.value = 800;
					lpf.Q.value = 5;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0, t);
					env.gain.linearRampToValueAtTime(0.18, t + 0.02);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

					osc.connect(lpf).connect(env).connect(sfxMasterGain);
					lfo.start(t); lfo.stop(t + 0.25);
					osc.start(t); osc.stop(t + 0.25);
				},

				/* ▸▸▸ DRAW: LINE COMPLETE — rubber snap ◂◂◂ */
				lineComplete() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "square";
					osc.frequency.setValueAtTime(500, t);
					osc.frequency.exponentialRampToValueAtTime(120, t + 0.15);

					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.setValueAtTime(2000, t);
					lpf.frequency.exponentialRampToValueAtTime(400, t + 0.15);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.3, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

					osc.connect(lpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.25);
				},

				/* ▸▸▸ DRAW: CIRCLE — theremin-like sweep up/down ◂◂◂ */
				_circleLastRadius: 0,
				_circleOsc: null,
				_circleOsc2: null,
				_circleGain: null,
				_circleGain2: null,
				_circleStopTimer: null,

				circleResize(radius) {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Map radius to frequency: small circle = low, big = high
					// Range: ~120 Hz (tiny) to ~900 Hz (huge)
					const freq = 120 + Math.min(radius, 300) * 2.6;

					// If no oscillator running yet, create a continuous one
					if (!this._circleOsc) {
						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.setValueAtTime(freq, t);

						const osc2 = ctx.createOscillator();
						osc2.type = "sine";
						osc2.frequency.setValueAtTime(freq * 1.498, t); // slightly detuned fifth

						const gain = ctx.createGain();
						gain.gain.setValueAtTime(0.001, t);
						gain.gain.linearRampToValueAtTime(0.16, t + 0.06);

						const gain2 = ctx.createGain();
						gain2.gain.setValueAtTime(0.001, t);
						gain2.gain.linearRampToValueAtTime(0.06, t + 0.06);

						osc.connect(gain).connect(sfxMasterGain);
						osc2.connect(gain2).connect(sfxMasterGain);

						osc.start(t);
						osc2.start(t);

						this._circleOsc = osc;
						this._circleOsc2 = osc2;
						this._circleGain = gain;
						this._circleGain2 = gain2;
					}

					// Smoothly glide pitch to match current radius
					this._circleOsc.frequency.cancelScheduledValues(t);
					this._circleOsc.frequency.setValueAtTime(this._circleOsc.frequency.value, t);
					this._circleOsc.frequency.linearRampToValueAtTime(freq, t + 0.04);

					this._circleOsc2.frequency.cancelScheduledValues(t);
					this._circleOsc2.frequency.setValueAtTime(this._circleOsc2.frequency.value, t);
					this._circleOsc2.frequency.linearRampToValueAtTime(freq * 1.498, t + 0.04);

					// Keep volume alive
					this._circleGain.gain.cancelScheduledValues(t);
					this._circleGain.gain.setValueAtTime(0.16, t);
					this._circleGain2.gain.cancelScheduledValues(t);
					this._circleGain2.gain.setValueAtTime(0.06, t);

					this._circleLastRadius = radius;

					// Reset the fade-out timer (oscillator dies 200ms after last resize event)
					if (this._circleStopTimer) clearTimeout(this._circleStopTimer);
					this._circleStopTimer = setTimeout(() => {
						this._circleCleanup();
					}, 200);
				},

				_circleCleanup() {
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;
					if (this._circleGain) {
						this._circleGain.gain.cancelScheduledValues(t);
						this._circleGain.gain.setValueAtTime(this._circleGain.gain.value, t);
						this._circleGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
					}
					if (this._circleGain2) {
						this._circleGain2.gain.cancelScheduledValues(t);
						this._circleGain2.gain.setValueAtTime(this._circleGain2.gain.value, t);
						this._circleGain2.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
					}
					setTimeout(() => {
						try { if (this._circleOsc) this._circleOsc.stop(); } catch(e) {}
						try { if (this._circleOsc2) this._circleOsc2.stop(); } catch(e) {}
						this._circleOsc = null;
						this._circleOsc2 = null;
						this._circleGain = null;
						this._circleGain2 = null;
						this._circleStopTimer = null;
					}, 180);
				},

				/* ▸▸▸ DRAW: CIRCLE COMPLETE — crystalline chime ◂◂◂ */
				circleComplete() {
					if (!sfxEnabled) return;
					// Stop the continuous resize sweep first
					if (this._circleStopTimer) clearTimeout(this._circleStopTimer);
					this._circleCleanup();
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Bell-like harmonics (1, 2.76, 5.4, 8.93 — like a real bell)
					const ratios = [1, 2.76, 5.4, 8.93];
					const amps = [0.3, 0.12, 0.06, 0.03];
					const base = 440;

					ratios.forEach((r, i) => {
						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.value = base * r;
						const g = ctx.createGain();
						g.gain.setValueAtTime(amps[i], t);
						g.gain.exponentialRampToValueAtTime(0.001, t + 0.6 - i * 0.08);
						osc.connect(g).connect(sfxMasterGain);
						osc.start(t);
						osc.stop(t + 0.7);
					});
				},

				/* ▸▸▸ DRAW: ATTRACTOR — magnetic pull whir ◂◂◂ */
				attractorDraw() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(600, t);
					osc.frequency.exponentialRampToValueAtTime(150, t + 0.25);

					const lfo = ctx.createOscillator();
					lfo.type = "sine";
					lfo.frequency.value = 6;
					const lfoG = ctx.createGain();
					lfoG.gain.value = 80;
					lfo.connect(lfoG).connect(osc.frequency);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.2, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

					osc.connect(env).connect(sfxMasterGain);
					lfo.start(t); lfo.stop(t + 0.3);
					osc.start(t); osc.stop(t + 0.35);
				},

				/* ▸▸▸ DRAW: REPULSOR — push-away whoosh ◂◂◂ */
				repulsorDraw() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "sawtooth";
					osc.frequency.setValueAtTime(100, t);
					osc.frequency.exponentialRampToValueAtTime(800, t + 0.2);

					const hpf = ctx.createBiquadFilter();
					hpf.type = "highpass";
					hpf.frequency.setValueAtTime(200, t);
					hpf.frequency.linearRampToValueAtTime(1200, t + 0.2);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.15, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

					osc.connect(hpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.3);
				},

				/* ▸▸▸ DRAW: PARTICLE — sparkle fizz ◂◂◂ */
				particleEmit() {
					if (!sfxEnabled) return;
					sfxThrottle("particleEmit", 80, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;

						const noise = ctx.createBufferSource();
						noise.buffer = getNoise05();
						const bpf = ctx.createBiquadFilter();
						bpf.type = "bandpass";
						bpf.frequency.value = 3000 + Math.random() * 4000;
						bpf.Q.value = 15;

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.08, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.06);

						// Tiny sine ping
						const ping = ctx.createOscillator();
						ping.type = "sine";
						ping.frequency.value = 2000 + Math.random() * 3000;
						const pEnv = ctx.createGain();
						pEnv.gain.setValueAtTime(0.04, t);
						pEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

						noise.connect(bpf).connect(env).connect(sfxMasterGain);
						ping.connect(pEnv).connect(sfxMasterGain);
						noise.start(t); noise.stop(t + 0.08);
						ping.start(t); ping.stop(t + 0.06);
					});
				},

				/* ▸▸▸ EDIT: SLICE — sharp zip/cut ◂◂◂ */
				slice() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Noise burst through swept bandpass = "zip"
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(500, t);
					bpf.frequency.exponentialRampToValueAtTime(6000, t + 0.08);
					bpf.Q.value = 4;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.35, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

					noise.connect(bpf).connect(env).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.15);
				},

				/* ▸▸▸ EDIT: DRAG — rubbery stretch (continuous call) ◂◂◂ */
				drag() {
					if (!sfxEnabled) return;
					sfxThrottle("drag", 120, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;

						const osc = ctx.createOscillator();
						osc.type = "triangle";
						osc.frequency.setValueAtTime(100 + Math.random() * 40, t);
						osc.frequency.linearRampToValueAtTime(80 + Math.random() * 30, t + 0.1);

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.08, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

						osc.connect(env).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.15);
					});
				},

				/* ▸▸▸ EDIT: PIN — metallic tack ◂◂◂ */
				pin() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "square";
					osc.frequency.setValueAtTime(2200, t);
					osc.frequency.exponentialRampToValueAtTime(800, t + 0.04);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.25, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.08);

					const hpf = ctx.createBiquadFilter();
					hpf.type = "highpass";
					hpf.frequency.value = 600;

					osc.connect(hpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.1);
				},

				/* ▸▸▸ EDIT: FREEZE — crystalline shimmer ◂◂◂ */
				freeze() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Shimmer = detuned sine cluster
					const freqs = [1200, 1510, 1810, 2400];
					freqs.forEach((f, i) => {
						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.setValueAtTime(f + Math.random() * 20, t);
						// Slow detune drift
						osc.frequency.linearRampToValueAtTime(f - 10 + Math.random() * 20, t + 0.5);
						const g = ctx.createGain();
						g.gain.setValueAtTime(0.06, t + i * 0.02);
						g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
						osc.connect(g).connect(sfxMasterGain);
						osc.start(t + i * 0.02);
						osc.stop(t + 0.55);
					});

					// Ice crack noise
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "highpass";
					bpf.frequency.value = 4000;
					const nEnv = ctx.createGain();
					nEnv.gain.setValueAtTime(0.1, t);
					nEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
					noise.connect(bpf).connect(nEnv).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.1);
				},

				/* ▸▸▸ EDIT: DELETE — poof vanish ◂◂◂ */
				deleteSound() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Descending tone cluster = "poof"
					const osc1 = ctx.createOscillator();
					osc1.type = "sine";
					osc1.frequency.setValueAtTime(800, t);
					osc1.frequency.exponentialRampToValueAtTime(80, t + 0.3);

					// Noise whoosh
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.setValueAtTime(3000, t);
					lpf.frequency.exponentialRampToValueAtTime(200, t + 0.25);
					const nEnv = ctx.createGain();
					nEnv.gain.setValueAtTime(0.2, t);
					nEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.3, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.35);

					osc1.connect(env).connect(sfxMasterGain);
					noise.connect(lpf).connect(nEnv).connect(sfxMasterGain);
					osc1.start(t); osc1.stop(t + 0.4);
					noise.start(t); noise.stop(t + 0.3);
				},

				/* ▸▸▸ SLIDER: BLOB SIZE — blobby pitch follows value ◂◂◂ */
				sliderBlobSize(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderBlob", 60, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						const freq = 80 + pct * 4;

						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.setValueAtTime(freq, t);
						osc.frequency.exponentialRampToValueAtTime(freq * 0.7, t + 0.12);

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.12, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

						osc.connect(env).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.15);
					});
				},

				/* ▸▸▸ SLIDER: EXCITABILITY — vibrato intensity ◂◂◂ */
				sliderExcitability(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderExcite", 70, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						const freq = 220;
						const vibratoRate = 2 + pct * 0.2;
						const vibratoDepth = 5 + pct * 0.8;

						const osc = ctx.createOscillator();
						osc.type = "triangle";
						osc.frequency.value = freq;

						const lfo = ctx.createOscillator();
						lfo.type = "sine";
						lfo.frequency.value = vibratoRate;
						const lfoG = ctx.createGain();
						lfoG.gain.value = vibratoDepth;
						lfo.connect(lfoG).connect(osc.frequency);

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.1, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.14);

						osc.connect(env).connect(sfxMasterGain);
						lfo.start(t); lfo.stop(t + 0.16);
						osc.start(t); osc.stop(t + 0.16);
					});
				},

				/* ▸▸▸ SLIDER: INFLATION — breathing expansion ◂◂◂ */
				sliderInflation(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderInflation", 70, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						const freq = 60 + pct * 3;

						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.setValueAtTime(freq, t);
						osc.frequency.linearRampToValueAtTime(freq * 1.15, t + 0.1);

						// Sub-bass for "fullness"
						const sub = ctx.createOscillator();
						sub.type = "sine";
						sub.frequency.value = freq * 0.5;

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.12, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

						const subEnv = ctx.createGain();
						subEnv.gain.setValueAtTime(0.08, t);
						subEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.13);

						osc.connect(env).connect(sfxMasterGain);
						sub.connect(subEnv).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.18);
						sub.start(t); sub.stop(t + 0.16);
					});
				},

				/* ▸▸▸ SLIDER: STIFFNESS — taut string pluck ◂◂◂ */
				sliderStiffness(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderStiffness", 65, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						// Higher stiffness = higher pitch, tighter feel
						const freq = 150 + pct * 8;

						const osc = ctx.createOscillator();
						osc.type = "triangle";
						osc.frequency.setValueAtTime(freq, t);
						osc.frequency.exponentialRampToValueAtTime(freq * 0.85, t + 0.08);

						const lpf = ctx.createBiquadFilter();
						lpf.type = "lowpass";
						lpf.frequency.value = 800 + pct * 30;

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.12, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

						osc.connect(lpf).connect(env).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.12);
					});
				},

				/* ▸▸▸ SLIDER: CHAOS — distorted noise burst ◂◂◂ */
				sliderChaos(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderChaos", 60, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;

						const noise = ctx.createBufferSource();
						noise.buffer = getNoise05();

						const bpf = ctx.createBiquadFilter();
						bpf.type = "bandpass";
						bpf.frequency.value = 200 + pct * 40;
						bpf.Q.value = 2 + pct * 0.1;

						// Waveshaper for grit at high values
						const shaper = ctx.createWaveShaper();
						const curve = new Float32Array(256);
						const amt = 0.2 + (pct / 100) * 2;
						for (let i = 0; i < 256; i++) {
							const x = (i / 128) - 1;
							curve[i] = (Math.PI + amt) * x / (Math.PI + amt * Math.abs(x));
						}
						shaper.curve = curve;

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.06 + pct * 0.0015, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

						noise.connect(bpf).connect(shaper).connect(env).connect(sfxMasterGain);
						noise.start(t); noise.stop(t + 0.12);
					});
				},

				/* ▸▸▸ SLIDER: SPEED — tempo tick ◂◂◂ */
				sliderSpeed(pct) {
					if (!sfxEnabled) return;
					sfxThrottle("sliderSpeed", 55, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						const freq = 600 + pct * 12;

						const osc = ctx.createOscillator();
						osc.type = "square";
						osc.frequency.value = freq;

						const lpf = ctx.createBiquadFilter();
						lpf.type = "lowpass";
						lpf.frequency.value = 1500;

						const env = ctx.createGain();
						env.gain.setValueAtTime(0.08, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

						osc.connect(lpf).connect(env).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.06);
					});
				},

				/* ▸▸▸ UI: TOOL SELECT — soft mechanical click ◂◂◂ */
				toolSelect() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "square";
					osc.frequency.setValueAtTime(1800, t);
					osc.frequency.exponentialRampToValueAtTime(600, t + 0.02);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.15, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

					const hpf = ctx.createBiquadFilter();
					hpf.type = "highpass";
					hpf.frequency.value = 400;

					osc.connect(hpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.06);
				},

				/* ▸▸▸ UI: TOOL DESELECT — softer reverse click ◂◂◂ */
				toolDeselect() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "square";
					osc.frequency.setValueAtTime(600, t);
					osc.frequency.exponentialRampToValueAtTime(1200, t + 0.025);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.1, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

					const hpf = ctx.createBiquadFilter();
					hpf.type = "highpass";
					hpf.frequency.value = 400;

					osc.connect(hpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.05);
				},

				/* ▸▸▸ UI: UNDO — rewind whoosh ◂◂◂ */
				undo() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Descending tone = "going back"
					const osc = ctx.createOscillator();
					osc.type = "sawtooth";
					osc.frequency.setValueAtTime(900, t);
					osc.frequency.exponentialRampToValueAtTime(200, t + 0.15);

					const lpf = ctx.createBiquadFilter();
					lpf.type = "lowpass";
					lpf.frequency.setValueAtTime(3000, t);
					lpf.frequency.exponentialRampToValueAtTime(500, t + 0.15);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.2, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

					osc.connect(lpf).connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.22);
				},

				/* ▸▸▸ UI: RESET — dramatic sweep clear ◂◂◂ */
				reset() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Sweeping noise
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise1();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(4000, t);
					bpf.frequency.exponentialRampToValueAtTime(100, t + 0.5);
					bpf.Q.value = 2;

					const nEnv = ctx.createGain();
					nEnv.gain.setValueAtTime(0.3, t);
					nEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

					// Descending tone
					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(600, t);
					osc.frequency.exponentialRampToValueAtTime(40, t + 0.5);

					const oEnv = ctx.createGain();
					oEnv.gain.setValueAtTime(0.2, t);
					oEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

					noise.connect(bpf).connect(nEnv).connect(sfxMasterGain);
					osc.connect(oEnv).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.6);
					osc.start(t); osc.stop(t + 0.55);
				},

				/* ▸▸▸ UI: CONFIRM — warm positive chime ◂◂◂ */
				uiConfirm() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Major third arpeggio (C5, E5)
					[523, 659].forEach((f, i) => {
						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.value = f;
						const g = ctx.createGain();
						g.gain.setValueAtTime(0, t + i * 0.08);
						g.gain.linearRampToValueAtTime(0.18, t + i * 0.08 + 0.01);
						g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.3);
						osc.connect(g).connect(sfxMasterGain);
						osc.start(t + i * 0.08);
						osc.stop(t + i * 0.08 + 0.35);
					});
				},

				/* ▸▸▸ UI: CANCEL — descending minor ◂◂◂ */
				uiCancel() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					[440, 349].forEach((f, i) => {
						const osc = ctx.createOscillator();
						osc.type = "sine";
						osc.frequency.value = f;
						const g = ctx.createGain();
						g.gain.setValueAtTime(0, t + i * 0.07);
						g.gain.linearRampToValueAtTime(0.14, t + i * 0.07 + 0.01);
						g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.07 + 0.25);
						osc.connect(g).connect(sfxMasterGain);
						osc.start(t + i * 0.07);
						osc.stop(t + i * 0.07 + 0.3);
					});
				},

				/* ▸▸▸ GRAVITY TOGGLE — heavy thud or float ◂◂◂ */
				gravityOn() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(250, t);
					osc.frequency.exponentialRampToValueAtTime(35, t + 0.3);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.35, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.35);

					osc.connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.4);
				},

				gravityOff() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(80, t);
					osc.frequency.exponentialRampToValueAtTime(400, t + 0.25);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.2, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

					osc.connect(env).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.32);
				},

				/* ▸▸▸ APPEARANCE / DIFFUSION DIALOGS — whoosh open/close ◂◂◂ */
				dialogOpen() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(200, t);
					bpf.frequency.exponentialRampToValueAtTime(2000, t + 0.12);
					bpf.Q.value = 1.5;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.1, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

					noise.connect(bpf).connect(env).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.18);
				},

				dialogClose() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(2000, t);
					bpf.frequency.exponentialRampToValueAtTime(200, t + 0.1);
					bpf.Q.value = 1.5;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.08, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

					noise.connect(bpf).connect(env).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.15);
				},

				/* ▸▸▸ DRAWING IN-PROGRESS — continuous subtle texture ◂◂◂ */
				drawingTick(drawMode, hex) {
					if (!sfxEnabled) return;
					if (drawMode === "blob") {
						sfxThrottle("drawTick", 90, () => {
							const ctx = ensureAudioCtx();
							const t = ctx.currentTime;
							const tone = colorToTone(hex || "#0066ff");
							// Tiny liquid drip — pitch tinted by color
							const f = (200 + Math.random() * 180) * tone.pitchMult;
							const osc = ctx.createOscillator();
							osc.type = "sine";
							osc.frequency.setValueAtTime(f, t);
							osc.frequency.exponentialRampToValueAtTime(f * 0.4, t + 0.07);
							// Resonant lowpass — brightness tinted by color
							const lpf = ctx.createBiquadFilter();
							lpf.type = "lowpass";
							lpf.frequency.value = (500 + Math.random() * 200) * tone.filterMult;
							lpf.Q.value = 8;
							const env = ctx.createGain();
							env.gain.setValueAtTime(0.06, t);
							env.gain.exponentialRampToValueAtTime(0.001, t + 0.09);
							osc.connect(lpf).connect(env).connect(sfxMasterGain);
							osc.start(t); osc.stop(t + 0.1);
						});
					} else if (drawMode === "line") {
						sfxThrottle("drawTick", 90, () => {
							const ctx = ensureAudioCtx();
							const t = ctx.currentTime;
							const osc = ctx.createOscillator();
							osc.type = "sawtooth";
							osc.frequency.value = 300 + Math.random() * 100;
							const lpf = ctx.createBiquadFilter();
							lpf.type = "lowpass";
							lpf.frequency.value = 600;
							const env = ctx.createGain();
							env.gain.setValueAtTime(0.025, t);
							env.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
							osc.connect(lpf).connect(env).connect(sfxMasterGain);
							osc.start(t); osc.stop(t + 0.08);
						});
					} else if (drawMode === "attractor" || drawMode === "repulsor") {
						sfxThrottle("drawTick", 110, () => {
							const ctx = ensureAudioCtx();
							const t = ctx.currentTime;
							const f = drawMode === "attractor" ? 180 : 400;
							const osc = ctx.createOscillator();
							osc.type = "sine";
							osc.frequency.setValueAtTime(f, t);
							osc.frequency.linearRampToValueAtTime(f * (drawMode === "attractor" ? 0.7 : 1.3), t + 0.07);
							const env = ctx.createGain();
							env.gain.setValueAtTime(0.035, t);
							env.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
							osc.connect(env).connect(sfxMasterGain);
							osc.start(t); osc.stop(t + 0.1);
						});
					}
				},

				/* ▸▸▸ FILMSTRIP — camera shutter click ◂◂◂ */
				cameraShutter() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					// Shutter click = two fast noise bursts
					for (let i = 0; i < 2; i++) {
						const noise = ctx.createBufferSource();
						noise.buffer = getNoise05();
						const bpf = ctx.createBiquadFilter();
						bpf.type = "bandpass";
						bpf.frequency.value = 1500;
						bpf.Q.value = 2;
						const env = ctx.createGain();
						env.gain.setValueAtTime(0.2, t + i * 0.04);
						env.gain.exponentialRampToValueAtTime(0.001, t + i * 0.04 + 0.025);
						noise.connect(bpf).connect(env).connect(sfxMasterGain);
						noise.start(t + i * 0.04);
						noise.stop(t + i * 0.04 + 0.03);
					}
				},

				/* ▸▸▸ FULLSCREEN — whoosh transition ◂◂◂ */
				fullscreenEnter() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const noise = ctx.createBufferSource();
					noise.buffer = getNoise1();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(300, t);
					bpf.frequency.exponentialRampToValueAtTime(3000, t + 0.25);
					bpf.Q.value = 1;

					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(200, t);
					osc.frequency.exponentialRampToValueAtTime(500, t + 0.2);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.15, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
					const oEnv = ctx.createGain();
					oEnv.gain.setValueAtTime(0.1, t);
					oEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

					noise.connect(bpf).connect(env).connect(sfxMasterGain);
					osc.connect(oEnv).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.35);
					osc.start(t); osc.stop(t + 0.3);
				},

				fullscreenExit() {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;

					const noise = ctx.createBufferSource();
					noise.buffer = getNoise1();
					const bpf = ctx.createBiquadFilter();
					bpf.type = "bandpass";
					bpf.frequency.setValueAtTime(3000, t);
					bpf.frequency.exponentialRampToValueAtTime(300, t + 0.2);
					bpf.Q.value = 1;

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.12, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

					noise.connect(bpf).connect(env).connect(sfxMasterGain);
					noise.start(t); noise.stop(t + 0.3);
				},

				/* ▸▸▸ DRUM PAD HIT — percussive thump ◂◂◂ */
				drumPadHit(padIndex) {
					if (!sfxEnabled) return;
					const ctx = ensureAudioCtx();
					const t = ctx.currentTime;
					// Each pad gets a unique pitch
					const pitches = [80, 120, 200, 300, 160, 240, 100, 180];
					const freq = pitches[padIndex % pitches.length];

					const osc = ctx.createOscillator();
					osc.type = "sine";
					osc.frequency.setValueAtTime(freq * 1.5, t);
					osc.frequency.exponentialRampToValueAtTime(freq, t + 0.05);

					const env = ctx.createGain();
					env.gain.setValueAtTime(0.3, t);
					env.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

					// Noise transient
					const noise = ctx.createBufferSource();
					noise.buffer = getNoise05();
					const nf = ctx.createBiquadFilter();
					nf.type = "highpass";
					nf.frequency.value = 2000;
					const ne = ctx.createGain();
					ne.gain.setValueAtTime(0.08, t);
					ne.gain.exponentialRampToValueAtTime(0.001, t + 0.03);

					osc.connect(env).connect(sfxMasterGain);
					noise.connect(nf).connect(ne).connect(sfxMasterGain);
					osc.start(t); osc.stop(t + 0.2);
					noise.start(t); noise.stop(t + 0.05);
				},

				/* ▸▸▸ SCROLL WHEEL — subtle ratchet tick ◂◂◂ */
				scrollTick() {
					if (!sfxEnabled) return;
					sfxThrottle("scrollTick", 40, () => {
						const ctx = ensureAudioCtx();
						const t = ctx.currentTime;
						const osc = ctx.createOscillator();
						osc.type = "triangle";
						osc.frequency.value = 1400 + Math.random() * 200;
						const env = ctx.createGain();
						env.gain.setValueAtTime(0.05, t);
						env.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
						osc.connect(env).connect(sfxMasterGain);
						osc.start(t); osc.stop(t + 0.03);
					});
				}
			};

			/* ═══════════════════════════════════════════════════════════
			   END SOUND ENGINE
			   ═══════════════════════════════════════════════════════════ */

			function toast(msg, ms = 2200) {
				if (!tipsEnabled) return;
				const el = document.createElement("div");
				el.className = "toast";
				el.textContent = msg;
				$("toastStack").appendChild(el);
				requestAnimationFrame(() => el.classList.add("show")); // fade in
				setTimeout(() => {
					el.classList.remove("show"); // fade out
					el.addEventListener("transitionend", () => el.remove(), { once: true });
				}, ms);
			}

			/* -----------------------------------
			   SPLASH OVERLAY
			----------------------------------- */
			$("splashOverlay").onclick = () => {
				$("splashOverlay").style.display = "none";
			};

			/* -----------------------------------
			   DIALOG SETUP (ABOUT, HELP)
			----------------------------------- */
			function setupDialog(openBtnId, backdropId, closeBtnId) {
				const openBtn = $(openBtnId),
					backdrop = $(backdropId),
					closeBtn = $(closeBtnId);
				openBtn.addEventListener("click", () => (backdrop.style.display = "flex"));
				closeBtn.addEventListener("click", () => (backdrop.style.display = "none"));
			}
			setupDialog("menuAbout", "aboutBackdrop", "closeAbout");
			$("menuHelp").addEventListener("click", startTour);
			window.addEventListener("keydown", e => { if (e.key === "h" || e.key === "H") startTour(); });

			/* -----------------------------------
			   FILE & EXPORT MENU
			----------------------------------- */
			function setupSubmenu(menuId, submenuId) {
				const menu = $(menuId),
					submenu = $(submenuId);
				let visible = false;
				menu.addEventListener("click", (e) => {
					e.stopPropagation();
					visible = !visible;
					submenu.style.display = visible ? "flex" : "none";
				});
				document.addEventListener("click", (e) => {
					if (!menu.contains(e.target) && visible) {
						visible = false;
						submenu.style.display = "none";
					}
				});
			}
			setupSubmenu("menuFile", "fileSubmenu");
			setupSubmenu("menuExport", "exportSubmenu");


			/* ---------- PRESETS ---------- */
			$("menuPresets").onclick = () => {
				$("presetsBackdrop").style.display = "flex";
			};

			/* close gallery */
			$("closePresets").onclick = () =>
				$("presetsBackdrop").style.display = "none";

			/* show the Grid-options dialog when the card is clicked */
			$("presetGrid").onclick = () => {
				$("presetsBackdrop").style.display = "none";
				$("gridBackdrop").style.display = "flex";
			};

			/* cancel grid dialog */
			$("cancelGrid").onclick = () =>
				$("gridBackdrop").style.display = "none";

			/* show / hide the custom-radius row */
			$("autoRadius").onchange = () =>
				$("radiusRow").style.display = $("autoRadius").checked ? "none" : "block";

			/* apply grid */
			$("applyGrid").onclick = () => {
				const count = Math.min(12,
					Math.max(1, parseInt($("gridCount").value, 10) || 1));
				/* this radius would make circles kiss each other and the edges */
				/* leave a 1px gap between adjacent circles */
				const maxR = (Math.min(canvas.width, canvas.height) - (count - 1)) / (count * 2);

				const radius = $("autoRadius").checked ?
					maxR :
					Math.min(parseFloat($("gridRadius").value) || 2, maxR);

				const spacing = 2 * maxR + 1; // +1 ensures 1px gap between centers

				for (let r = 0; r < count; r++) {
					for (let c = 0; c < count; c++) {
						circles.push({
							x: maxR + c * spacing,
							y: maxR + r * spacing,
							radius // may be < maxR ⇒ nice margin
						});
						history.push({ type: "circle" });
					}
				}

				/* set Blob Size slider to 0 % and Excitability to 85 % */
				setDotScale(0); // updates UI + dotScaleFactor
				damping = 0.85;
				$("dampingSlider").value = 85;
				$("dampingValue").textContent = "85%";
				/* ── 1. High Repulsion ON ── */
				if (interRepelMult !== 3) { // 1 = normal, 3 = high
					interRepelMult = 3;
					toggleActiveIcon($("iconDiffusion"), true);
				}

				/* ── 2. Blob draw-mode ── */
				setDrawMode("blob"); // switches UI + cursor

				/* ── 3. Edit tools OFF ── */
				slicingMode = dragMode = pinMode =
					freezeMode = deleteMode = false; // clear flags
				$("editToolsSection").classList.remove("edit-on");
				["iconSlice", "iconDrag", "iconPin", "iconFreeze", "iconDelete"]
				.forEach(id => setIconActive($(id), false, "", ""));
				updateCanvasCursor();

				if (!showFilled) {
					showFilled = true;
					$("iconFill").title = "Solid Fill On";
					toggleActiveIcon($("iconFill"), true);
				}

				toast(`Grid (${count}×${count}) added`, 1600);
				$("gridBackdrop").style.display = "none";
			};

			/* === ANTHRO BLOBS PRESET =========================================== */
			$("presetAnthro").onclick = () => {
				$("presetsBackdrop").style.display = "none"; // close gallery
				addAnthroBlobs(8); // draw 8 faces by default
			};

			/* helper: main face + eyes + pupils + mouth ------------------------- */
			function addAnthroBlobs(count = 8) {

				/* clamp Excitability (damping) to 0 % */
				damping = 0;
				$("dampingSlider").value = 0;
				$("dampingValue").textContent = "0%";

				/* step 0 ─ turn High-Repel ON (keeps blobs apart) */
				if (interRepelMult !== 3) { // 1 = normal, 3 = boosted
					interRepelMult = 3; // physics flag
					toggleActiveIcon($("iconDiffusion"), true); // light the toolbar icon
				}

				const palette = ["#ff3333", "#ffd700", "#0066ff", "#000000"]; // red, yellow, blue, black
				const placed = []; // remember centres

				for (let k = 0; k < count; k++) {

					/* find a free, non-overlapping position (≤100 tries) */
					let cx, cy, R, ok, tries = 100;
					do {
						R = 30 + Math.random() * 40; // 30‒70 px radius
						cx = R + Math.random() * (canvas.width - 2 * R);
						cy = R + Math.random() * (canvas.height - 2 * R);

						ok = true;
						for (const p of placed) {
							const minGap = R + p.R + 6; // 6 px padding
							if (Math.hypot(cx - p.cx, cy - p.cy) < minGap) { ok = false; break; }
						}
					} while (!ok && --tries);
					if (!ok) continue; // couldn’t place

					placed.push({ cx, cy, R });

					/* 1 ─ base face blob */
					const faceCol = palette[Math.floor(Math.random() * palette.length)];
					const faceArr = hexToRGBA(faceCol);
					chains.push(makeCircleBlob(cx, cy, R, faceArr));
					history.push({ type: "chain" });

					/* 2 ─ eyes & pupils */
					const eyeDX = R * 0.30,
						eyeDY = -R * 0.20,
						eyeR = R * 0.18;
					const pupilR = eyeR * 0.40;
					const white = hexToRGBA("#ffffff");
					const pupilArr = hexToRGBA("#000000"); // pupils always black

					// left eye
					chains.push(makeCircleBlob(cx - eyeDX, cy + eyeDY, eyeR, white, 10));
					chains.push(makeCircleBlob(cx - eyeDX, cy + eyeDY, pupilR, pupilArr, 8));
					// right eye
					chains.push(makeCircleBlob(cx + eyeDX, cy + eyeDY, eyeR, white, 10));
					chains.push(makeCircleBlob(cx + eyeDX, cy + eyeDY, pupilR, pupilArr, 8));
					history.push({ type: "chain" }, { type: "chain" }, { type: "chain" }, { type: "chain" });

					/* 3 ─ mouth (more-dots straight line) ----------------------------- */
					const mouthY = cy + R * 0.25,
						mouthW = R * 0.75, // width already bumped
						mouthArr = hexToRGBA(faceCol === "#000000" ? "#ffffff" : "#000000");

					/* roughly 8 points across the span (left → right) */
					const mouthPts = [];
					const segments = 7; // 7 gaps ⇒ 8 dots
					for (let i = 0; i <= segments; i++) {
						const t = i / segments; // 0 … 1
						mouthPts.push({
							x: cx - mouthW + 2 * mouthW * t, // linear x-interpolation
							y: mouthY, // keep flat (straight line)
							vx: 0,
							vy: 0,
							pinned: false
						});
					}

					chains.push({
						chain: mouthPts,
						color: mouthArr,
						baseDotRadius: R * 0.06,
						isClosed: false,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				/* make sure fill mode + Blob draw-mode are active */
				if (!showFilled) {
					showFilled = true;
					$("iconFill").title = "Solid Fill On";
					toggleActiveIcon($("iconFill"), true);
				}
				setDrawMode("blob");

				toast(`Anthro blobs (${count}) added`, 1600);
				toast("Raise the Excitability slider to see the blobs come alive!", 3000);
			}

			/* === GRID-OF-BLOBS PRESET ======================================== */
			$("presetBlobGrid").onclick = () => {
				$("presetsBackdrop").style.display = "none"; // ✨ hide gallery
				$("blobGridBackdrop").style.display = "flex"; // show blob-dialog
			};

			/* toggle custom size row */
			$("blobAutoSize").onchange = () =>
				$("blobSizeRow").style.display = $("blobAutoSize").checked ? "none" : "block";

			/* helper to create a simple circular blob (you could swap in fancier math) */
			function makeCircleBlob(cx, cy, r, colorArr, steps = 48) {
				const pts = [];
				for (let i = 0; i < steps; i++) {
					const θ = i / steps * 2 * Math.PI;
					pts.push({
						x: cx + r * Math.cos(θ),
						y: cy + r * Math.sin(θ),
						vx: 0,
						vy: 0,
						pinned: false
					});
				}
				return {
					chain: pts,
					color: colorArr,
					baseDotRadius: r * 0.12,
					isClosed: true,
					frozen: false
				};
			}

			/* Apply button */
			$("applyBlobGrid").onclick = () => {
				/* 1 ─ grid sizing */
				const cnt = Math.min(10,
					Math.max(1, parseInt($("blobGridCount").value, 10) || 1));
				const maxR = Math.min(canvas.width, canvas.height) / (cnt * 2);

				const baseR = $("blobAutoSize").checked ?
					maxR :
					Math.min(parseFloat($("blobBaseRadius").value) || 4, maxR);

				const spacing = 2 * maxR; // centres stay fixed

				const chosenColor = hexToRGBA($("blobColor").value);
				/* 2 ─ add blobs */
				for (let r = 0; r < cnt; r++) {
					for (let c = 0; c < cnt; c++) {
						const cx = maxR + c * spacing;
						const cy = maxR + r * spacing;
						const blob = makeCircleBlob(cx, cy, baseR, chosenColor);
						chains.push(blob);
						history.push({ type: "chain" });
					}
				}

				/* 3 ─ snap UI states exactly like circle-grid did */
				{
					if (interRepelMult !== 3) {
						interRepelMult = 3;
						toggleActiveIcon($("iconDiffusion"), true);
					}
					setDrawMode("blob");
					$("dampingSlider").value = 40;
					$("dampingValue").textContent = "40%";
					setDotScale(12);
					damping = 0.40;
					turgorPressure = 0;
					const tpSlider = $("turgorPressureSlider");
					const tpValue  = $("turgorPressureValue");
					if (tpSlider && tpValue) {
						tpSlider.value = 0;
						tpValue.textContent = "0%";
					}

					slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;
					$("editToolsSection").classList.remove("edit-on");
					["iconSlice", "iconDrag", "iconPin", "iconFreeze", "iconDelete"]
					.forEach(id => setIconActive($(id), false, "", ""));
					updateCanvasCursor();
				}

				toast(`Blob grid (${cnt}×${cnt}) added`, 1600);
				$("blobGridBackdrop").style.display = "none";
			};
			$("cancelBlobGrid").onclick = () =>
				$("blobGridBackdrop").style.display = "none";

			/* -----------------------------------
			   WEBGL CONTEXT
			----------------------------------- */
			const canvas = $("glCanvas");

			// --- Pointer normalization helpers ---
			function getCanvasXY(evt) {
				// Use CSS box but scale into the canvas's internal pixel space
				const rect = canvas.getBoundingClientRect();
				const scaleX = canvas.width / rect.width;
				const scaleY = canvas.height / rect.height;
				const x = (evt.clientX - rect.left) * scaleX;
				const y = (evt.clientY - rect.top) * scaleY;
				return { x, y };
			}

			// Primary pointer test: accept pen/touch, left mouse only
			function isPrimaryPointer(evt) {
				return (evt.isPrimary !== false) && (evt.pointerType !== "mouse" || evt.button === 0);
			}

			// Optional: use pressure for dynamic radius when drawing with Pencil
			function getPressure(evt) {
				// 0..1 on Apple Pencil; mouse is 0 or 0.5+ depending on browser
				return (typeof evt.pressure === "number" && evt.pressure > 0) ? evt.pressure : 1;
			}


			// PERFORMANCE: Try WebGL 2.0 first for GPU acceleration features, fallback to WebGL 1.0
			// preserveDrawingBuffer: true is needed for frame capture functionality
			let gl = canvas.getContext("webgl2", { stencil: true, preserveDrawingBuffer: true });
			const isWebGL2 = !!gl;
			if (!gl) {
				gl = canvas.getContext("webgl", { stencil: true, preserveDrawingBuffer: true });
				if (!gl) alert("WebGL not supported by your browser.");
			}

			// GPU acceleration features available
			const hasTransformFeedback = isWebGL2 && !!gl.getExtension("EXT_transform_feedback");
			const hasInstancedRendering = isWebGL2 || !!gl.getExtension("ANGLE_instanced_arrays");

			// Use GPU physics when WebGL 2.0 is available (texture-based approach works without transform feedback)
			// Transform feedback is NOT required - we use texture rendering which works on iPad/Safari
			const useGPUPhysics = isWebGL2;
			gl.enable(gl.BLEND);
			gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,
				gl.ONE, gl.ONE_MINUS_SRC_ALPHA);


			// Prevent browser context menu on canvas - use capture phase to catch it early
			// ───── Unified Pointer Events (mouse + touch + Pencil) ─────
			let activePointerId = null;

			canvas.addEventListener("pointerdown", (e) => {
				if (!isPrimaryPointer(e)) return;
				e.preventDefault();
				activePointerId = e.pointerId;
				canvas.setPointerCapture(activePointerId);

				const { x, y } = getCanvasXY(e);
				const pressure = getPressure(e);

				currentMouseX = x;
				currentMouseY = y;
				
				// Track pointer down for double-tap detection
				pointerDownTime = Date.now();
				pointerDownX = x;
				pointerDownY = y;
				pointerDownType = e.pointerType; // Track if this is pen, touch, or mouse

				// Long-press detection for attractor gradient curve editor (iPad/touch)
				if (longPressAttractorTimer) { clearTimeout(longPressAttractorTimer); longPressAttractorTimer = null; }
				longPressAttractorIndex = null;
				{
					let hitIdx = null;
					let minDist = Infinity;
					for (let i = 0; i < attractorsRepulsors.length; i++) {
						const ar = attractorsRepulsors[i];
						if (ar.type !== 'attractor' || ar.path.length < 2) continue;
						for (let j = 0; j < ar.path.length - 1; j++) {
							const p1 = ar.path[j], p2 = ar.path[j + 1];
							const dx = p2.x - p1.x, dy = p2.y - p1.y;
							const lenSq = dx * dx + dy * dy;
							let d;
							if (lenSq < 1e-8) {
								d = Math.hypot(x - p1.x, y - p1.y);
							} else {
								const t = Math.max(0, Math.min(1, ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq));
								d = Math.hypot(x - (p1.x + t * dx), y - (p1.y + t * dy));
							}
							if (d < 20 && d < minDist) { minDist = d; hitIdx = i; }
						}
					}
					if (hitIdx !== null) {
						longPressAttractorIndex = hitIdx;
						longPressAttractorStartX = x;
						longPressAttractorStartY = y;
						longPressAttractorTimer = setTimeout(() => {
							if (longPressAttractorIndex === null) return;
							const ar = attractorsRepulsors[longPressAttractorIndex];
							if (ar) {
								if (!ar.gradientMode) {
									ar.gradientMode = 'forward';
									toast("Gradient mode enabled: Forward", 1200);
								}
								openGradientCurveEditor(longPressAttractorIndex);
							}
							longPressAttractorIndex = null;
							longPressAttractorTimer = null;
						}, ATTRACTOR_LONG_PRESS_MS);
					}
				}

				// Handle capture area selection (crosshairs mode)
				if (filmstripData.crosshairsMode) {
					filmstripData.isDraggingCaptureArea = true;
					filmstripData.captureAreaStart = { x, y };
					filmstripData.captureAreaCurrent = { x, y };
					return; // Don't process other drawing modes
				}

				if (drawMode === 'circle') {
					if (dragMode) {
						for (let i = 0; i < circles.length; i++) {
							const c = circles[i];
							if (Math.hypot(x - c.x, y - c.y) < c.radius + 5) { draggingCircleIndex = i; return; }
						}
						return;
					} else {

						// ── Long-press to resize an existing circle ───────────────────
						// ── Long-press to resize an existing circle ───────────────────
						{
							let hitIndex = null;
							for (let i = circles.length - 1; i >= 0; i--) {
								const c = circles[i];
								const d = Math.hypot(x - c.x, y - c.y);
								if (d <= c.radius) { hitIndex = i; break; }
							}

							if (hitIndex !== null) {
								waitingForLongPress = true; // <— NEW
								longPressTargetIndex = hitIndex;
								longPressStartX = x;
								longPressStartY = y;

								if (longPressTimer) {
									clearTimeout(longPressTimer);
									longPressTimer = null;
								}
								longPressTimer = setTimeout(() => {
									// Activate resize mode after 5s (only if we’re still waiting)
									if (!waitingForLongPress) return;
									resizingCircleIndex = longPressTargetIndex;
									if (resizingCircleIndex !== null) {
										circles[resizingCircleIndex].__resizing = true;
									}
									isCircleDrawing = false;
									currentCircle = null;
									waitingForLongPress = false; // we’re no longer waiting
								}, resizeHoldMs);

								return; // Defer decision to move: either resize (after 5s) or start new circle on drift
							}
						}
						// ───────────────────────────────────────────────────────────────
						// ───


						isCircleDrawing = true;
						currentCircle = { x, y, radius: 0 };
						SFX.circleResize(0);
						return;
					}
				}

				if (freezeMode) {
					// Start lasso selection for freeze mode
					freezeLassoActive = true;
					freezeLassoPath = [{ x, y }];
					return; // stop further handling
				}
				if (deleteMode) {
					// Start lasso selection for delete mode
					deleteLassoActive = true;
					deleteLassoPath = [{ x, y }];
					return; // stop further handling in delete mode
				}

				if (pinMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20; // same radius you use in mousedown

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dx = x - ch[i].x;
							const dy = y - ch[i].y;
							const d = Math.hypot(dx, dy);
							if (d < pickRadius && d < bestDist) {
								bestDist = d;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const dot = chains[bestChainIndex].chain[bestDotIndex];
						dot.pinned = !dot.pinned; // toggle
						SFX.pin();
					}
					return; // stop further handling
				}

				const wantDrag = (dragMode || drawMode === "none");

				if (wantDrag) {
				  // 1) Prefer dragging blob dots first
				  let bestChainIndex = null;
				  let bestDotIndex = null;
				  let bestDist = Infinity;
				  const pickRadius = 20;

				  for (let c = 0; c < chains.length; c++) {
				    const ch = chains[c].chain;
				    for (let i = 0; i < ch.length; i++) {
				      const dot = ch[i];
				      const dx = x - dot.x;
				      const dy = y - dot.y;
				      const dist = Math.sqrt(dx * dx + dy * dy);
				      if (dist < pickRadius && dist < bestDist) {
				        bestDist = dist;
				        bestChainIndex = c;
				        bestDotIndex = i;
				      }
				    }
				  }

				  if (bestChainIndex !== null) {
				    draggingChainIndex = bestChainIndex;
				    draggingDotIndex = bestDotIndex;
				    return;
				  }

				  // 2) Only if no blob dot was hit, allow circle dragging
				  const circlePad = 3; // was effectively 5; smaller reduces accidental grabs
				  const ci = pickCircleIndex(x, y, circlePad);
				  if (ci !== null) {
				    draggingCircleIndex = ci;
				    return;
				  }
				}




				if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
					isDrawing = true;
					currentPathPoints = [{ x, y, vx: 0, vy: 0, pinned: false }];
					if (drawMode === 'blob') SFX.blobDraw(colorInput.value); else SFX.lineDraw();
					// Store start point for straight line drawing when shift is held
					if (e.shiftKey) {
						shiftKeyHeld = true;
						straightLineStart = { x, y };
					} else {
						shiftKeyHeld = false;
						straightLineStart = null;
					}
				}

				// Start drawing attractor/repulsor
				if ((drawMode === 'attractor' || drawMode === 'repulsor') && !dragMode && attractorRepulsorType) {
					isDrawing = true;
					currentAttractorRepulsorPath = [{ x, y }];
					if (drawMode === 'attractor') SFX.attractorDraw(); else SFX.repulsorDraw();
					// Store start point for straight line drawing when shift is held
					if (e.shiftKey) {
						shiftKeyHeld = true;
						straightLineStart = { x, y };
					} else {
						shiftKeyHeld = false;
						straightLineStart = null;
					}
				}

				// Start particle emitter
				if (drawMode === 'particle' && !dragMode) {
					startParticleEmission();
				}
				// ↑↑↑ END: adapted mousedown body
			}, { passive: false });

			canvas.addEventListener("pointermove", (e) => {
				if (activePointerId !== null && e.pointerId !== activePointerId) return;

				// Use the main event, not coalesced events, to maintain consistent vertex spacing
				// Coalesced events can create too many vertices in Chrome
				let { x, y } = getCanvasXY(e);

				// Update shift key state from event (in case it changed during drawing)
				if (e.shiftKey && !shiftKeyHeld && isDrawing && !straightLineStart) {
					shiftKeyHeld = true;
					straightLineStart = { x: currentMouseX, y: currentMouseY };
				} else if (!e.shiftKey && shiftKeyHeld) {
					shiftKeyHeld = false;
					straightLineStart = null;
				}

				// Constrain to straight line when shift is held (check both tracked state and event)
				// Only horizontal or vertical - no diagonal
				if ((shiftKeyHeld || e.shiftKey) && straightLineStart && isDrawing) {
					const dx = x - straightLineStart.x;
					const dy = y - straightLineStart.y;
					const absDx = Math.abs(dx);
					const absDy = Math.abs(dy);

					// Simple: snap to whichever direction has more movement
					if (absDx > absDy) {
						// Horizontal constraint
						y = straightLineStart.y;
					} else {
						// Vertical constraint
						x = straightLineStart.x;
					}
				}

				currentMouseX = x;
				currentMouseY = y;

				// Handle capture area dragging
				if (filmstripData.isDraggingCaptureArea && filmstripData.captureAreaStart) {
					filmstripData.captureAreaCurrent = { x, y };
					return; // Don't process other drawing modes
				}

				// If we were waiting for long-press but the finger moved too much, start drawing a new circle instead
				if (waitingForLongPress && longPressTimer && longPressTargetIndex !== null) {
					const drift = Math.hypot(x - longPressStartX, y - longPressStartY);
					if (drift > LONG_PRESS_MOVE_CANCEL) {
						// Cancel long-press path
						clearTimeout(longPressTimer);
						longPressTimer = null;
						waitingForLongPress = false;
						longPressTargetIndex = null;

						// Start a new circle draw RIGHT HERE (even if inside another circle)
						isCircleDrawing = true;
						// Seed from the original touch-down point for a natural feel
						currentCircle = {
							x: longPressStartX,
							y: longPressStartY,
							radius: drift, // small initial radius based on the first move
						};
					}
				}
				// Cancel pending long-press if finger drifts too far
				if (longPressTimer && longPressTargetIndex !== null) {
					const drift = Math.hypot(x - longPressStartX, y - longPressStartY);
					if (drift > LONG_PRESS_MOVE_CANCEL) {
						clearTimeout(longPressTimer);
						longPressTimer = null;
						longPressTargetIndex = null;
					}
				}

				// Cancel attractor long-press if finger drifts too far
				if (longPressAttractorTimer && longPressAttractorIndex !== null) {
					const drift = Math.hypot(x - longPressAttractorStartX, y - longPressAttractorStartY);
					if (drift > ATTRACTOR_LONG_PRESS_MOVE_CANCEL) {
						clearTimeout(longPressAttractorTimer);
						longPressAttractorTimer = null;
						longPressAttractorIndex = null;
					}
				}

				// Live-resize an active circle
				if (resizingCircleIndex !== null) {
					const c = circles[resizingCircleIndex];
					c.radius = Math.hypot(x - c.x, y - c.y);
					// optional HUD
					if (typeof circleInfo !== 'undefined' && circleInfo) {
						circleInfo.textContent = "r: " + Math.round(c.radius);
						circleInfo.style.left = (e.clientX + 14) + "px";
						circleInfo.style.top = (e.clientY + 18) + "px";
						circleInfo.style.display = "block";
					}
					return; // swallow move while resizing
				}
				// draw path (blob/line)
				if (isDrawing && (drawMode === 'blob' || drawMode === 'line')) {
					const last = currentPathPoints[currentPathPoints.length - 1];
					// PERFORMANCE: Increase threshold slightly to reduce vertex density in Chrome
					// Chrome fires pointermove events more frequently than Firefox
					const minDist = 2.0; // Increased from 1.5 to reduce vertex count
					if (Math.hypot(x - last.x, y - last.y) > minDist) {
						currentPathPoints.push({ x, y, vx: 0, vy: 0, pinned: false });
						SFX.drawingTick(drawMode, colorInput.value);
					}
				}

				// draw attractor/repulsor path (leaner - larger minDist to reduce point count)
				if (isDrawing && (drawMode === 'attractor' || drawMode === 'repulsor')) {
					const last = currentAttractorRepulsorPath[currentAttractorRepulsorPath.length - 1];
					const minDist = 8.0; // Increased from 2.0 to make paths much leaner and reduce performance impact
					if (Math.hypot(x - last.x, y - last.y) > minDist) {
						currentAttractorRepulsorPath.push({ x, y });
						SFX.drawingTick(drawMode);
					}
				}

				// resize in-progress circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					currentCircle.radius = Math.hypot(x - currentCircle.x, y - currentCircle.y);
				}

				if ((dragMode || drawMode === "none") && draggingCircleIndex !== null) {
				  circles[draggingCircleIndex].x = x;
				  circles[draggingCircleIndex].y = y;
				}

				// Delete lasso: add points to the lasso path
				if (deleteMode && deleteLassoActive) {
					const last = deleteLassoPath[deleteLassoPath.length - 1];
					if (Math.hypot(x - last.x, y - last.y) > 3) {
						deleteLassoPath.push({ x, y });
					}
				}

				// Freeze lasso: add points to the lasso path
				if (freezeMode && freezeLassoActive) {
					const last = freezeLassoPath[freezeLassoPath.length - 1];
					if (Math.hypot(x - last.x, y - last.y) > 3) {
						freezeLassoPath.push({ x, y });
					}
				}

				// pin/drag hover highlight
				if ((pinMode || dragMode) && (e.movementX || e.movementY)) {
					pinHoverChainIndex = null;
					pinHoverDotIndex = null;
					let bestDist = Infinity;
					const hoverRad = 20;
					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const d = Math.hypot(x - ch[i].x, y - ch[i].y);
							if (d < hoverRad && d < bestDist) {
								bestDist = d;
								pinHoverChainIndex = c;
								pinHoverDotIndex = i;
							}
						}
					}
				}
			}, { passive: false });

			function finalizePointer(e) {
				if (activePointerId !== null && e.pointerId !== activePointerId) return;

				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					if (currentCircle.radius > 5) {
						circles.push(currentCircle);
						history.push({ type: "circle" });
						SFX.circleComplete();
					}
					isCircleDrawing = false;
					currentCircle = null;
					draggingCircleIndex = null;
					circleInfo.style.display = "none";
				}

				if (isDrawing && currentPathPoints.length > 2 &&
					(drawMode === 'blob' || drawMode === 'line')) {
					let r = globalRadiusAvg + (Math.random() * 2 - 1) * globalRadiusVar;
					if (r < 1) r = 1;
					const chosenColor = hexToRGBA(colorInput.value);
					const isClosed = (drawMode === 'blob');
					if (isClosed) {
						const f = currentPathPoints[0];
						currentPathPoints.push({ ...f });
						SFX.blobComplete(colorInput.value);
					} else {
						SFX.lineComplete();
					}
					chains.push({
						chain: currentPathPoints.slice(),
						color: chosenColor,
						baseDotRadius: r,
						isClosed,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				// Finalize attractor/repulsor path
				if (isDrawing && currentAttractorRepulsorPath.length > 2 &&
					(drawMode === 'attractor' || drawMode === 'repulsor')) {
					attractorsRepulsors.push({
						path: currentAttractorRepulsorPath.slice(),
						type: attractorRepulsorType,
						gradientMode: null, // null, 'forward', or 'backward'
						gradientCurve: null, // Sampled curve array for physics (null = use default based on gradientMode)
						gradientCurveControlPoints: null, // Original control points for editing (null = use default)
						temporalMode: 'none', // 'none', 'oscillate', or 'shift'
						temporalFrequency: 1.0, // Oscillations per second
						temporalAmplitude: 0.5, // Amplitude of temporal variation (0-1)
						shiftDirection: 'forward' // 'forward' or 'backward' for shift mode
					});
					history.push({ type: "attractorRepulsor" });
				}

				isDrawing = false;
				// Stop particle emission if active
				stopParticleEmission();
				// Reset shift key state when drawing ends
				shiftKeyHeld = false;
				straightLineStart = null;
				currentAttractorRepulsorPath = [];
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;

				// ── Delete lasso finalization ──
				if (deleteMode && deleteLassoActive) {
					if (deleteLassoPath.length < 4) {
						// Too few points = single-click delete (original behavior)
						const p = deleteLassoPath[0];
						if (p) performSingleDelete(p.x, p.y);
					} else {
						// Close the lasso and delete everything inside
						performLassoDelete(deleteLassoPath);
					}
					deleteLassoActive = false;
					deleteLassoPath = [];
				}

				// ── Freeze lasso finalization ──
				if (freezeMode && freezeLassoActive) {
					if (freezeLassoPath.length < 4) {
						// Too few points = single-click freeze (original behavior)
						const p = freezeLassoPath[0];
						if (p) performSingleFreeze(p.x, p.y);
					} else {
						// Close the lasso and freeze everything inside
						performLassoFreeze(freezeLassoPath);
					}
					freezeLassoActive = false;
					freezeLassoPath = [];
				}

				if (longPressTimer) {
					clearTimeout(longPressTimer);
					longPressTimer = null;
				}
				waitingForLongPress = false; // <— NEW
				longPressTargetIndex = null;

				// Cancel any pending attractor long-press
				if (longPressAttractorTimer) {
					clearTimeout(longPressAttractorTimer);
					longPressAttractorTimer = null;
				}
				longPressAttractorIndex = null;

				// Handle capture area completion
				if (filmstripData.isDraggingCaptureArea && filmstripData.captureAreaStart && filmstripData.captureAreaCurrent) {
					const start = filmstripData.captureAreaStart;
					const current = filmstripData.captureAreaCurrent;

					const x = Math.min(start.x, current.x);
					const y = Math.min(start.y, current.y);
					const w = Math.abs(current.x - start.x);
					const h = Math.abs(current.y - start.y);

					// Only set if area is large enough (at least 10x10 pixels)
					if (w >= 10 && h >= 10) {
						filmstripData.captureArea = {
							x: Math.max(0, Math.min(x, canvas.width)),
							y: Math.max(0, Math.min(y, canvas.height)),
							width: Math.min(w, canvas.width),
							height: Math.min(h, canvas.height)
						};
						toast(`Capture area set: ${Math.round(filmstripData.captureArea.width)}×${Math.round(filmstripData.captureArea.height)}`, 1500);
					} else {
						toast("Capture area too small", 1200);
					}

					filmstripData.isDraggingCaptureArea = false;
					filmstripData.captureAreaStart = null;
					filmstripData.captureAreaCurrent = null;
					filmstripData.crosshairsMode = false; // Deactivate after setting area
					$("filmstripCrosshairsBtn").classList.remove("active");

					// Restore previous cursor
					if (filmstripData.previousCursor !== null) {
						canvas.style.cursor = filmstripData.previousCursor;
						filmstripData.previousCursor = null;
					} else {
						canvas.style.cursor = '';
					}
				}

				// If we *were* resizing, turn off highlight and exit resize mode
				if (resizingCircleIndex !== null) {
					circles[resizingCircleIndex].__resizing = false; // remove blue rim
					resizingCircleIndex = null;

					// Hide any radius HUD if you added it
					if (typeof circleInfo !== 'undefined' && circleInfo) {
						circleInfo.style.display = "none";
					}
				}
				
				// Double-tap detection for iPad/touch devices (including Apple Pencil)
				// Only detect double-tap if this was a quick tap (not a drag) and not in drawing mode
				const { x: tapX, y: tapY } = getCanvasXY(e);
				const tapDuration = Date.now() - pointerDownTime;
				const tapDistance = Math.hypot(tapX - pointerDownX, tapY - pointerDownY);
				
				// Use pen-specific thresholds if this is a pen event (check both stored and current event type)
				const isPen = (pointerDownType === "pen" || e.pointerType === "pen");
				const maxTapDuration = isPen ? MAX_TAP_DURATION_PEN : MAX_TAP_DURATION;
				const maxTapDistance = isPen ? DOUBLE_TAP_DISTANCE_PEN : DOUBLE_TAP_DISTANCE;
				const wasQuickTap = tapDuration < maxTapDuration && tapDistance < maxTapDistance;
				
				// Check if we're not in the middle of drawing/dragging and this was a quick tap
				// Allow double-tap in any mode as long as we're not actively drawing/dragging
				if (wasQuickTap && !isDrawing && draggingChainIndex === null && draggingDotIndex === null && 
				    draggingCircleIndex === null && !filmstripData.isDraggingCaptureArea && 
				    resizingCircleIndex === null && currentAttractorRepulsorPath.length === 0) {
					
					const currentTime = Date.now();
					const timeSinceLastTap = currentTime - lastTapTime;
					const distanceFromLastTap = Math.hypot(tapX - lastTapX, tapY - lastTapY);
					
					// Check if this is a double-tap (within time and distance thresholds)
					// Use pen-specific distance threshold if this is a pen event
					const maxDoubleTapDistance = isPen ? DOUBLE_TAP_DISTANCE_PEN : DOUBLE_TAP_DISTANCE;
					if (timeSinceLastTap < DOUBLE_TAP_TIME && distanceFromLastTap < maxDoubleTapDistance) {
						// This is a double-tap! Trigger the conversion handler
						handleDoubleTapConversion(tapX, tapY, false);
						// Reset tap tracking to prevent triple-tap
						lastTapTime = 0;
						lastTapX = 0;
						lastTapY = 0;
					} else {
						// Store this tap for potential double-tap detection
						lastTapTime = currentTime;
						lastTapX = tapX;
						lastTapY = tapY;
					}
				} else {
					// Reset tap tracking if this wasn't a quick tap
					lastTapTime = 0;
					lastTapX = 0;
					lastTapY = 0;
				}
				
				try { canvas.releasePointerCapture(activePointerId); } catch {}
				activePointerId = null;
			}

			canvas.addEventListener("pointerup", finalizePointer, { passive: true });
			canvas.addEventListener("pointercancel", finalizePointer, { passive: true });

			// Double-click to convert blob/line to attractor/repulsor OR cycle gradient mode on attractors
			// Shift-click on attractor with gradient opens curve editor
			let chainToConvertIndex = null; // Store chain index for conversion
			
			// Double-tap detection for iPad/touch devices
			let lastTapTime = 0;
			let lastTapX = 0;
			let lastTapY = 0;
			let pointerDownTime = 0;
			let pointerDownX = 0;
			let pointerDownY = 0;
			let pointerDownType = null; // Track pointer type for pen-specific handling
			const DOUBLE_TAP_TIME = 300; // milliseconds
			const DOUBLE_TAP_DISTANCE = 30; // pixels
			const DOUBLE_TAP_DISTANCE_PEN = 40; // pixels - slightly larger for pen (angle/hover)
			const MAX_TAP_DURATION = 200; // milliseconds - max time for a tap (vs drag)
			const MAX_TAP_DURATION_PEN = 250; // milliseconds - slightly longer for pen
			
			// Long-press for attractor gradient curve editor (iPad/touch)
			let longPressAttractorTimer = null;
			let longPressAttractorIndex = null;
			let longPressAttractorStartX = 0;
			let longPressAttractorStartY = 0;
			const ATTRACTOR_LONG_PRESS_MS = 500;
			const ATTRACTOR_LONG_PRESS_MOVE_CANCEL = 10;
			
			// Reusable function to handle double-click/tap conversion logic
			function handleDoubleTapConversion(x, y, shiftKey = false) {

				// First, check if an attractor was clicked (only for attractors, not repulsors)
				let clickedAttractorIndex = null;
				let minAttractorDist = Infinity;
				for (let i = 0; i < attractorsRepulsors.length; i++) {
					const ar = attractorsRepulsors[i];
					// Only handle attractors (not repulsors) for gradient mode
					if (ar.type !== 'attractor' || ar.path.length < 2) continue;

					// Check if point is near the attractor path (within 15px for easier clicking)
					let minDist = Infinity;
					for (let j = 0; j < ar.path.length - 1; j++) {
						const p1 = ar.path[j];
						const p2 = ar.path[j + 1];
						const dx = p2.x - p1.x;
						const dy = p2.y - p1.y;
						const lenSq = dx * dx + dy * dy;

						if (lenSq < 1e-8) {
							// Degenerate segment, use point distance
							const dist = Math.hypot(x - p1.x, y - p1.y);
							minDist = Math.min(minDist, dist);
						} else {
							const t = Math.max(0, Math.min(1, ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq));
							const px = p1.x + t * dx;
							const py = p1.y + t * dy;
							const dist = Math.hypot(x - px, y - py);
							minDist = Math.min(minDist, dist);
						}
					}

					if (minDist < 15 && minDist < minAttractorDist) {
						minAttractorDist = minDist;
						clickedAttractorIndex = i;
					}
				}

				// If an attractor was clicked
				if (clickedAttractorIndex !== null) {
					const ar = attractorsRepulsors[clickedAttractorIndex];
					
					// Shift-click: open curve editor (only if gradient mode is active)
					if (shiftKey && ar.gradientMode) {
						openGradientCurveEditor(clickedAttractorIndex);
						return;
					}
					
					// Regular double-click: cycle gradient mode
					// Cycle: null -> 'forward' -> 'backward' -> null
					if (ar.gradientMode === null) {
						ar.gradientMode = 'forward';
						toast("Gradient mode: Forward", 1500);
					} else if (ar.gradientMode === 'forward') {
						ar.gradientMode = 'backward';
						toast("Gradient mode: Backward", 1500);
					} else {
						ar.gradientMode = null;
						toast("Gradient mode: Off", 1500);
					}
					history.push({ type: "attractorRepulsor" });
					return; // Don't process chain conversion
				}

				// Find which chain was clicked
				const hits = [];
				for (let i = 0; i < chains.length; i++) {
					const chainObj = chains[i];
					if (!chainObj || !chainObj.chain) continue;
					const ch = chainObj.chain;
					if (ch.length < 2) continue;

					// For closed blobs, check if point is inside
					if (chainObj.isClosed && pointInPolygon(x, y, ch)) {
						hits.push(i);
					} else if (!chainObj.isClosed) {
						// For open lines, check if point is near the path (within 15px for easier clicking)
						let minDist = Infinity;
						for (let j = 0; j < ch.length - 1; j++) {
							const p1 = ch[j];
							const p2 = ch[j + 1];
							const dx = p2.x - p1.x;
							const dy = p2.y - p1.y;
							const lenSq = dx * dx + dy * dy;

							if (lenSq < 1e-8) {
								// Degenerate segment, use point distance
								const dist = Math.hypot(x - p1.x, y - p1.y);
								minDist = Math.min(minDist, dist);
							} else {
								const t = Math.max(0, Math.min(1, ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq));
								const px = p1.x + t * dx;
								const py = p1.y + t * dy;
								const dist = Math.hypot(x - px, y - py);
								minDist = Math.min(minDist, dist);
							}
						}
						if (minDist < 15) {
							hits.push(i);
						}
					}
				}

				if (hits.length > 0) {
					// Pick the smallest chain (most specific)
					let bestIndex = hits[0];
					let bestArea = polygonArea(chains[bestIndex].chain);

					for (let k = 1; k < hits.length; k++) {
						const idx = hits[k];
						const area = polygonArea(chains[idx].chain);
						if (area < bestArea) {
							bestArea = area;
							bestIndex = idx;
						}
					}

					// Store the chain index and show dialog
					chainToConvertIndex = bestIndex;
					const backdrop = $("attractorRepulsorBackdrop");
					if (backdrop) {
						backdrop.style.display = "flex";
						toast("Choose Attractor or Repulsor", 2000);
					} else {
						toast("Error: Dialog not found", 2000);
					}
				}
			}
			
			// Mouse double-click handler
			canvas.addEventListener("dblclick", (e) => {
				const { x, y } = getCanvasXY(e);
				handleDoubleTapConversion(x, y, e.shiftKey);
			});
			canvas.addEventListener("lostpointercapture", () => {
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
				activePointerId = null;
				deleteLassoActive = false;
				deleteLassoPath = [];
				freezeLassoActive = false;
				freezeLassoPath = [];
			});

			/* ── Single-click delete (original behavior) ── */
			function performSingleDelete(x, y) {
				SFX.deleteSound();
				// a) delete attractors/repulsors first
				const AR_SEG_TOL = 6;
				for (let i = 0; i < attractorsRepulsors.length; i++) {
					const ar = attractorsRepulsors[i];
					for (let j = 0; j < ar.path.length - 1; j++) {
						const p1 = ar.path[j];
						const p2 = ar.path[j + 1];
						const denom = (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 || 1;
						const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / denom;
						const clamped = Math.max(0, Math.min(1, t));
						const px = p1.x + clamped * (p2.x - p1.x);
						const py = p1.y + clamped * (p2.y - p1.y);
						if (Math.hypot(x - px, y - py) < AR_SEG_TOL) {
							attractorsRepulsors.splice(i, 1);
							history.push({ type: "attractorRepulsor" });
							return;
						}
					}
				}
				// b) delete circles
				for (let i = 0; i < circles.length; i++) {
					const c = circles[i];
					if (Math.hypot(x - c.x, y - c.y) < c.radius) {
						circles.splice(i, 1);
						history.push({ type: "circle" });
						return;
					}
				}
				// c) delete open lines if near a segment
				const SEG_TOL = 6;
				for (let k = 0; k < chains.length; k++) {
					const obj = chains[k];
					if (obj.isClosed) continue;
					const pts = obj.chain;
					for (let i = 0; i < pts.length - 1; i++) {
						const a = pts[i], b = pts[i + 1];
						const denom = (b.x - a.x) ** 2 + (b.y - a.y) ** 2 || 1;
						const t = ((x - a.x) * (b.x - a.x) + (y - a.y) * (b.y - a.y)) / denom;
						const clamped = Math.max(0, Math.min(1, t));
						const px = a.x + clamped * (b.x - a.x);
						const py = a.y + clamped * (b.y - a.y);
						if (Math.hypot(x - px, y - py) < SEG_TOL) {
							chains.splice(k, 1);
							splineCache.clear();
							spatialHashCache.needsRebuild = true;
							_gpuTexturesDirty = true;
							history.push({ type: "chain" });
							return;
						}
					}
				}
				// d) delete the smallest closed blob under the point
				const hits = [];
				for (let i = 0; i < chains.length; i++) {
					const ch = chains[i];
					if (!ch.isClosed) continue;
					if (pointInPolygon(x, y, ch.chain)) hits.push(i);
				}
				if (hits.length) {
					let best = hits[0], bestArea = polygonArea(chains[best].chain);
					for (let j = 1; j < hits.length; j++) {
						const idx = hits[j];
						const area = polygonArea(chains[idx].chain);
						if (area < bestArea) { best = idx; bestArea = area; }
					}
					chains.splice(best, 1);
					splineCache.clear();
					spatialHashCache.needsRebuild = true;
					_gpuTexturesDirty = true;
					history.push({ type: "chain" });
				}
			}

			/* ── Lasso delete: remove everything whose center/body is within the lasso ── */
			function performLassoDelete(lasso) {
				if (lasso.length < 3) return;
				SFX.deleteSound();
				let deletedAny = false;

				// Delete attractors/repulsors whose any path point is inside the lasso
				for (let i = attractorsRepulsors.length - 1; i >= 0; i--) {
					const ar = attractorsRepulsors[i];
					const inside = ar.path.some(p => pointInPolygon(p.x, p.y, lasso));
					if (inside) {
						attractorsRepulsors.splice(i, 1);
						deletedAny = true;
					}
				}

				// Delete circles whose center is inside the lasso
				for (let i = circles.length - 1; i >= 0; i--) {
					const c = circles[i];
					if (pointInPolygon(c.x, c.y, lasso)) {
						circles.splice(i, 1);
						deletedAny = true;
					}
				}

				// Delete chains (blobs, lines, particles) if any vertex is inside the lasso
				for (let k = chains.length - 1; k >= 0; k--) {
					const obj = chains[k];
					const inside = obj.chain.some(p => pointInPolygon(p.x, p.y, lasso));
					if (inside) {
						chains.splice(k, 1);
						deletedAny = true;
					}
				}

				if (deletedAny) {
					splineCache.clear();
					spatialHashCache.needsRebuild = true;
					_gpuTexturesDirty = true;
					history.push({ type: "chain" });
					toast("Deleted selected objects", 1500);
				}
			}

			/* ── Single-click freeze (original behavior) ── */
			function performSingleFreeze(x, y) {
				const hits = [];
				for (let i = 0; i < chains.length; i++) {
					const ch = chains[i];
					if (!ch.isClosed) continue;
					if (pointInPolygon(x, y, ch.chain)) hits.push(i);
				}
				if (hits.length) {
					let bestIndex = hits[0];
					let bestArea = polygonArea(chains[bestIndex].chain);
					for (let k = 1; k < hits.length; k++) {
						const idx = hits[k];
						const area = polygonArea(chains[idx].chain);
						if (area < bestArea) { bestIndex = idx; bestArea = area; }
					}
					const obj = chains[bestIndex];
					obj.frozen = !obj.frozen;
					obj.alpha = obj.frozen ? 0.3 : 1.0;
					SFX.freeze();
				}
			}

			/* ── Lasso freeze: toggle frozen for everything inside the lasso ── */
			function performLassoFreeze(lasso) {
				if (lasso.length < 3) return;
				SFX.freeze();
				let count = 0;

				for (let k = 0; k < chains.length; k++) {
					const obj = chains[k];
					let inside = false;
					if (obj.isClosed) {
						let sx = 0, sy = 0;
						for (const p of obj.chain) { sx += p.x; sy += p.y; }
						const centX = sx / obj.chain.length;
						const centY = sy / obj.chain.length;
						inside = pointInPolygon(centX, centY, lasso);
					} else {
						inside = obj.chain.some(p => pointInPolygon(p.x, p.y, lasso));
					}
					if (inside) {
						obj.frozen = !obj.frozen;
						obj.alpha = obj.frozen ? 0.3 : 1.0;
						count++;
					}
				}
				if (count > 0) {
					toast(`Toggled freeze on ${count} object${count > 1 ? 's' : ''}`, 1500);
				}
			}

			/* ── Draw lasso selection overlay ── */
			function drawEditLassoSelect() {
				if (isPresentationMode) return;
				if (filmstripData.isExporting) return;

				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

				// Delete lasso
				if (deleteMode && deleteLassoActive && deleteLassoPath.length >= 2) {
					const n = deleteLassoPath.length;
					const verts = new Float32Array(n * 2);
					for (let i = 0; i < n; i++) {
						verts[i * 2] = deleteLassoPath[i].x;
						verts[i * 2 + 1] = deleteLassoPath[i].y;
					}
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform4fv(lineColorLoc, [1.0, 0.2, 0.2, 0.85]);
					gl.drawArrays(gl.LINE_LOOP, 0, n);

					if (n >= 3) {
						let cx = 0, cy = 0;
						for (const p of deleteLassoPath) { cx += p.x; cy += p.y; }
						cx /= n; cy /= n;
						const fillVerts = new Float32Array((n + 2) * 2);
						fillVerts[0] = cx; fillVerts[1] = cy;
						for (let i = 0; i < n; i++) {
							fillVerts[(i + 1) * 2] = deleteLassoPath[i].x;
							fillVerts[(i + 1) * 2 + 1] = deleteLassoPath[i].y;
						}
						fillVerts[(n + 1) * 2] = deleteLassoPath[0].x;
						fillVerts[(n + 1) * 2 + 1] = deleteLassoPath[0].y;
						gl.bufferData(gl.ARRAY_BUFFER, fillVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.clear(gl.STENCIL_BUFFER_BIT);
						gl.enable(gl.STENCIL_TEST);
						gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
						gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
						gl.colorMask(false, false, false, false);
						gl.drawArrays(gl.TRIANGLE_FAN, 0, n + 2);
						gl.colorMask(true, true, true, true);
						gl.stencilFunc(gl.EQUAL, 1, 0xFF);
						gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
						const delQuad = new Float32Array([0,0, canvas.width,0, 0,canvas.height, canvas.width,canvas.height]);
						gl.bufferData(gl.ARRAY_BUFFER, delQuad, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.uniform4fv(lineColorLoc, [1.0, 0.1, 0.1, 0.12]);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
						gl.disable(gl.STENCIL_TEST);
					}
				}

				// Freeze lasso
				if (freezeMode && freezeLassoActive && freezeLassoPath.length >= 2) {
					const n = freezeLassoPath.length;
					const verts = new Float32Array(n * 2);
					for (let i = 0; i < n; i++) {
						verts[i * 2] = freezeLassoPath[i].x;
						verts[i * 2 + 1] = freezeLassoPath[i].y;
					}
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform4fv(lineColorLoc, [0.3, 0.7, 1.0, 0.85]);
					gl.drawArrays(gl.LINE_LOOP, 0, n);

					if (n >= 3) {
						let cx = 0, cy = 0;
						for (const p of freezeLassoPath) { cx += p.x; cy += p.y; }
						cx /= n; cy /= n;
						const fillVerts = new Float32Array((n + 2) * 2);
						fillVerts[0] = cx; fillVerts[1] = cy;
						for (let i = 0; i < n; i++) {
							fillVerts[(i + 1) * 2] = freezeLassoPath[i].x;
							fillVerts[(i + 1) * 2 + 1] = freezeLassoPath[i].y;
						}
						fillVerts[(n + 1) * 2] = freezeLassoPath[0].x;
						fillVerts[(n + 1) * 2 + 1] = freezeLassoPath[0].y;
						gl.bufferData(gl.ARRAY_BUFFER, fillVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.clear(gl.STENCIL_BUFFER_BIT);
						gl.enable(gl.STENCIL_TEST);
						gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
						gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
						gl.colorMask(false, false, false, false);
						gl.drawArrays(gl.TRIANGLE_FAN, 0, n + 2);
						gl.colorMask(true, true, true, true);
						gl.stencilFunc(gl.EQUAL, 1, 0xFF);
						gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
						const frzQuad = new Float32Array([0,0, canvas.width,0, 0,canvas.height, canvas.width,canvas.height]);
						gl.bufferData(gl.ARRAY_BUFFER, frzQuad, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.uniform4fv(lineColorLoc, [0.2, 0.5, 1.0, 0.12]);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
						gl.disable(gl.STENCIL_TEST);
					}
				}
			}

			/* ───────── Device/layout toggler ───────── */
			const rootWindow = document.querySelector(".window");
			const contentEl = document.querySelector(".content");
			const toolbarEl = document.querySelector(".toolbar");
			const bottomEl = document.querySelector(".bottom-panel");

			/* robust iPad detection (covers iPadOS reporting as Mac) */
			function isIPad() {
				const ua = navigator.userAgent || "";
				const platform = navigator.platform || "";
				const touch = navigator.maxTouchPoints || 0;
				return /iPad/.test(ua) || (platform === "MacIntel" && touch > 1);
			}
			// PERFORMANCE: Cache iPad detection result at startup (avoids regex per frame)
			const _isIPad = isIPad();
			// PERFORMANCE: Reduce spline subdivision on iPad (fewer vertices = faster GPU + less CPU)
			const _splineSeg = _isIPad ? 6 : 10;

			/* iPad panels are now fixed position, no DOM manipulation needed */
			let toolbarHomeParent = toolbarEl.parentElement;
			let toolbarHomeNext = toolbarEl.nextSibling;

			function adoptIPadDOM() {
				// Panels are fixed position on iPad, no DOM changes needed
				// But ensure they're in the window for proper z-index stacking
				if (toolbarEl.parentElement !== rootWindow) {
					rootWindow.appendChild(toolbarEl);
				}
				if (bottomEl.parentElement !== rootWindow) {
					rootWindow.appendChild(bottomEl);
				}
			}

			function restoreDesktopDOM() {
				// Restore original desktop layout
				if (toolbarHomeNext && toolbarHomeNext.parentNode === toolbarHomeParent) {
					toolbarHomeParent.insertBefore(toolbarEl, toolbarHomeNext);
				} else if (toolbarHomeParent) {
					toolbarHomeParent.appendChild(toolbarEl);
				}
			}

			/* Full-screen canvas for iPad - fills entire screen, panel overlays */
			function fitCanvasForIPad() {
				const titleBarHeight = 44;
				// Canvas fills entire screen width and height (panel overlays on top)
				const fullWidth = window.innerWidth;
				const fullHeight = window.innerHeight - titleBarHeight;

			// Fill entire screen
			// PERFORMANCE: Force devicePixelRatio to 1 on iPad to avoid retina resolution overhead
			// On retina displays, devicePixelRatio is 2 or 3, which means the browser renders
			// the canvas at 2x/3x resolution internally. By dividing canvas dimensions by
			// devicePixelRatio, we force it to render at 1x resolution (native logical pixels).
			const isIPadDevice = /iPad/i.test(navigator.userAgent) ||
				(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

			// Force device pixel ratio to 1 for iPad (ignore retina scaling)
			// Divide canvas dimensions by devicePixelRatio to get 1x rendering resolution
			const actualDPR = window.devicePixelRatio || 1.0;
			const dpr = isIPadDevice ? 1.0 : actualDPR;
			const resolutionScale = 1.0; // No additional downscaling - devicePixelRatio handling is enough

			// Set CSS size to full screen (visual size)
			canvas.style.width = fullWidth + "px";
			canvas.style.height = fullHeight + "px";

			// Set internal canvas resolution: divide by devicePixelRatio to force 1x rendering
			// This prevents the browser from rendering at 2x/3x resolution on retina displays
			// The CSS size stays the same, so it displays correctly, but renders at lower resolution
			canvas.width = Math.floor(fullWidth * resolutionScale / dpr);
			canvas.height = Math.floor(fullHeight * resolutionScale / dpr);

			if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
			}

			/* master switch */
			function applyResponsiveLayout() {
				if (_isIPad) {
					rootWindow.classList.add("ipad");
					adoptIPadDOM();
					document.documentElement.style.overflow = "hidden";
					document.body.style.overflow = "hidden";
					fitCanvasForIPad();
				} else {
					rootWindow.classList.remove("ipad");
					restoreDesktopDOM();
					document.documentElement.style.overflow = "";
					document.body.style.overflow = "";
				}
			}

			applyResponsiveLayout();
			$("splashOverlay").style.display = "flex"; // ← show splash on load
			window.addEventListener("resize", applyResponsiveLayout);
			window.addEventListener("orientationchange", applyResponsiveLayout);

			/* ───────── iPad Panel Toggle Functionality ───────── */
			const toggleToolbarBtn = $("toggleToolbar");
			const toggleSlidersBtn = $("toggleSliders");
			const toolbarPanel = toolbarEl;
			const bottomPanel = bottomEl;

			function setupPanelToggles() {
				if (!rootWindow.classList.contains("ipad")) {
					// Hide toggle buttons on desktop
					if (toggleToolbarBtn) toggleToolbarBtn.style.display = "none";
					if (toggleSlidersBtn) toggleSlidersBtn.style.display = "none";
					return;
				}

				// Show toggle buttons on iPad
				if (toggleToolbarBtn) toggleToolbarBtn.style.display = "flex";
				if (toggleSlidersBtn) toggleSlidersBtn.style.display = "flex";

				// Open toolbar panel by default on iPad
				if (toolbarPanel) {
					toolbarPanel.classList.add("panel-visible");
				}
				if (toggleToolbarBtn) {
					toggleToolbarBtn.classList.add("panel-visible");
					// Set initial button position
					const panelWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--panel-left-width')) || 60;
					toggleToolbarBtn.style.left = `calc(${panelWidth}px + var(--gap-2))`;
				}

				// Open bottom panel by default on iPad
				if (bottomPanel) {
					bottomPanel.classList.add("panel-visible");
				}
				if (toggleSlidersBtn) {
					toggleSlidersBtn.classList.add("panel-visible");
				}

				// Toolbar toggle
				if (toggleToolbarBtn && toolbarPanel) {
					toggleToolbarBtn.onclick = (e) => {
						e.stopPropagation();
						toolbarPanel.classList.toggle("panel-visible");
						toggleToolbarBtn.classList.toggle("panel-visible");

						// Update button position based on panel state
						const panelWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--panel-left-width')) || 60;
						if (toolbarPanel.classList.contains("panel-visible")) {
							toggleToolbarBtn.style.left = `calc(${panelWidth}px + var(--gap-2))`;
						} else {
							toggleToolbarBtn.style.left = "var(--gap-2)";
						}

						// Canvas size stays constant - no need to resize
					};
				}

				// Sliders toggle
				if (toggleSlidersBtn && bottomPanel) {
					toggleSlidersBtn.onclick = (e) => {
						e.stopPropagation();
						bottomPanel.classList.toggle("panel-visible");
						toggleSlidersBtn.classList.toggle("panel-visible");
					};
				}

				// Panels stay open when drawing - only toggle via buttons
			}

			// Setup toggles after layout is applied
			setTimeout(setupPanelToggles, 100);
			window.addEventListener("resize", () => {
				setTimeout(setupPanelToggles, 100);
			});

			/* -----------------------------------
			   GLOBALS & DATA
			----------------------------------- */

			/* 1. Canvas draw-mode */
			let drawMode = 'blob'; // 'blob' | 'line' | 'circle' | 'attractor' | 'repulsor' | 'particle'
			let attractorRepulsorType = null; // 'attractor' | 'repulsor' | null

			/* Particle emitter settings */
			let particleEmitRate = 10;       // particles per second
			let particleRenderSize = 4;      // render radius in px
			let particleEmitting = false;    // true while mouse held in particle mode
			let particleEmitTimer = null;    // interval timer for emission

			/* 2. Geometry collections */
			const chains = []; // { chain:[…], color, baseDotRadius, isClosed, frozen }
			const attractorsRepulsors = []; // { path: [{x, y}], type: 'attractor' | 'repulsor' }

			// PERFORMANCE: Cache splines to avoid recalculating when blobs haven't moved
			const splineCache = new Map(); // chainIndex -> { spline, hash }
			const spatialHashCache = { needsRebuild: true }; // Track if spatial hash needs rebuilding

			// PERFORMANCE: Reusable data structures to avoid per-frame allocations
			const _selfRepulsionMap = new Map(); // Reused in simulateChain self-repulsion
			// Forward-only neighbor offsets: each cell-pair visited exactly once (no Set needed)
			const _selfFwdOffsets = [[1, 0], [0, 1], [1, 1], [-1, 1]];
			// Pre-allocated fill quad (updated in-place, avoids new Float32Array per frame)
			const _fillQuad = new Float32Array(12);
			// PERFORMANCE: Pre-allocated color arrays to avoid per-frame allocation
			const _blackColor = new Float32Array([0, 0, 0, 1.0]);
			const _rgbaScratch = new Float32Array(4); // reusable RGBA scratch for drawChain
			// Grid cache
			let _gridVerts = null;
			let _gridCacheSize = -1;
			let _gridCacheW = -1;
			let _gridCacheH = -1;
			// Particle batch collection (reused each frame)
			let _particleBatch = [];
			// Spatial hash point object pool
			let _shPool = [];
			let _shPoolIdx = 0;
			// GPU texture rebuild flag — set when chains change
			let _gpuTexturesDirty = true;
			let _lastChainCount = 0;

			// GPU Physics system (WebGL 2.0 only)
			const gpuPhysics = {
				initialized: false,
				positionTextures: [null, null], // Ping-pong textures for positions
				velocityTextures: [null, null], // Ping-pong textures for velocities
				metadataTexture: null, // Texture storing chain metadata (chainIdx, vertIdx, prevIdx, nextIdx)
				forceTexture: null, // Temporary texture for force calculations
				physicsProgram: null, // Shader program for physics
				updateProgram: null, // Shader program for position updates
				renderProgram: null, // Shader program for GPU-based rendering
				framebuffers: [null, null], // Framebuffers for ping-pong
				vertexMapping: [], // Maps chainIndex.vertexIndex -> texture coordinate
				chainStartIndices: [], // Maps chainIndex -> starting texture index
				totalVertices: 0,
				textureWidth: 0,
				textureHeight: 0,
				currentBuffer: 0, // Which ping-pong buffer is current (0 or 1)
				quadBuffer: null, // Full-screen quad for rendering
				splineBuffer: null, // Buffer for spline rendering
				needsSync: false, // Flag to sync GPU->CPU when needed
				uniformLocations: {}, // Cached uniform locations
				attribLocations: {}, // Cached attribute locations
				renderUniformLocations: {}, // Cached render shader uniform locations
				renderAttribLocations: {} // Cached render shader attribute locations
			};

			// Initialize GPU physics if WebGL 2.0 is available
			if (useGPUPhysics) {
				initGPUPhysics();
			}

			// Generate a simple hash of chain positions for cache invalidation
			function getChainPositionHash(chainObj) {
				if (!chainObj.chain || chainObj.chain.length === 0) return 0;
				// Sample a few points to create a fast hash
				let hash = 0;
				const sampleCount = Math.min(chainObj.chain.length, 10);
				const step = Math.floor(chainObj.chain.length / sampleCount);
				for (let i = 0; i < chainObj.chain.length; i += step) {
					const p = chainObj.chain[i];
					hash = ((hash << 5) - hash) + (p.x * 1000 | 0);
					hash = ((hash << 5) - hash) + (p.y * 1000 | 0);
				}
				return hash;
			}
			const circles = []; // { x, y, radius }
			let history = []; // undo stack

			/* 3. Live drawing state */
			let isDrawing = false;
			let shiftKeyHeld = false; // Track shift key for straight line drawing
			let straightLineStart = null; // Start point for straight line when shift is held
			let isCircleDrawing = false;
			let currentCircle = null;
			let draggingCircleIndex = null;
			// ── Circle long-press/resize state ─────────────────────────────
			let resizeHoldMs = 1000; // 5 seconds to enter resize mode
			let longPressTimer = null; // pending timer id
			let longPressStartX = 0,
				longPressStartY = 0;
			let longPressTargetIndex = null; // which circle we’re aiming to resize
			let resizingCircleIndex = null; // active circle being resized
			const LONG_PRESS_MOVE_CANCEL = 6; // px tolerance before we cancel press

			// ── Lasso state for delete and freeze tools ─────────────────────
			let deleteLassoActive = false;      // true when drawing a lasso in delete mode
			let deleteLassoPath = [];           // [{x,y}, ...] freeform path
			let freezeLassoActive = false;      // true when drawing a lasso in freeze mode
			let freezeLassoPath = [];           // [{x,y}, ...] freeform path
			// While we’re waiting to see if this becomes a long-press
			let waitingForLongPress = false;
			/* 4. Active edit-tool flags (mutually exclusive) */
			let slicingMode = false,
				dragMode = false,
				pinMode = false,
				freezeMode = false,
				deleteMode = false;

			/* 5. Drag / hover helpers */
			let draggingChainIndex = null,
				draggingDotIndex = null;
			let pinHoverChainIndex = null,
				pinHoverDotIndex = null;

			/* 6. Render options */
			let showOutline = true; // Show outline/stroke
			let showFilled = true; // Show filled area
			let outlineWidth = 4; // Width of outline/border
			let canvasBackgroundColor = [0.75, 0.80, 0.67, 1.0]; // Canvas background color [r, g, b, a]
			let showGrid = true; // Show grid on canvas

			// Dynamic text color based on canvas background darkness
			function updateTextColorsForBackground() {
				// Calculate perceived luminance (0 = black, 1 = white)
				const r = canvasBackgroundColor[0];
				const g = canvasBackgroundColor[1];
				const b = canvasBackgroundColor[2];
				const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
				
				// If background is dark (luminance below threshold), use light text
				const isDark = luminance < 0.45;
				const textColor = isDark ? '#e0e0e0' : '';
				const mutedColor = isDark ? '#b0b0b0' : '';
				
				// Toggle body class so CSS can restyle slider tracks
				document.body.classList.toggle('dark-canvas', isDark);
				
				// Only apply text color changes on iPad — desktop panels keep fixed colors
				const isIPad = document.querySelector('.window.ipad');
				if (!isIPad) return;
				
				// Update slider labels
				document.querySelectorAll('#sliders label').forEach(label => {
					label.style.color = isDark ? mutedColor : '';
				});
				
				// Update shape settings labels
				document.querySelectorAll('.shape-settings label').forEach(label => {
					label.style.color = isDark ? textColor : '';
				});
				
				// Update toolbar section headers
				document.querySelectorAll('.toolbar-section h4').forEach(h4 => {
					h4.style.color = isDark ? mutedColor : '';
				});
			}

			// Traveling segment mode
			let travelingSegmentEnabled = false; // Enable traveling segment mode
			let travelingSegmentLength = 50; // Length of the visible segment in pixels
			let travelingSegmentSpeed = 100; // Speed of travel (pixels per second)
			let travelingSegmentNormalizedPosition = {}; // Store normalized position (0-1) per chain to avoid flickering
			let travelingSegmentLastTime = performance.now(); // Last frame time for delta calculation

			/* 7. Physics parameters (defaults) */
			let springConstant = 0.3, // ~30 %
				repulsionConstant = 0.09, // ~10 %
				damping = 0.85, // ~85 %
				timeStep = 1.05, // slider 47 % → 0.1‒2
				dotScaleFactor = 2.0, // slider 39 % → 0.1‒5
				currentLineThickness = 4; // Default to thicker lines

			let prevDamping = damping; // remembers last non-zero value

			/* 8. Noise movement state */
			let noiseActive = false;
			let noiseTime = 0;
			let noiseRampTime = 0; // Time for ramping oscillation

			/* 9. Global shape settings */
			let globalRadiusAvg = 5,
				globalRadiusVar = 0;

				let turgorPressure = 0.0; // 0..1 — 0 = no inflation, 1 = max

			// --- Gravity Mode ---
			let gravityEnabled = false;
			// Pixels per second^2; feels good across your current timestep range
			let gravityAccel = 15;

			/* 9. UI element references */
			const colorInput = $("blobColor");
			const DOT_SCROLL_STEP = 0.01; // lower = finer control
			const DOT_MIN_PERCENT = 0;
			const DOT_MAX_PERCENT = 100;
			/* -----------------------------------b
			   ICON "ON" LABEL HELPER
			----------------------------------- */
			function toggleActiveIcon(iconEl, isActive) {
				iconEl.classList.toggle("icon-active", isActive);
			}


			// A helper to apply the “active” styling to edit-tool icons
			function setIconActive(iconEl, isActive, activeTitle, inactiveTitle) {
				iconEl.title = isActive ? activeTitle : inactiveTitle;
				iconEl.style.backgroundColor = isActive ? "#D3D3D3" : "";
				iconEl.style.fontWeight = isActive ? "bold" : "normal";
				iconEl.classList.toggle("icon-active", isActive);
			}

			function pickCircleIndex(x, y, pad = 5) {
			  // iterate backwards so “topmost / newest” circle wins
			  for (let i = circles.length - 1; i >= 0; i--) {
			    const c = circles[i];
			    if (Math.hypot(x - c.x, y - c.y) <= c.radius + pad) return i;
			  }
			  return null;
			}


			// Ensure only one edit tool is active at a time
			function setEditTool(toolName, opts = {}) {
			  const forceOn = !!opts.forceOn;

			  const isAlreadyActive = !forceOn && (
			    (toolName === "slice"  && slicingMode) ||
			    (toolName === "drag"   && dragMode)    ||
			    (toolName === "pin"    && pinMode)     ||
			    (toolName === "freeze" && freezeMode)  ||
			    (toolName === "delete" && deleteMode)
			  );

			  // Turn everything off first
			  slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;

			  // Turn the requested tool on (unless user toggled it off)
			  if (forceOn || !isAlreadyActive) {
			    if (toolName === "slice")  slicingMode = true;
			    if (toolName === "drag")   dragMode = true;
			    if (toolName === "pin")    pinMode = true;
			    if (toolName === "freeze") freezeMode = true;
			    if (toolName === "delete") deleteMode = true;
			  }

			  // ✅ If no draw mode is active, we ALWAYS fall back to drag
			  const anyEditOn = slicingMode || dragMode || pinMode || freezeMode || deleteMode;

				if (anyEditOn) {
  // ✅ If any edit tool is active, drawing must be OFF
  clearDrawModeUIOnly();
}
			  if (!anyEditOn && drawMode === "none") {
			    dragMode = true;
			  }

			  // UI updates (same as your existing code)
			  const editFrame = $("editToolsSection");
			  editFrame.classList.toggle("edit-on", slicingMode || dragMode || pinMode || freezeMode || deleteMode);

			  setIconActive($("iconSlice"),  slicingMode, "Slicing Mode (On)", "Slicing Mode (Off)");
			  setIconActive($("iconDrag"),   dragMode,    "Disable Drag Mode", "Enable Drag Mode");
			  setIconActive($("iconPin"),    pinMode,     "Disable Pin Mode",  "Enable Pin Mode");
			  setIconActive($("iconFreeze"), freezeMode,  "Disable Freeze Mode","Enable Freeze Mode");
			  setIconActive($("iconDelete"), deleteMode,  "Disable Delete Mode","Enable Delete Mode");

			  updateCanvasCursor();

			  const msg =
			    forceOn ? "Drag mode" :
			    (isAlreadyActive ? "Edit tools off" : `Edit mode: ${toolName.toUpperCase()}`);

			  toast(msg, 1800);
			}


			/* -----------------------------------
			   DRAW MODE: BLOB / LINE / CIRCLE
			----------------------------------- */
			function clearAllEditToolsUIOnly() {
			  const editFrame = $("editToolsSection");
			  editFrame.classList.remove("edit-on");
			  setIconActive($("iconSlice"),  false, "Slicing Mode (On)", "Slicing Mode (Off)");
			  setIconActive($("iconDrag"),   false, "Disable Drag Mode", "Enable Drag Mode");
			  setIconActive($("iconPin"),    false, "Disable Pin Mode",  "Enable Pin Mode");
			  setIconActive($("iconFreeze"), false, "Disable Freeze Mode","Enable Freeze Mode");
			  setIconActive($("iconDelete"), false, "Disable Delete Mode","Enable Delete Mode");
			}

			function clearDrawModeUIOnly() {
			  drawMode = "none";
			  toggleActiveIcon($("iconBlob"), false);
			  toggleActiveIcon($("iconLine"), false);
			  toggleActiveIcon($("iconCircle"), false);
			  toggleActiveIcon($("iconParticle"), false);
			  toggleActiveIcon($("iconAttractorRepulsor"), false);
			}


			function setDrawMode(mode) {
			  // Toggle: clicking the same draw mode turns drawing OFF
			  drawMode = (drawMode === mode) ? "none" : mode;

			  toggleActiveIcon($("iconBlob"),   drawMode === "blob");
			  toggleActiveIcon($("iconLine"),   drawMode === "line");
			  toggleActiveIcon($("iconCircle"), drawMode === "circle");
			  toggleActiveIcon($("iconParticle"), drawMode === "particle");
			  toggleActiveIcon($("iconAttractorRepulsor"), drawMode === "attractor" || drawMode === "repulsor");

			  if (drawMode === "none") {
			    // ✅ When draw is off, drag becomes the default interaction
			    setEditTool("drag", { forceOn: true });
			    toast("Draw: OFF (Drag)", 1600);
			  } else {
			    // Entering a draw mode: turn off edit tools to avoid blocking drawing
			    slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;
			    clearAllEditToolsUIOnly();
			    toast(`Draw mode: ${drawMode.toUpperCase()}`, 1600);
			  }

			  updateCanvasCursor();
			}

			// Initialize default draw mode
			setDrawMode("none");
			setDrawMode("blob");
			/* -----------------------------------
			   EDIT TOOL ICONS (now calling setEditTool)
			----------------------------------- */
			$("iconSlice").onclick = function() {
				setEditTool("slice");
			};
			$("iconDrag").onclick = function() {
				setEditTool("drag");
			};
			$("iconPin").onclick = function() {
				setEditTool("pin");
			};
			$("iconFreeze").onclick = function() {
				setEditTool("freeze");
			};
			$("iconDelete").onclick = function() {
				setEditTool("delete");
			};

			/* -----------------------------------
			   APPEARANCE DIALOG
			----------------------------------- */
			$("iconAppearance").onclick = () => {
				// Initialize dialog with current values
				$("appearanceOutline").checked = showOutline;
				$("appearanceFilled").checked = showFilled;
				$("appearanceOutlineWidth").value = outlineWidth;
				$("appearanceOutlineWidthValue").textContent = outlineWidth;

				// Show/hide outline width based on outline checkbox
				$("appearanceOutlineWidthGroup").style.display = showOutline ? "block" : "none";

				// Traveling segment settings
				$("appearanceTravelingSegment").checked = travelingSegmentEnabled;
				$("appearanceTravelingSegmentLength").value = travelingSegmentLength;
				$("appearanceTravelingSegmentLengthValue").textContent = travelingSegmentLength;
				$("appearanceTravelingSegmentSpeed").value = travelingSegmentSpeed;
				$("appearanceTravelingSegmentSpeedValue").textContent = travelingSegmentSpeed;
				$("appearanceTravelingSegmentControls").style.display = travelingSegmentEnabled ? "block" : "none";

				// Canvas settings
				const bgColor = canvasBackgroundColor;
				const hexColor = "#" + [Math.round(bgColor[0] * 255), Math.round(bgColor[1] * 255), Math.round(bgColor[2] * 255)]
					.map(x => x.toString(16).padStart(2, '0')).join('');
				$("appearanceBackgroundColor").value = hexColor;
				$("appearanceShowGrid").checked = showGrid;

				updateAppearancePreview();
				$("appearanceBackdrop").style.display = "flex";
			};

			$("appearanceCancelBtn").onclick = () => {
				$("appearanceBackdrop").style.display = "none";
			};

			$("appearanceApplyBtn").onclick = () => {
				// Apply settings
				showOutline = $("appearanceOutline").checked;
				showFilled = $("appearanceFilled").checked;
				outlineWidth = parseInt($("appearanceOutlineWidth").value);

				// Update line thickness based on outline width
				currentLineThickness = outlineWidth;

				// Traveling segment settings
				travelingSegmentEnabled = $("appearanceTravelingSegment").checked;
				travelingSegmentLength = parseInt($("appearanceTravelingSegmentLength").value);
				travelingSegmentSpeed = parseInt($("appearanceTravelingSegmentSpeed").value);
				if (travelingSegmentEnabled) {
					travelingSegmentNormalizedPosition = {}; // Reset positions for all chains
					travelingSegmentLastTime = performance.now(); // Reset time tracking
				}

				// Canvas settings
				const hexColor = $("appearanceBackgroundColor").value;
				const r = parseInt(hexColor.slice(1, 3), 16) / 255;
				const g = parseInt(hexColor.slice(3, 5), 16) / 255;
				const b = parseInt(hexColor.slice(5, 7), 16) / 255;
				canvasBackgroundColor = [r, g, b, 1.0];
				showGrid = $("appearanceShowGrid").checked;

				// Update canvas background color
				gl.clearColor(canvasBackgroundColor[0], canvasBackgroundColor[1], canvasBackgroundColor[2], canvasBackgroundColor[3]);

				// Update text colors based on background darkness
				updateTextColorsForBackground();

				$("appearanceBackdrop").style.display = "none";
				toast("Appearance updated", 1600);
			};

			// Update preview when controls change
			$("appearanceFilled").addEventListener("change", updateAppearancePreview);
			$("appearanceOutline").addEventListener("change", () => {
				// Show/hide outline width based on outline checkbox
				$("appearanceOutlineWidthGroup").style.display = $("appearanceOutline").checked ? "block" : "none";
				updateAppearancePreview();
			});
			$("appearanceOutlineWidth").addEventListener("input", () => {
				$("appearanceOutlineWidthValue").textContent = $("appearanceOutlineWidth").value;
				updateAppearancePreview();
			});
			$("appearanceTravelingSegment").addEventListener("change", () => {
				const enabled = $("appearanceTravelingSegment").checked;
				$("appearanceTravelingSegmentControls").style.display = enabled ? "block" : "none";
				// Uncheck filled when traveling segment is enabled
				if (enabled) {
					$("appearanceFilled").checked = false;
				}
				updateAppearancePreview();
			});
			$("appearanceTravelingSegmentLength").addEventListener("input", () => {
				$("appearanceTravelingSegmentLengthValue").textContent = $("appearanceTravelingSegmentLength").value;
				updateAppearancePreview();
			});
			$("appearanceTravelingSegmentSpeed").addEventListener("input", () => {
				$("appearanceTravelingSegmentSpeedValue").textContent = $("appearanceTravelingSegmentSpeed").value;
				updateAppearancePreview();
			});
			$("appearanceBackgroundColor").addEventListener("input", updateAppearancePreview);
			$("appearanceShowGrid").addEventListener("change", updateAppearancePreview);

			// Preview rendering function
			function updateAppearancePreview() {
				const canvas = $("appearancePreviewCanvas");
				const ctx = canvas.getContext("2d");
				const width = canvas.width;
				const height = canvas.height;

				// Draw canvas background preview
				const hexColor = $("appearanceBackgroundColor").value;
				ctx.fillStyle = hexColor;
				ctx.fillRect(0, 0, width, height);

				// Draw grid if enabled
				if ($("appearanceShowGrid").checked) {
					ctx.strokeStyle = "rgba(115, 128, 115, 0.3)";
					ctx.lineWidth = 1;
					for (let i = 0; i <= width; i += 20) {
						ctx.beginPath();
						ctx.moveTo(i, 0);
						ctx.lineTo(i, height);
						ctx.stroke();
					}
					for (let i = 0; i <= height; i += 20) {
						ctx.beginPath();
						ctx.moveTo(0, i);
						ctx.lineTo(width, i);
						ctx.stroke();
					}
				}

				// Draw preview blob
				const centerX = width / 2;
				const centerY = height / 2;
				const radius = 60;
				const showOutlineCheck = $("appearanceOutline").checked;
				const showFilledCheck = $("appearanceFilled").checked;
				const outlineWidthVal = parseInt($("appearanceOutlineWidth").value);
				const travelingSegmentCheck = $("appearanceTravelingSegment").checked;
				const travelingSegmentLengthVal = parseInt($("appearanceTravelingSegmentLength").value);
				const travelingSegmentSpeedVal = parseInt($("appearanceTravelingSegmentSpeed").value);

				ctx.save();

				// Create blob path (simple rounded shape)
				const numPoints = 32; // More points for smoother preview
				const blobPoints = [];
				for (let i = 0; i < numPoints; i++) {
					const angle = (i / numPoints) * Math.PI * 2;
					const r = radius + Math.sin(angle * 3) * 15;
					const x = centerX + Math.cos(angle) * r;
					const y = centerY + Math.sin(angle) * r;
					blobPoints.push({x, y});
				}

				// Create spline array for preview
				const previewSpline = new Float32Array(numPoints * 2);
				for (let i = 0; i < numPoints; i++) {
					previewSpline[i * 2] = blobPoints[i].x;
					previewSpline[i * 2 + 1] = blobPoints[i].y;
				}

				// Draw filled area if enabled
				if (showFilledCheck) {
					ctx.beginPath();
					ctx.moveTo(blobPoints[0].x, blobPoints[0].y);
					for (let i = 1; i < blobPoints.length; i++) {
						ctx.lineTo(blobPoints[i].x, blobPoints[i].y);
					}
					ctx.closePath();
					ctx.fillStyle = "#0066ff";
					ctx.fill();
				}

				// Draw outline if enabled
				if (showOutlineCheck) {
					if (travelingSegmentCheck) {
						// Draw traveling segment (preview uses simple time-based approach)
						const currentTime = performance.now();
						if (!window.previewLastTime) window.previewLastTime = currentTime;
						const deltaTime = (currentTime - window.previewLastTime) / 1000;
						window.previewLastTime = currentTime;

						const totalLength = calculateSplineLength(previewSpline);
						if (!window.previewNormalizedPos) window.previewNormalizedPos = 0;

						if (totalLength > 0) {
							const distanceTraveled = deltaTime * travelingSegmentSpeedVal;
							const normalizedAdvance = distanceTraveled / totalLength;
							window.previewNormalizedPos = (window.previewNormalizedPos + normalizedAdvance) % 1.0;
						}

						const currentPosition = window.previewNormalizedPos * totalLength;
						const segment = extractTravelingSegment(previewSpline, currentPosition, travelingSegmentLengthVal);

						if (segment.length >= 4) {
							ctx.beginPath();
							ctx.moveTo(segment[0], segment[1]);
							for (let i = 2; i < segment.length; i += 2) {
								ctx.lineTo(segment[i], segment[i + 1]);
							}
							ctx.strokeStyle = showFilledCheck ? "#000" : "#0066ff";
							ctx.lineWidth = outlineWidthVal;
							ctx.setLineDash([]);
							ctx.stroke();
						}

						// Animate preview
						requestAnimationFrame(() => {
							if ($("appearanceBackdrop").style.display === "flex") {
								updateAppearancePreview();
							}
						});
					} else {
						// Draw full outline
						ctx.beginPath();
						ctx.moveTo(blobPoints[0].x, blobPoints[0].y);
						for (let i = 1; i < blobPoints.length; i++) {
							ctx.lineTo(blobPoints[i].x, blobPoints[i].y);
						}
						ctx.closePath();
						ctx.strokeStyle = showFilledCheck ? "#000" : "#0066ff";
						ctx.lineWidth = outlineWidthVal;
						ctx.setLineDash([]);
						ctx.stroke();
					}
				}

				ctx.restore();
			}

			/* -----------------------------------
			   UNDO & RESET
			----------------------------------- */

			$("iconUndo").onclick = () => {
				if (history.length > 0) {
					const last = history.pop();
					if (last.type === "chain") chains.pop();
					if (last.type === "circle") circles.pop();
					SFX.undo();
				}
				toast("Undo", 1200);
			};

			$("resetIcon").onclick = () => {
				if (confirm("Are you sure you want to clear the entire canvas?")) {
					chains.length = 0;
					circles.length = 0;
					attractorsRepulsors.length = 0;
					history.length = 0;
					splineCache.clear(); // PERFORMANCE: Clear cache when canvas cleared
					spatialHashCache.needsRebuild = true;
					SFX.reset();
				}
				toast("Canvas cleared", 1600);
			};

			/* -----------------------------------
			   FULLSCREEN MODE
			----------------------------------- */
			let isFullscreen = false;
			let originalCanvasWidth = canvas.width;
			let originalCanvasHeight = canvas.height;

			// Store original positions for restoration (persistent across fullscreen toggles)
			const panelOriginalPositions = new Map();

			// Store event handler references to allow removal
			let panelHideHandlers = {
				toolbar: null,
				bottomPanel: null,
				filmstrip: null
			};

			function toggleFullscreen() {
				isFullscreen = !isFullscreen;
				const body = document.body;
				const toolbar = document.querySelector(".toolbar");
				const bottomPanel = document.querySelector(".bottom-panel");
				const fullscreenIcon = $("fullscreenIcon");

				if (isFullscreen) {
					SFX.fullscreenEnter();
					// Enter fullscreen mode
					body.classList.add("fullscreen-mode");
					fullscreenIcon.classList.add("active");
					fullscreenIcon.textContent = "⛶"; // Fullscreen exit icon
					fullscreenIcon.title = "Exit Full Screen Mode";

					// Store original canvas size
					originalCanvasWidth = canvas.width;
					originalCanvasHeight = canvas.height;

					// Resize canvas to fill screen
					resizeCanvasToFullscreen();

					// Initialize panel dragging
					initPanelDragging();

					// Reset and minimize film strip panel by default when entering fullscreen
					const filmstripPanel = $("filmstripPanel");
					const hideFilmstripBtn = $("hideFilmstrip");
					if (filmstripPanel && hideFilmstripBtn) {
						// Clear any saved position from previous session
						panelOriginalPositions.delete(filmstripPanel);

						// First, ensure panel is not hidden (reset state from previous session)
						filmstripPanel.classList.remove("panel-hidden");
						hideFilmstripBtn.classList.remove("panel-restore");

						// Set position to top-right anchor point immediately
						filmstripPanel.style.left = "auto";
						filmstripPanel.style.top = "60px";
						filmstripPanel.style.right = "20px";
						filmstripPanel.style.bottom = "auto";
						filmstripPanel.style.transform = "none";

						// Add hidden class immediately (before panel is visible)
						// Use requestAnimationFrame to ensure DOM is ready
						requestAnimationFrame(() => {
							filmstripPanel.classList.add("panel-hidden");
							hideFilmstripBtn.textContent = "+";
							hideFilmstripBtn.title = "Show Film Strip Panel";
							hideFilmstripBtn.classList.add("panel-restore");
						});
					}

					// Initialize panel hide/show (after setting initial state)
					initPanelHideShow();

					toast("Fullscreen Mode ON", 1500);
				} else {
					SFX.fullscreenExit();
					// Exit fullscreen mode
					body.classList.remove("fullscreen-mode");
					fullscreenIcon.classList.remove("active");
					fullscreenIcon.textContent = "⛶";
					fullscreenIcon.title = "Full Screen Mode";

					// Restore panels if they were hidden
					const toolbar = document.querySelector(".toolbar");
					const bottomPanel = document.querySelector(".bottom-panel");
					const hideToolbarBtn = document.getElementById("hideToolbar");
					const hideBottomPanelBtn = document.getElementById("hideBottomPanel");

					if (toolbar && toolbar.classList.contains("panel-hidden")) {
						toolbar.classList.remove("panel-hidden");
						if (hideToolbarBtn) {
							hideToolbarBtn.textContent = "−";
							hideToolbarBtn.classList.remove("panel-restore");
						}
					}

					if (bottomPanel && bottomPanel.classList.contains("panel-hidden")) {
						bottomPanel.classList.remove("panel-hidden");
						if (hideBottomPanelBtn) {
							hideBottomPanelBtn.textContent = "−";
							hideBottomPanelBtn.classList.remove("panel-restore");
						}
					}

					// Restore original canvas size
					canvas.width = originalCanvasWidth;
					canvas.height = originalCanvasHeight;
					gl.viewport(0, 0, canvas.width, canvas.height);

					// Update canvas background color
					gl.clearColor(canvasBackgroundColor[0], canvasBackgroundColor[1], canvasBackgroundColor[2], canvasBackgroundColor[3]);

					// Don't rebuild GPU textures - they're independent of canvas size
					// The resolution uniform will be updated in simulateGPUPhysics()

					toast("Fullscreen Mode OFF", 1500);
				}
			}

			function resizeCanvasToFullscreen() {
				const width = window.innerWidth;
				const height = window.innerHeight - 48; // Subtract title bar height
				canvas.width = width;
				canvas.height = height;
				gl.viewport(0, 0, width, height);

				// Update canvas background color
				gl.clearColor(canvasBackgroundColor[0], canvasBackgroundColor[1], canvasBackgroundColor[2], canvasBackgroundColor[3]);

				// Don't rebuild GPU textures - they're independent of canvas size
				// The resolution uniform will be updated in simulateGPUPhysics()
			}

			// Handle window resize in fullscreen
			window.addEventListener("resize", () => {
				if (isFullscreen) {
					resizeCanvasToFullscreen();
					constrainPanelsToViewport();
				}
			});

			// Fullscreen icon click handler
			$("fullscreenIcon").onclick = toggleFullscreen;

			/* -----------------------------------
			   FILM STRIP TIMELINE
			----------------------------------- */
			const filmstripData = {
				frames: [], // Array of { imageData: string (dataURL), vectorData: object, timestamp: number }
				isPlaying: false,
				currentFrameIndex: 0,
				fps: 24,
				playbackInterval: null,
				scrollAnimation: null,
				captureArea: null, // { x, y, width, height } or null for full canvas
				crosshairsMode: false,
				isDraggingCaptureArea: false,
				captureAreaStart: null,
				captureAreaCurrent: null,
				isExporting: false, // Flag to hide bounding box during export
				previousCursor: null, // Store cursor state before crosshairs mode
				isRecording: false, // Flag for recording mode
				recordingInterval: null, // Interval for automatic frame capture
				recordingCadence: null, // Capture frequency in milliseconds
				recordingBlinkInterval: null, // Interval for blinking bounding box
				firstFrameOverlay: null, // Store first frame vector data for overlay during playback
				overlaySplinesCache: null, // Cached splines for overlay to avoid recalculating every frame
				overlayBuffer: null // Reusable buffer for overlay vertices
			};

			function captureFrame() {
				SFX.cameraShutter();
				// Wait for next frame to ensure canvas is fully rendered
				requestAnimationFrame(() => {
					// Determine capture area
					let captureX = 0, captureY = 0, captureWidth = canvas.width, captureHeight = canvas.height;

					if (filmstripData.captureArea) {
						captureX = Math.round(filmstripData.captureArea.x);
						captureY = Math.round(filmstripData.captureArea.y);
						captureWidth = Math.round(filmstripData.captureArea.width);
						captureHeight = Math.round(filmstripData.captureArea.height);

						// Clamp to canvas bounds
						captureX = Math.max(0, Math.min(captureX, canvas.width));
						captureY = Math.max(0, Math.min(captureY, canvas.height));
						captureWidth = Math.max(1, Math.min(captureWidth, canvas.width - captureX));
						captureHeight = Math.max(1, Math.min(captureHeight, canvas.height - captureY));
					}

					// Create a temporary 2D canvas to convert WebGL pixels to image
					const tempCanvas = document.createElement("canvas");
					tempCanvas.width = captureWidth;
					tempCanvas.height = captureHeight;
					const tempCtx = tempCanvas.getContext("2d");

					// Read pixels from WebGL context (only the capture area)
					const pixels = new Uint8Array(captureWidth * captureHeight * 4);
					// WebGL coordinates: y=0 is bottom, so we need to convert
					const glY = canvas.height - captureY - captureHeight;
					gl.readPixels(captureX, glY, captureWidth, captureHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

					// WebGL reads pixels from bottom-left, but canvas expects top-left
					// PERFORMANCE: Optimized vertical flip using direct array manipulation
					const imageData = tempCtx.createImageData(captureWidth, captureHeight);
					const data = imageData.data;
					const rowSize = captureWidth * 4;

					// Flip rows by swapping top and bottom rows
					for (let y = 0; y < captureHeight / 2; y++) {
						const topRow = y * rowSize;
						const bottomRow = (captureHeight - 1 - y) * rowSize;

						// Swap entire rows at once (faster than pixel-by-pixel)
						for (let x = 0; x < rowSize; x++) {
							const temp = pixels[topRow + x];
							pixels[topRow + x] = pixels[bottomRow + x];
							pixels[bottomRow + x] = temp;
						}
					}

					// Copy flipped pixels to imageData
					data.set(pixels);

					// Draw the flipped image to the 2D canvas
					tempCtx.putImageData(imageData, 0, 0);

					// Convert to data URL
					const dataURL = tempCanvas.toDataURL("image/png");

					// Deep clone chains data for vector export
					const vectorData = {
						chains: chains.map(chainObj => ({
							chain: chainObj.chain.map(dot => ({
								x: dot.x,
								y: dot.y,
								vx: dot.vx,
								vy: dot.vy,
								pinned: dot.pinned
							})),
							isClosed: chainObj.isClosed,
							color: chainObj.color ? [...chainObj.color] : [0, 0, 0, 1],
							alpha: chainObj.alpha ?? 1.0,
							baseDotRadius: chainObj.baseDotRadius,
							frozen: chainObj.frozen || false,
							isParticle: chainObj.isParticle || false,
							particleRenderSize: chainObj.particleRenderSize || 0
						})),
						circles: circles.map(circle => ({
							x: circle.x,
							y: circle.y,
							radius: circle.radius
						})),
						showFilled: showFilled,
						showOutline: showOutline,
						outlineWidth: outlineWidth
					};

					const frame = {
						imageData: dataURL,
						vectorData: vectorData,
						timestamp: Date.now(),
						index: filmstripData.frames.length
					};
					filmstripData.frames.push(frame);

					// Store first frame's vector data for overlay (if this is the first frame)
					if (filmstripData.frames.length === 1 && vectorData) {
						filmstripData.firstFrameOverlay = vectorData;
						// Pre-calculate and cache splines for overlay (performance optimization)
						filmstripData.overlaySplinesCache = [];
						vectorData.chains.forEach(chainObj => {
							// Include particles as circle overlay data
							if (chainObj.isParticle && chainObj.chain.length === 1) {
								filmstripData.overlaySplinesCache.push({
									isParticle: true,
									x: chainObj.chain[0].x,
									y: chainObj.chain[0].y,
									particleRenderSize: chainObj.particleRenderSize || 4
								});
								return;
							}
							if (chainObj.chain.length < 2) return;
							const spline = chainObj.isClosed
								? getClosedSmoothCurve(chainObj.chain, 10)
								: getOpenSmoothCurve(chainObj.chain, 10);
							if (spline.length >= 4) {
								filmstripData.overlaySplinesCache.push({
									spline: spline,
									isClosed: chainObj.isClosed
								});
							}
						});
					}

					renderFilmstrip();
					toast(`Frame ${filmstripData.frames.length} captured`, 1200);
				});
			}

			function deleteFrame(index) {
				if (index < 0 || index >= filmstripData.frames.length) return;

				filmstripData.frames.splice(index, 1);

				// Adjust current frame index if needed
				if (filmstripData.currentFrameIndex >= filmstripData.frames.length) {
					filmstripData.currentFrameIndex = Math.max(0, filmstripData.frames.length - 1);
				}

				// Re-render the filmstrip
				renderFilmstrip();
				toast(`Frame ${index + 1} deleted`, 1200);
			}

			function renderFilmstrip() {
				const container = $("filmstripFrames");

				// PERFORMANCE: Use DocumentFragment for batch DOM operations
				// This reduces reflows and improves performance when adding many elements
				container.innerHTML = "";
				const fragment = document.createDocumentFragment();

				filmstripData.frames.forEach((frame, index) => {
					const frameEl = document.createElement("div");
					frameEl.className = "filmstrip-frame";
					frameEl.dataset.index = index;

					const img = document.createElement("img");
					img.src = frame.imageData;
					img.alt = `Frame ${index + 1}`;

					const number = document.createElement("div");
					number.className = "filmstrip-frame-number";
					number.textContent = index + 1;

					// Add delete button
					const deleteBtn = document.createElement("div");
					deleteBtn.className = "filmstrip-frame-delete";
					deleteBtn.textContent = "×";
					deleteBtn.title = "Delete frame";
					deleteBtn.onclick = (e) => {
						e.stopPropagation(); // Prevent frame click
						deleteFrame(index);
					};

					frameEl.appendChild(img);
					frameEl.appendChild(number);
					frameEl.appendChild(deleteBtn);

					frameEl.onclick = () => {
						// Click frame to jump to it
						if (!filmstripData.isPlaying) {
							filmstripData.currentFrameIndex = index;
							displayFrame(index);
							updateFilmstripScroll();
						}
					};

					fragment.appendChild(frameEl);
				});

				// PERFORMANCE: Single DOM insertion instead of multiple
				container.appendChild(fragment);

				// Update active frame
				updateActiveFrame();

				// PERFORMANCE: Use requestAnimationFrame instead of setTimeout for smoother scrolling
				// Auto-scroll to bottom to show latest frame when there are more than 3 frames
				if (filmstripData.frames.length > 3) {
					requestAnimationFrame(() => {
						container.scrollTop = container.scrollHeight;
					});
				}
			}

			function updateActiveFrame() {
				const container = $("filmstripFrames");
				if (!container) return;
				const frames = container.querySelectorAll(".filmstrip-frame");
				if (frames.length === 0) return;

				// PERFORMANCE: Only update classes that changed instead of all frames
				const currentActive = frames[filmstripData.currentFrameIndex];
				const previousActive = container.querySelector(".filmstrip-frame.active");

				if (previousActive && previousActive !== currentActive) {
					previousActive.classList.remove("active");
				}
				if (currentActive) {
					currentActive.classList.add("active");
				}
			}

			function displayFrame(index) {
				if (index < 0 || index >= filmstripData.frames.length) return;

				filmstripData.currentFrameIndex = index;
				updateActiveFrame();
				updateFilmstripScroll();
			}

			function updateFilmstripScroll() {
				const container = $("filmstripFrames");
				const frames = container.querySelectorAll(".filmstrip-frame");
				if (frames.length === 0) return;

				const activeFrame = frames[filmstripData.currentFrameIndex];
				if (!activeFrame) return;

				// Calculate scroll position to center active frame in the yellow window
				const containerRect = container.parentElement.getBoundingClientRect();
				const frameTop = activeFrame.offsetTop;
				const frameHeight = activeFrame.offsetHeight;
				const containerHeight = containerRect.height;
				const currentScroll = container.scrollTop;
				const targetScroll = frameTop - (containerHeight / 2) + (frameHeight / 2);

				// For smooth continuous scrolling during playback
				if (filmstripData.isPlaying) {
					// Use smooth scrolling for continuous motion picture effect
					container.scrollTo({
						top: targetScroll,
						behavior: 'smooth'
					});
				} else {
					// Instant scroll when not playing
					container.scrollTop = targetScroll;
				}
			}

			function playFilmstrip() {
				if (filmstripData.frames.length === 0) {
					toast("No frames to play", 1500);
					return;
				}

				// Store first frame's vector data for overlay
				if (filmstripData.frames[0] && filmstripData.frames[0].vectorData) {
					filmstripData.firstFrameOverlay = filmstripData.frames[0].vectorData;
					// Pre-calculate and cache splines for overlay (performance optimization)
					filmstripData.overlaySplinesCache = [];
					filmstripData.firstFrameOverlay.chains.forEach(chainObj => {
						// Include particles as circle overlay data
						if (chainObj.isParticle && chainObj.chain.length === 1) {
							filmstripData.overlaySplinesCache.push({
								isParticle: true,
								x: chainObj.chain[0].x,
								y: chainObj.chain[0].y,
								particleRenderSize: chainObj.particleRenderSize || 4
							});
							return;
						}
						if (chainObj.chain.length < 2) return;
						const spline = chainObj.isClosed
							? getClosedSmoothCurve(chainObj.chain, 10)
							: getOpenSmoothCurve(chainObj.chain, 10);
						if (spline.length >= 4) {
							filmstripData.overlaySplinesCache.push({
								spline: spline,
								isClosed: chainObj.isClosed
							});
						}
					});
				}

				// Collapse panel to single frame view
				const panel = $("filmstripPanel");
				panel.classList.add("playing");

				filmstripData.isPlaying = true;
				$("filmstripPlayBtn").style.display = "none";
				$("filmstripPauseBtn").style.display = "inline-flex";

				// Get reference to single frame element
				const singleFrame = $("filmstripSingleFrame");
				if (!singleFrame) {
					console.error("Filmstrip single frame element not found");
					return;
				}

				// Start from frame 0 to show all frames in sequence
				filmstripData.currentFrameIndex = 0;
				singleFrame.src = filmstripData.frames[0].imageData;

				// Start animation loop
				const frameDelay = 1000 / filmstripData.fps;
				let lastFrameTime = performance.now();
				let frameAccumulator = 0;

				function animateFilmstrip(currentTime) {
					if (!filmstripData.isPlaying) {
						if (filmstripData.scrollAnimation) {
							cancelAnimationFrame(filmstripData.scrollAnimation);
							filmstripData.scrollAnimation = null;
						}
						return;
					}

					const deltaTime = currentTime - lastFrameTime;
					lastFrameTime = currentTime;
					frameAccumulator += deltaTime;

					// Update frame when enough time has passed
					if (frameAccumulator >= frameDelay) {
						// Move to next frame (loop if at end)
						filmstripData.currentFrameIndex = (filmstripData.currentFrameIndex + 1) % filmstripData.frames.length;

						// Update the single frame display
						const frame = filmstripData.frames[filmstripData.currentFrameIndex];
						if (frame && frame.imageData) {
							singleFrame.src = frame.imageData;
						}

						frameAccumulator = 0;
					}

					filmstripData.scrollAnimation = requestAnimationFrame(animateFilmstrip);
				}

				filmstripData.scrollAnimation = requestAnimationFrame(animateFilmstrip);
			}

			function pauseFilmstrip() {
				filmstripData.isPlaying = false;
				$("filmstripPlayBtn").style.display = "inline-flex";
				$("filmstripPauseBtn").style.display = "none";

				// Clear first frame overlay and cache
				filmstripData.firstFrameOverlay = null;
				filmstripData.overlaySplinesCache = null;
				filmstripData.overlayBuffer = null;

				// Expand panel back to full film strip view
				const panel = $("filmstripPanel");
				panel.classList.remove("playing");

				if (filmstripData.scrollAnimation) {
					cancelAnimationFrame(filmstripData.scrollAnimation);
					filmstripData.scrollAnimation = null;
				}

				// Update active frame in the film strip
				updateActiveFrame();
				updateFilmstripScroll();
			}

			// Show record frequency selection dialog
			function showRecordFrequencyDialog() {
				const backdrop = $("recordFrequencyBackdrop");
				if (backdrop) {
					backdrop.style.display = "flex";
				}
			}

			// Start recording with specified cadence
			function startRecording(cadenceMs) {
				if (filmstripData.isRecording) {
					stopRecording();
				}

				filmstripData.isRecording = true;
				filmstripData.recordingCadence = cadenceMs;

				// Update button appearance
				const recordBtn = $("filmstripRecordBtn");
				if (recordBtn) {
					recordBtn.classList.add("recording");
					recordBtn.title = "Stop Recording";
				}

				// Capture first frame immediately
				captureFrame();

				// Set up interval for automatic captures
				filmstripData.recordingInterval = setInterval(() => {
					// Check if we've reached max frames (100)
					if (filmstripData.frames.length >= 100) {
						toast("Maximum of 100 frames reached. Recording stopped.", 2000);
						stopRecording();
						return;
					}

					captureFrame();
				}, cadenceMs);

				// Format the cadence message nicely
				let cadenceText;
				if (cadenceMs === 250) {
					cadenceText = "1/4 second";
				} else if (cadenceMs === 500) {
					cadenceText = "1/2 second";
				} else {
					cadenceText = `${cadenceMs / 1000} seconds`;
				}
				toast(`Recording started: capturing every ${cadenceText}`, 2000);
			}

			// Stop recording
			function stopRecording() {
				if (!filmstripData.isRecording) return;

				filmstripData.isRecording = false;

				// Clear interval
				if (filmstripData.recordingInterval) {
					clearInterval(filmstripData.recordingInterval);
					filmstripData.recordingInterval = null;
				}

				// Update button appearance
				const recordBtn = $("filmstripRecordBtn");
				if (recordBtn) {
					recordBtn.classList.remove("recording");
					recordBtn.title = "Record Animation";
				}

				filmstripData.recordingCadence = null;

				toast(`Recording stopped. Captured ${filmstripData.frames.length} frames`, 2000);
			}

			function clearFilmstrip() {
				if (filmstripData.frames.length === 0) return;

				if (confirm(`Clear all ${filmstripData.frames.length} frames?`)) {
					// Stop recording if active
					if (filmstripData.isRecording) {
						stopRecording();
					}

					// Expand panel back to film strip mode (remove playing class)
					const panel = $("filmstripPanel");
					if (panel) {
						panel.classList.remove("playing");
					}

					// Clear the single frame display
					const singleFrame = $("filmstripSingleFrame");
					if (singleFrame) {
						singleFrame.src = "";
					}

					filmstripData.frames = [];
					filmstripData.currentFrameIndex = 0;
					filmstripData.isPlaying = false;
					$("filmstripPlayBtn").style.display = "inline-flex";
					$("filmstripPauseBtn").style.display = "none";

					if (filmstripData.scrollAnimation) {
						cancelAnimationFrame(filmstripData.scrollAnimation);
						filmstripData.scrollAnimation = null;
					}

					// Clear first frame overlay
					filmstripData.firstFrameOverlay = null;
					filmstripData.overlaySplinesCache = null;
					filmstripData.overlayBuffer = null;

					// Clear capture area and revert to full canvas
					filmstripData.captureArea = null;
					filmstripData.crosshairsMode = false;
					filmstripData.isDraggingCaptureArea = false;
					filmstripData.captureAreaStart = null;
					filmstripData.captureAreaCurrent = null;
					$("filmstripCrosshairsBtn").classList.remove("active");

					renderFilmstrip();
					toast("Film strip cleared and capture area reset", 1500);
				}
			}

			// Export filmstrip animation as video (WebM) using native MediaRecorder API
			async function exportFilmstripAnimation() {
				if (filmstripData.frames.length === 0) {
					toast("No frames to export", 1500);
					return;
				}

				// Check if MediaRecorder is supported
				if (typeof MediaRecorder === 'undefined' || !MediaRecorder.isTypeSupported) {
					toast("Video export not supported in this browser", 3000);
					return;
				}

				toast("Creating video...", 2000);

				// Set exporting flag to hide bounding box
				filmstripData.isExporting = true;

				// Get frame dimensions from first frame
				const firstFrame = new Image();
				firstFrame.src = filmstripData.frames[0].imageData;

				await new Promise((resolve, reject) => {
					firstFrame.onload = async () => {
						const width = firstFrame.width;
						const height = firstFrame.height;

						// Create a temporary canvas for recording
						const recordCanvas = document.createElement("canvas");
						recordCanvas.width = width;
						recordCanvas.height = height;
						const recordCtx = recordCanvas.getContext("2d");

						// Create a stream from the canvas
						const stream = recordCanvas.captureStream(filmstripData.fps);

						// Set up MediaRecorder
						const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
							? 'video/webm;codecs=vp9'
							: MediaRecorder.isTypeSupported('video/webm')
							? 'video/webm'
							: 'video/webm';

						const mediaRecorder = new MediaRecorder(stream, {
							mimeType: mimeType,
							videoBitsPerSecond: 2500000 // 2.5 Mbps
						});

						const chunks = [];

						mediaRecorder.ondataavailable = (event) => {
							if (event.data && event.data.size > 0) {
								chunks.push(event.data);
							}
						};

						mediaRecorder.onstop = () => {
							filmstripData.isExporting = false; // Reset flag
							const blob = new Blob(chunks, { type: mimeType });
							const url = URL.createObjectURL(blob);
							const link = document.createElement("a");
							link.href = url;
							link.download = `blobsketch-animation-${Date.now()}.webm`;
							link.click();
							URL.revokeObjectURL(url);
							toast(`Animation exported! ${filmstripData.frames.length} frames`, 2000);
							resolve();
						};

						mediaRecorder.onerror = (event) => {
							toast("Error recording video", 2000);
							reject(event.error);
						};

						// Start recording
						mediaRecorder.start();

						// Load all frame images
						const frameImages = [];
						let imagesLoaded = 0;

						filmstripData.frames.forEach((frame, index) => {
							const img = new Image();
							img.src = frame.imageData;

							img.onload = () => {
								frameImages[index] = img;
								imagesLoaded++;

								// When all images are loaded, start playing through frames
								if (imagesLoaded === filmstripData.frames.length) {
									let currentFrameIndex = 0;
									const frameDelay = 1000 / filmstripData.fps;
									const startTime = performance.now();

									function drawNextFrame() {
										if (currentFrameIndex >= frameImages.length) {
											// All frames drawn, stop recording
											setTimeout(() => {
												mediaRecorder.stop();
												stream.getTracks().forEach(track => track.stop());
											}, frameDelay);
											return;
										}

										// Draw current frame
										recordCtx.clearRect(0, 0, width, height);
										recordCtx.drawImage(frameImages[currentFrameIndex], 0, 0);

										currentFrameIndex++;

										// Schedule next frame
										setTimeout(drawNextFrame, frameDelay);
									}

									// Start drawing frames
									drawNextFrame();
								}
							};

							img.onerror = () => {
								imagesLoaded++;
								if (imagesLoaded === filmstripData.frames.length) {
									filmstripData.isExporting = false; // Reset flag on error
									toast("Error loading some frames", 2000);
									mediaRecorder.stop();
									stream.getTracks().forEach(track => track.stop());
									reject(new Error("Failed to load frames"));
								}
							};
						});
					};

					firstFrame.onerror = () => {
						filmstripData.isExporting = false; // Reset flag on error
						toast("Error loading first frame", 2000);
						reject(new Error("Failed to load first frame"));
					};
				});
			}

			// Export SVG animation
			function exportFilmstripSVG() {
				if (filmstripData.frames.length === 0) {
					toast("No frames to export", 1500);
					return;
				}

				// Check if frames have vector data
				if (!filmstripData.frames[0].vectorData) {
					toast("Vector data not available. Please recapture frames.", 2000);
					return;
				}

				toast("Creating SVG animation...", 2000);

				// Determine export dimensions based on capture area
				let exportX = 0;
				let exportY = 0;
				let exportWidth = canvas.width;
				let exportHeight = canvas.height;

				// If capture area is set, use it for export dimensions
				if (filmstripData.captureArea) {
					exportX = filmstripData.captureArea.x;
					exportY = filmstripData.captureArea.y;
					exportWidth = filmstripData.captureArea.width;
					exportHeight = filmstripData.captureArea.height;
				}

				// Get visual dimensions for scaling
				const rect = canvas.getBoundingClientRect();
				const visualWidth = rect.width || canvas.width;
				const visualHeight = rect.height || canvas.height;
				const scaleX = visualWidth / canvas.width;
				const scaleY = visualHeight / canvas.height;

				// Calculate scaled export dimensions
				const scaledExportWidth = exportWidth * scaleX;
				const scaledExportHeight = exportHeight * scaleY;

				// Calculate frame duration in seconds
				const frameDuration = 1 / filmstripData.fps;
				const totalDuration = filmstripData.frames.length * frameDuration;

				// Create SVG with animation - use capture area dimensions if set
				const svgParts = [`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${scaledExportWidth} ${scaledExportHeight}" style="background:white;">`];

				// Create a hidden master timeline that repeats indefinitely
				// This will be used to synchronize all frame animations
				svgParts.push(`<rect width="0" height="0" opacity="0">`);
				svgParts.push(`<animate id="masterLoop" attributeName="opacity" values="0;1" dur="${totalDuration}s" repeatCount="indefinite" />`);
				svgParts.push(`</rect>`);

				// Create a group for each frame
				filmstripData.frames.forEach((frame, frameIndex) => {
					const vectorData = frame.vectorData;
					const groupId = `frame-${frameIndex}`;

					// Calculate when this frame should be visible (in seconds)
					const beginTime = frameIndex * frameDuration;
					const endTime = (frameIndex + 1) * frameDuration;

					// Start with opacity 0, will be animated (opacity is animatable, display is not)
					svgParts.push(`<g id="${groupId}" opacity="0">`);

					// Draw chains (blobs)
					vectorData.chains.forEach(chainObj => {
						// Handle particle chains (single-vertex, rendered as circles)
						if (chainObj.isParticle && chainObj.chain.length === 1) {
							const dot = chainObj.chain[0];
							const r = (chainObj.particleRenderSize || 4) * dotScaleFactor;
							const [rr, gg, bb] = chainObj.color.map(c => Math.floor(c * 255));
							const cx = (dot.x - exportX) * scaleX;
							const cy = (dot.y - exportY) * scaleY;
							const sr = r * Math.min(scaleX, scaleY);
							svgParts.push(`<circle cx="${cx}" cy="${cy}" r="${sr}" fill="rgb(${rr},${gg},${bb})" />`);
							return;
						}

						if (chainObj.chain.length < 2) return;

						// Generate smooth spline using the same functions as rendering
						const spline = chainObj.isClosed
							? getClosedSmoothCurve(chainObj.chain, 10)
							: getOpenSmoothCurve(chainObj.chain, 10);

						if (spline.length < 4) return;

						// Build SVG path from spline, offsetting by capture area if set
						// Convert canvas coordinates to export coordinates (relative to capture area)
						let pathData = `M ${(spline[0] - exportX) * scaleX} ${(spline[1] - exportY) * scaleY}`;
						for (let i = 2; i < spline.length; i += 2) {
							pathData += ` L ${(spline[i] - exportX) * scaleX} ${(spline[i + 1] - exportY) * scaleY}`;
						}
						if (chainObj.isClosed) pathData += " Z";

						const [rr, gg, bb] = chainObj.color.map(c => Math.floor(c * 255));
						// Make frozen items appear unfrozen (always use alpha 1.0)
						const alpha = 1.0;
						const shouldFill = (vectorData.showFilled && chainObj.isClosed);
						const shouldStroke = vectorData.showOutline;
						const strokeWidth = vectorData.outlineWidth * Math.min(scaleX, scaleY);

						if (shouldFill && shouldStroke) {
							svgParts.push(`<path d="${pathData}" fill="rgb(${rr},${gg},${bb})" fill-opacity="${alpha}" stroke="rgb(0,0,0)" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" />`);
						} else if (shouldFill) {
							svgParts.push(`<path d="${pathData}" fill="rgb(${rr},${gg},${bb})" fill-opacity="${alpha}" stroke="none" />`);
						} else if (shouldStroke) {
							svgParts.push(`<path d="${pathData}" stroke="rgb(${rr},${gg},${bb})" stroke-opacity="${alpha}" fill="none" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" />`);
						}
					});

					// Circles are not exported (repulsion circles removed from export)

					// Add animation to show this frame at the right time
					// Use animate with opacity for reliable infinite looping
					// Calculate keyTimes as fractions (0 to 1) of totalDuration
					const startKey = beginTime / totalDuration;
					const endKey = endTime / totalDuration;

					// Animate opacity: 0 (hidden) -> 1 (visible) -> 0 (hidden)
					// This loops infinitely because masterLoop repeats indefinitely
					svgParts.push(`<animate attributeName="opacity"
						values="0;0;1;1;0;0"
						keyTimes="0;${startKey};${startKey};${endKey};${endKey};1"
						dur="${totalDuration}s"
						repeatCount="indefinite"
						calcMode="discrete" />`);

					svgParts.push(`</g>`);
				});

				svgParts.push("</svg>");

				const blob = new Blob([svgParts.join("")], { type: "image/svg+xml" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = `blobsketch-animation-${Date.now()}.svg`;
				link.click();
				URL.revokeObjectURL(url);
				toast(`SVG animation exported! ${filmstripData.frames.length} frames`, 2000);
			}

			// Export menu handler
			function showExportMenu() {
				if (filmstripData.frames.length === 0) {
					toast("No frames to export", 1500);
					return;
				}

				const hasVectorData = filmstripData.frames[0] && filmstripData.frames[0].vectorData;
				const backdrop = $("exportAnimationBackdrop");

				// Show/hide SVG button based on vector data availability
				const svgBtn = $("exportSVGBtn");
				if (svgBtn) {
					svgBtn.style.display = hasVectorData ? "inline-block" : "none";
				}

				// Show dialog
				backdrop.style.display = "flex";

				// Close dialog on backdrop click
				backdrop.onclick = (e) => {
					if (e.target === backdrop) {
						backdrop.style.display = "none";
					}
				};
			}

			// Export dialog button handlers
			$("exportWebMBtn").onclick = () => {
				$("exportAnimationBackdrop").style.display = "none";
				exportFilmstripAnimation();
			};

			$("exportSVGBtn").onclick = () => {
				$("exportAnimationBackdrop").style.display = "none";
				exportFilmstripSVG();
			};

			$("exportCancelBtn").onclick = () => {
				$("exportAnimationBackdrop").style.display = "none";
			};

			// ── Konami Code Easter Egg → unlocks Film Strip mode ──
			{
				const konamiSequence = [
					"ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown",
					"ArrowLeft", "ArrowRight", "ArrowLeft", "ArrowRight",
					"KeyB", "KeyA"
				];
				let konamiIndex = 0;

				document.addEventListener("keydown", (e) => {
					if (e.code === konamiSequence[konamiIndex]) {
						konamiIndex++;
						if (konamiIndex === konamiSequence.length) {
							konamiIndex = 0;
							if (!document.body.classList.contains("filmstrip-unlocked")) {
								document.body.classList.add("filmstrip-unlocked");
								toast("🎬 Film Strip mode unlocked!", 3000);
								SFX.uiConfirm();
							}
						}
					} else {
						konamiIndex = 0;
					}
				});
			}

			// Film strip event handlers
			$("filmstripCaptureBtn").onclick = captureFrame;
			$("filmstripPlayBtn").onclick = playFilmstrip;
			$("filmstripPauseBtn").onclick = pauseFilmstrip;
			$("filmstripClearBtn").onclick = clearFilmstrip;
			$("filmstripExportBtn").onclick = showExportMenu;

			// Record button handler
			$("filmstripRecordBtn").onclick = () => {
				if (filmstripData.isRecording) {
					// Stop recording
					stopRecording();
				} else {
					// Show frequency selection dialog
					showRecordFrequencyDialog();
				}
			};

			// Record frequency dialog handlers
			$("recordQuarterBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
				startRecording(250); // 1/4 second
			};

			$("recordHalfBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
				startRecording(500); // 1/2 second
			};

			$("record1sBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
				startRecording(1000); // 1 second
			};

			$("record5sBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
				startRecording(5000); // 5 seconds
			};

			$("record10sBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
				startRecording(10000); // 10 seconds
			};

			$("recordCancelBtn").onclick = () => {
				$("recordFrequencyBackdrop").style.display = "none";
			};

			// Close dialog on backdrop click
			{
				const recordBackdrop = $("recordFrequencyBackdrop");
				if (recordBackdrop) {
					recordBackdrop.onclick = (e) => {
						if (e.target === recordBackdrop) {
							recordBackdrop.style.display = "none";
						}
					};
				}
			}

			// Crosshairs button - toggle capture area selection
			$("filmstripCrosshairsBtn").onclick = () => {
				if (filmstripData.crosshairsMode) {
					// Deactivate - clear capture area
					filmstripData.crosshairsMode = false;
					filmstripData.captureArea = null;
					filmstripData.isDraggingCaptureArea = false;
					$("filmstripCrosshairsBtn").classList.remove("active");

					// Restore previous cursor
					if (filmstripData.previousCursor !== null) {
						canvas.style.cursor = filmstripData.previousCursor;
						filmstripData.previousCursor = null;
					} else {
						canvas.style.cursor = '';
					}

					toast("Capture area cleared", 1200);
				} else {
					// Activate crosshairs mode
					filmstripData.crosshairsMode = true;

					// Store current cursor and set to pointer
					filmstripData.previousCursor = canvas.style.cursor || '';
					canvas.style.cursor = 'pointer';

					$("filmstripCrosshairsBtn").classList.add("active");
					toast("Click and drag on canvas to define capture area", 2000);
				}
			};

			// Add CSS for active crosshairs button
			const crosshairsStyle = document.createElement("style");
			crosshairsStyle.textContent = `
				.filmstrip-btn.active {
					background: rgba(255, 215, 0, 0.3);
					border-color: rgba(255, 215, 0, 0.6);
				}
			`;
			document.head.appendChild(crosshairsStyle);

			// Initialize film strip panel hide/show
			// Film strip will be initialized in toggleFullscreen function below

			// Panel dragging functionality
			function initPanelDragging() {
				const toolbar = document.querySelector(".toolbar");
				const bottomPanel = document.querySelector(".bottom-panel");
				const filmstripPanel = $("filmstripPanel");

				function makeDraggable(panel) {
					let isDragging = false;
					let currentX;
					let currentY;
					let initialX;
					let initialY;
					let xOffset = 0;
					let yOffset = 0;

					// Reset to original position (don't load from localStorage)
					let panelId = "toolbar";
					if (panel === toolbar) {
						panelId = "toolbar";
						// Toolbar original position: left: 20px, top: 60px
						panel.style.left = "20px";
						panel.style.top = "60px";
						panel.style.right = "auto";
						panel.style.bottom = "auto";
						panel.style.transform = "none";
					} else if (panel === bottomPanel) {
						panelId = "bottom-panel";
						// Bottom panel original position: bottom-right with 20px padding
						panel.style.left = "auto";
						panel.style.top = "auto";
						panel.style.right = "20px";
						panel.style.bottom = "20px";
						panel.style.transform = "none";
					} else if (panel === filmstripPanel) {
						panelId = "filmstrip-panel";
						// Filmstrip panel original position: right: 20px, top: 60px
						panel.style.left = "auto";
						panel.style.top = "60px";
						panel.style.right = "20px";
						panel.style.bottom = "auto";
						panel.style.transform = "none";
					}
					// xOffset and yOffset will be calculated in dragStart when dragging begins

					function dragStart(e) {
						// Don't allow dragging if panel is hidden
						if (panel.classList.contains("panel-hidden")) {
							return;
						}

						if (e.target.tagName === "INPUT" || e.target.tagName === "BUTTON" ||
						    e.target.closest(".icon") || e.target.closest("label") ||
						    e.target.closest(".submenu") || e.target.closest(".help-icon-container") ||
						    e.target.closest(".panel-hide-btn")) {
							return;
						}

						// Calculate offset from mouse position to panel's top-left corner
						const rect = panel.getBoundingClientRect();
						if (e.type === "touchstart") {
							initialX = e.touches[0].clientX - rect.left;
							initialY = e.touches[0].clientY - rect.top;
						} else {
							initialX = e.clientX - rect.left;
							initialY = e.clientY - rect.top;
						}

						// Get current panel position
						xOffset = rect.left;
						yOffset = rect.top;

						if (e.target === panel || panel.contains(e.target)) {
							isDragging = true;
							panel.classList.add("dragging");
						}
					}

					function drag(e) {
						if (!isDragging) return;

						e.preventDefault();

						if (e.type === "touchmove") {
							currentX = e.touches[0].clientX - initialX;
							currentY = e.touches[0].clientY - initialY;
						} else {
							currentX = e.clientX - initialX;
							currentY = e.clientY - initialY;
						}

						xOffset = currentX;
						yOffset = currentY;

						// Constrain to viewport
						const rect = panel.getBoundingClientRect();
						const maxX = window.innerWidth - rect.width;
						const maxY = window.innerHeight - rect.height;

						xOffset = Math.max(0, Math.min(xOffset, maxX));
						yOffset = Math.max(0, Math.min(yOffset, maxY));

						panel.style.left = xOffset + "px";
						panel.style.top = yOffset + "px";
						panel.style.right = "auto";
						panel.style.bottom = "auto";
						panel.style.transform = "none";
					}

					function dragEnd() {
						if (isDragging) {
							isDragging = false;
							panel.classList.remove("dragging");

							// Save position to localStorage
							let panelId = "toolbar";
							if (panel === toolbar) panelId = "toolbar";
							else if (panel === bottomPanel) panelId = "bottom-panel";
							else if (panel === filmstripPanel) panelId = "filmstrip-panel";
							localStorage.setItem(`fullscreen-${panelId}-pos`, JSON.stringify({
								x: xOffset,
								y: yOffset
							}));
						}
					}

					panel.addEventListener("mousedown", dragStart);
					panel.addEventListener("touchstart", dragStart, { passive: false });
					document.addEventListener("mousemove", drag);
					document.addEventListener("touchmove", drag, { passive: false });
					document.addEventListener("mouseup", dragEnd);
					document.addEventListener("touchend", dragEnd);
				}

				if (toolbar) makeDraggable(toolbar);
				if (bottomPanel) makeDraggable(bottomPanel);
				if (filmstripPanel) makeDraggable(filmstripPanel);
			}

			// Panel hide/show functionality
			function initPanelHideShow() {
				const toolbar = document.querySelector(".toolbar");
				const bottomPanel = document.querySelector(".bottom-panel");
				const filmstripPanel = $("filmstripPanel");
				const hideToolbarBtn = document.getElementById("hideToolbar");
				const hideBottomPanelBtn = document.getElementById("hideBottomPanel");
				const hideFilmstripBtn = document.getElementById("hideFilmstrip");

				// Remove existing event listeners if they exist
				if (panelHideHandlers.toolbar && hideToolbarBtn) {
					hideToolbarBtn.removeEventListener("click", panelHideHandlers.toolbar);
				}
				if (panelHideHandlers.bottomPanel && hideBottomPanelBtn) {
					hideBottomPanelBtn.removeEventListener("click", panelHideHandlers.bottomPanel);
				}
				if (panelHideHandlers.filmstrip && hideFilmstripBtn) {
					hideFilmstripBtn.removeEventListener("click", panelHideHandlers.filmstrip);
				}

				function togglePanel(panel, hideBtn) {
					if (!panel || !hideBtn) return;

					const isHidden = panel.classList.contains("panel-hidden");

					if (isHidden) {
						// Show panel - restore to original position
						panel.classList.remove("panel-hidden");
						hideBtn.textContent = "−";
						if (hideBtn === hideToolbarBtn) {
							hideBtn.title = "Hide Tools Panel";
						} else if (hideBtn === hideBottomPanelBtn) {
							hideBtn.title = "Hide Sliders Panel";
						} else if (hideBtn === hideFilmstripBtn) {
							hideBtn.title = "Hide Film Strip Panel";
						}
						hideBtn.classList.remove("panel-restore");

						// Restore original position if we saved it
						if (panelOriginalPositions.has(panel)) {
							const pos = panelOriginalPositions.get(panel);
							panel.style.left = pos.left;
							panel.style.top = pos.top;
							panel.style.right = pos.right;
							panel.style.bottom = pos.bottom;
							panel.style.transform = pos.transform;
							panelOriginalPositions.delete(panel);
						}
					} else {
						// Hide panel (dock it to fixed anchor point)
						// Save current position first
						const rect = panel.getBoundingClientRect();
						panelOriginalPositions.set(panel, {
							left: panel.style.left,
							top: panel.style.top,
							right: panel.style.right,
							bottom: panel.style.bottom,
							transform: panel.style.transform
						});

						// Move to fixed anchor point
						if (panel === toolbar) {
							// Dock to top-left
							panel.style.left = "20px";
							panel.style.top = "60px";
							panel.style.right = "auto";
							panel.style.bottom = "auto";
							panel.style.transform = "none";
						} else if (panel === bottomPanel) {
							// Dock to bottom-right
							panel.style.left = "auto";
							panel.style.top = "auto";
							panel.style.right = "20px";
							panel.style.bottom = "20px";
							panel.style.transform = "none";
						} else if (panel === filmstripPanel) {
							// Dock to top-right
							panel.style.left = "auto";
							panel.style.top = "60px";
							panel.style.right = "20px";
							panel.style.bottom = "auto";
							panel.style.transform = "none";
						}

						// Add hidden class after a brief delay to allow position change
						setTimeout(() => {
							panel.classList.add("panel-hidden");
							hideBtn.textContent = "+";
							if (hideBtn === hideToolbarBtn) {
								hideBtn.title = "Show Tools Panel";
							} else if (hideBtn === hideBottomPanelBtn) {
								hideBtn.title = "Show Sliders Panel";
							} else if (hideBtn === hideFilmstripBtn) {
								hideBtn.title = "Show Film Strip Panel";
							}
							hideBtn.classList.add("panel-restore");
						}, 10);
					}
				}

				// Create and store event handlers
				if (hideToolbarBtn) {
					panelHideHandlers.toolbar = (e) => {
						e.stopPropagation();
						togglePanel(toolbar, hideToolbarBtn);
					};
					hideToolbarBtn.addEventListener("click", panelHideHandlers.toolbar);
				}

				if (hideBottomPanelBtn) {
					panelHideHandlers.bottomPanel = (e) => {
						e.stopPropagation();
						togglePanel(bottomPanel, hideBottomPanelBtn);
					};
					hideBottomPanelBtn.addEventListener("click", panelHideHandlers.bottomPanel);
				}

				if (hideFilmstripBtn && filmstripPanel) {
					panelHideHandlers.filmstrip = (e) => {
						e.stopPropagation();
						togglePanel(filmstripPanel, hideFilmstripBtn);
					};
					hideFilmstripBtn.addEventListener("click", panelHideHandlers.filmstrip);
				}
			}

			// Constrain panels to viewport on window resize
			function constrainPanelsToViewport() {
				if (!isFullscreen) return;

				const toolbar = document.querySelector(".toolbar");
				const bottomPanel = document.querySelector(".bottom-panel");
				const filmstripPanel = $("filmstripPanel");

				[toolbar, bottomPanel, filmstripPanel].forEach(panel => {
					if (!panel) return;

					const rect = panel.getBoundingClientRect();
					const maxX = window.innerWidth - rect.width;
					const maxY = window.innerHeight - rect.height;

					// Get current position
					let currentX = rect.left;
					let currentY = rect.top;

					// Constrain position
					currentX = Math.max(0, Math.min(currentX, maxX));
					currentY = Math.max(0, Math.min(currentY, maxY));

					// Only update if position changed
					if (currentX !== rect.left || currentY !== rect.top) {
						panel.style.left = currentX + "px";
						panel.style.top = currentY + "px";
						panel.style.right = "auto";
						panel.style.bottom = "auto";
						panel.style.transform = "none";
					}
				});
			}

			// Initialize dragging when entering fullscreen (will be called by toggleFullscreen)

			let interRepelMult = 1; // 0 = no repel, 1 = normal, 3 = high

			// Function to map slider value (0, 1, 2) to interRepelMult (0, 1, 3)
			function sliderToRepelMult(sliderValue) {
				return sliderValue === 0 ? 0 : sliderValue === 1 ? 1 : 3;
			}

			// Function to map interRepelMult (0, 1, 3) to slider value (0, 1, 2)
			function repelMultToSlider(repelMult) {
				return repelMult === 0 ? 0 : repelMult === 1 ? 1 : 2;
			}

			// Function to get label text for repel mode
			function getRepelModeLabel(repelMult) {
				return repelMult === 0 ? "No Repel" : repelMult === 1 ? "Normal Repel" : "High Repel";
			}

			$("iconDiffusion").onclick = () => {
				// Initialize dialog with current value
				const currentSliderValue = repelMultToSlider(interRepelMult);
				$("repelModeSlider").value = currentSliderValue;
				$("repelModeLabel").textContent = getRepelModeLabel(interRepelMult);
				
				// Show dialog
				$("repelModeBackdrop").style.display = "flex";
			};

			// Repel mode dialog handlers
			$("repelModeSlider").addEventListener("input", (e) => {
				const sliderValue = parseInt(e.target.value);
				const repelMult = sliderToRepelMult(sliderValue);
				$("repelModeLabel").textContent = getRepelModeLabel(repelMult);
			});

			$("repelModeApplyBtn").onclick = () => {
				const sliderValue = parseInt($("repelModeSlider").value);
				interRepelMult = sliderToRepelMult(sliderValue);
				
				// Update icon active state (active for normal or high, inactive for no repel)
				toggleActiveIcon($("iconDiffusion"), interRepelMult !== 0);
				
				// Show toast with current mode
				toast(`Repel Mode: ${getRepelModeLabel(interRepelMult)}`, 1600);
				
				// Close dialog
				$("repelModeBackdrop").style.display = "none";
			};

			$("repelModeCancelBtn").onclick = () => {
				$("repelModeBackdrop").style.display = "none";
			};

			// Close dialog on backdrop click
			$("repelModeBackdrop").addEventListener("click", (e) => {
				if (e.target.id === "repelModeBackdrop") {
					$("repelModeBackdrop").style.display = "none";
				}
			});

			/* -----------------------------------
			   GRADIENT CURVE EDITOR
			----------------------------------- */
			let currentEditingAttractorIndex = null;
			let curvePoints = []; // Array of {x: 0-1, y: 0-1} representing curve control points
			let draggingCurvePoint = null;
			const CURVE_POINT_RADIUS = 8;
			const CURVE_RESOLUTION = 64; // Number of samples for the curve

			// Initialize curve editor canvas
			const curveCanvas = $("gradientCurveCanvas");
			const curveCtx = curveCanvas.getContext("2d");

			// Function to get curve value at a given position (0 to 1)
			function getCurveValue(curve, position) {
				if (!curve || curve.length === 0) return 1.0;
				
				// Find the two points to interpolate between
				for (let i = 0; i < curve.length - 1; i++) {
					if (position >= curve[i].x && position <= curve[i + 1].x) {
						// Linear interpolation
						const t = (position - curve[i].x) / (curve[i + 1].x - curve[i].x);
						return curve[i].y + (curve[i + 1].y - curve[i].y) * t;
					}
				}
				
				// Clamp to first or last point
				if (position <= curve[0].x) return curve[0].y;
				if (position >= curve[curve.length - 1].x) return curve[curve.length - 1].y;
				return 1.0;
			}

			// Function to draw the curve editor
			function drawCurveEditor() {
				const width = curveCanvas.width;
				const height = curveCanvas.height;
				const padding = 20;
				const drawWidth = width - padding * 2;
				const drawHeight = height - padding * 2;

				// Clear canvas
				curveCtx.clearRect(0, 0, width, height);

				// Draw background grid
				curveCtx.strokeStyle = "#e0e0e0";
				curveCtx.lineWidth = 1;
				for (let i = 0; i <= 10; i++) {
					const y = padding + (drawHeight / 10) * i;
					curveCtx.beginPath();
					curveCtx.moveTo(padding, y);
					curveCtx.lineTo(width - padding, y);
					curveCtx.stroke();
				}
				for (let i = 0; i <= 10; i++) {
					const x = padding + (drawWidth / 10) * i;
					curveCtx.beginPath();
					curveCtx.moveTo(x, padding);
					curveCtx.lineTo(x, height - padding);
					curveCtx.stroke();
				}

				// Draw axes
				curveCtx.strokeStyle = "#666";
				curveCtx.lineWidth = 2;
				curveCtx.beginPath();
				curveCtx.moveTo(padding, padding);
				curveCtx.lineTo(padding, height - padding);
				curveCtx.lineTo(width - padding, height - padding);
				curveCtx.stroke();

				// Draw curve line
				if (curvePoints.length > 0) {
					// Sort points by x
					const sortedPoints = [...curvePoints].sort((a, b) => a.x - b.x);
					
					// Get temporal settings for preview
					const temporalMode = $("temporalModeSelect").value;
					const temporalFrequency = parseFloat($("temporalFrequencySlider").value);
					const temporalAmplitude = parseFloat($("temporalAmplitudeSlider").value);
					const time = Date.now() / 1000;
					
					// Draw base curve
					curveCtx.strokeStyle = "#0066ff";
					curveCtx.lineWidth = 3;
					curveCtx.beginPath();
					
					// Draw smooth curve through points
					for (let i = 0; i < sortedPoints.length; i++) {
						const px = padding + sortedPoints[i].x * drawWidth;
						const py = height - padding - sortedPoints[i].y * drawHeight;
						
						if (i === 0) {
							curveCtx.moveTo(px, py);
						} else {
							// Use quadratic curve for smoother transitions
							const prevX = padding + sortedPoints[i - 1].x * drawWidth;
							const prevY = height - padding - sortedPoints[i - 1].y * drawHeight;
							const midX = (prevX + px) / 2;
							const midY = (prevY + py) / 2;
							curveCtx.quadraticCurveTo(prevX, prevY, midX, midY);
							curveCtx.lineTo(px, py);
						}
					}
					curveCtx.stroke();
					
					// Draw temporal preview overlay if temporal mode is active
					if (temporalMode !== 'none') {
						curveCtx.strokeStyle = "#ff6600";
						curveCtx.lineWidth = 2;
						curveCtx.setLineDash([5, 5]);
						curveCtx.beginPath();
						
						// Sample curve at many points for smooth preview
						const numSamples = 100;
						let firstPoint = true;
						
						for (let i = 0; i <= numSamples; i++) {
							const pos = i / numSamples;
							let y = getCurveValue(sortedPoints, pos);
							
							// Apply temporal modification
							if (temporalMode === 'oscillate') {
								const oscillation = Math.sin(time * temporalFrequency * Math.PI * 2);
								y = y * (1.0 + oscillation * temporalAmplitude);
								y = Math.max(0, Math.min(1, y));
							} else if (temporalMode === 'shift') {
								const shiftAmount = (Math.sin(time * temporalFrequency * Math.PI * 2) * 0.5 + 0.5) * temporalAmplitude;
								const shiftDirection = $("shiftDirectionSelect").value === 'backward' ? -1 : 1;
								let shiftedPos = pos + (shiftAmount * shiftDirection);
								if (shiftedPos < 0) shiftedPos = 1 + shiftedPos;
								if (shiftedPos > 1) shiftedPos = shiftedPos - 1;
								y = getCurveValue(sortedPoints, shiftedPos);
							} else if (temporalMode === 'reverse') {
								// Reverse mode: curve shape stays the same, but direction oscillates
								// For preview, we can show the curve with a visual indicator of direction change
								// The curve itself doesn't change, so just use the base curve
								y = getCurveValue(sortedPoints, pos);
								// We'll add a visual indicator separately
							}
							
							const px = padding + pos * drawWidth;
							const py = height - padding - y * drawHeight;
							
							if (firstPoint) {
								curveCtx.moveTo(px, py);
								firstPoint = false;
							} else {
								curveCtx.lineTo(px, py);
							}
						}
						curveCtx.stroke();
						curveCtx.setLineDash([]);
						
						// For reverse mode, add a visual indicator showing direction oscillation
						if (temporalMode === 'reverse') {
							const directionOscillation = Math.sin(time * temporalFrequency * Math.PI * 2);
							const amplitude = temporalAmplitude;
							
							// Draw direction indicator arrows at start and end
							curveCtx.strokeStyle = directionOscillation >= 0 ? "#00ff00" : "#ff0000";
							curveCtx.lineWidth = 2;
							curveCtx.setLineDash([]);
							
							// Arrow at start (left)
							const startX = padding + 10;
							const startY = height - padding - 20;
							const arrowLen = 15;
							const arrowAngle = directionOscillation >= 0 ? 0 : Math.PI; // Point right if forward, left if backward
							
							curveCtx.beginPath();
							curveCtx.moveTo(startX, startY);
							curveCtx.lineTo(startX + Math.cos(arrowAngle) * arrowLen, startY + Math.sin(arrowAngle) * arrowLen);
							curveCtx.stroke();
							
							// Arrow at end (right)
							const endX = width - padding - 10;
							const endY = height - padding - 20;
							curveCtx.beginPath();
							curveCtx.moveTo(endX, endY);
							curveCtx.lineTo(endX + Math.cos(arrowAngle) * arrowLen, endY + Math.sin(arrowAngle) * arrowLen);
							curveCtx.stroke();
						}
					}
				}

				// Draw control points
				curveCtx.fillStyle = "#0066ff";
				curveCtx.strokeStyle = "#fff";
				curveCtx.lineWidth = 2;
				for (const point of curvePoints) {
					const px = padding + point.x * drawWidth;
					const py = height - padding - point.y * drawHeight;
					curveCtx.beginPath();
					curveCtx.arc(px, py, CURVE_POINT_RADIUS, 0, Math.PI * 2);
					curveCtx.fill();
					curveCtx.stroke();
				}

				// Draw labels
				curveCtx.fillStyle = "#333";
				curveCtx.font = "12px sans-serif";
				curveCtx.textAlign = "center";
				curveCtx.save();
				curveCtx.translate(15, height / 2);
				curveCtx.rotate(-Math.PI / 2);
				curveCtx.fillText("Force", 0, 0);
				curveCtx.restore();
				curveCtx.fillText("Position along path", width / 2, height - 5);
			}

			// Function to get canvas coordinates from mouse event
			function getCurveCanvasXY(e) {
				const rect = curveCanvas.getBoundingClientRect();
				const scaleX = curveCanvas.width / rect.width;
				const scaleY = curveCanvas.height / rect.height;
				return {
					x: (e.clientX - rect.left) * scaleX,
					y: (e.clientY - rect.top) * scaleY
				};
			}

			// Function to find closest curve point to mouse
			function findClosestCurvePoint(x, y) {
				const padding = 20;
				const drawWidth = curveCanvas.width - padding * 2;
				const drawHeight = curveCanvas.height - padding * 2;
				
				let closest = null;
				let minDist = Infinity;
				
				for (let i = 0; i < curvePoints.length; i++) {
					const px = padding + curvePoints[i].x * drawWidth;
					const py = curveCanvas.height - padding - curvePoints[i].y * drawHeight;
					const dist = Math.hypot(x - px, y - py);
					if (dist < CURVE_POINT_RADIUS * 2 && dist < minDist) {
						minDist = dist;
						closest = i;
					}
				}
				
				return closest;
			}

			// Curve editor — use pointer events for touch/stylus support
			let curveCanvasActivePointerId = null;
			let curveDeleteTimer = null;
			let curveDeleteTargetIndex = null;

			// Primary pointer test: accept pen/touch, left mouse only
			function isPrimaryPointerCurve(evt) {
				return (evt.isPrimary !== false) && (evt.pointerType !== "mouse" || evt.button === 0);
			}

			curveCanvas.addEventListener("pointerdown", (e) => {
				if (!isPrimaryPointerCurve(e)) return;
				e.preventDefault();
				curveCanvasActivePointerId = e.pointerId;
				curveCanvas.setPointerCapture(curveCanvasActivePointerId);

				const { x, y } = getCurveCanvasXY(e);
				const padding = 20;
				const drawWidth = curveCanvas.width - padding * 2;
				const drawHeight = curveCanvas.height - padding * 2;

				// Check if clicking on existing point
				const pointIndex = findClosestCurvePoint(x, y);
				if (pointIndex !== null) {
					// Start long-press timer for deletion (touch-friendly alternative to right-click)
					if (pointIndex !== 0 && pointIndex !== curvePoints.length - 1 && curvePoints.length > 2) {
						curveDeleteTargetIndex = pointIndex;
						curveDeleteTimer = setTimeout(() => {
							if (curveDeleteTargetIndex !== null) {
								curvePoints.splice(curveDeleteTargetIndex, 1);
								drawCurveEditor();
								curveDeleteTargetIndex = null;
								draggingCurvePoint = null;
							}
						}, 500); // 500ms long-press to delete
					}
					draggingCurvePoint = pointIndex;
				} else {
					// Check if clicking in the drawing area
					if (x >= padding && x <= curveCanvas.width - padding &&
						y >= padding && y <= curveCanvas.height - padding) {
						// Add new point
						const normalizedX = (x - padding) / drawWidth;
						const normalizedY = 1.0 - (y - padding) / drawHeight;
						// Store the last point's y value before adding new point (to preserve it)
						const lastPointY = curvePoints.length > 0 ? curvePoints[curvePoints.length - 1].y : 0;
						// Clamp x to ensure new point is not at x=1 (last point must always be at x=1)
						const clampedX = Math.max(0, Math.min(0.999, normalizedX));
						curvePoints.push({ x: clampedX, y: Math.max(0, Math.min(1, normalizedY)) });
						curvePoints.sort((a, b) => a.x - b.x);
						// Ensure first point is at x=0 and last point is at x=1 with preserved y
						if (curvePoints.length > 0) {
							curvePoints[0].x = 0;
							const lastIndex = curvePoints.length - 1;
							curvePoints[lastIndex].x = 1;
							// Preserve the y value of the last point (it should stay where it was)
							curvePoints[lastIndex].y = lastPointY;
						}
						// Find the index of the newly added point after sorting
						draggingCurvePoint = curvePoints.findIndex(p => 
							Math.abs(p.x - clampedX) < 0.01 && Math.abs(p.y - normalizedY) < 0.01
						);
						if (draggingCurvePoint === -1) {
							draggingCurvePoint = curvePoints.length - 1;
						}
						drawCurveEditor();
					}
				}
			}, { passive: false });

			curveCanvas.addEventListener("pointermove", (e) => {
				if (curveCanvasActivePointerId !== null && e.pointerId !== curveCanvasActivePointerId) return;

				// Cancel delete timer if pointer moves (user is dragging, not long-pressing)
				if (curveDeleteTimer) {
					clearTimeout(curveDeleteTimer);
					curveDeleteTimer = null;
					curveDeleteTargetIndex = null;
				}

				if (draggingCurvePoint !== null) {
					const { x, y } = getCurveCanvasXY(e);
					const padding = 20;
					const drawWidth = curveCanvas.width - padding * 2;
					const drawHeight = curveCanvas.height - padding * 2;
					
					const normalizedX = Math.max(0, Math.min(1, (x - padding) / drawWidth));
					const normalizedY = Math.max(0, Math.min(1, 1.0 - (y - padding) / drawHeight));
					
					// Ensure first point is at x=0 and last at x=1
					if (draggingCurvePoint === 0) {
						curvePoints[0].x = 0;
					} else if (draggingCurvePoint === curvePoints.length - 1) {
						curvePoints[curvePoints.length - 1].x = 1;
					} else {
						curvePoints[draggingCurvePoint].x = normalizedX;
					}
					curvePoints[draggingCurvePoint].y = normalizedY;
					
					// Keep points sorted
					curvePoints.sort((a, b) => a.x - b.x);
					// Update dragging index after sort
					for (let i = 0; i < curvePoints.length; i++) {
						if (Math.abs(curvePoints[i].x - normalizedX) < 0.01 && 
							Math.abs(curvePoints[i].y - normalizedY) < 0.01) {
							draggingCurvePoint = i;
							break;
						}
					}
					
					drawCurveEditor();
				}
			}, { passive: false });

			curveCanvas.addEventListener("pointerup", (e) => {
				if (curveCanvasActivePointerId !== null && e.pointerId !== curveCanvasActivePointerId) return;
				try { curveCanvas.releasePointerCapture(curveCanvasActivePointerId); } catch {}
				curveCanvasActivePointerId = null;
				draggingCurvePoint = null;
				if (curveDeleteTimer) {
					clearTimeout(curveDeleteTimer);
					curveDeleteTimer = null;
					curveDeleteTargetIndex = null;
				}
			}, { passive: true });

			curveCanvas.addEventListener("pointercancel", (e) => {
				if (curveCanvasActivePointerId !== null && e.pointerId !== curveCanvasActivePointerId) return;
				try { curveCanvas.releasePointerCapture(curveCanvasActivePointerId); } catch {}
				curveCanvasActivePointerId = null;
				draggingCurvePoint = null;
				if (curveDeleteTimer) {
					clearTimeout(curveDeleteTimer);
					curveDeleteTimer = null;
					curveDeleteTargetIndex = null;
				}
			}, { passive: true });

			// Right-click to delete point
			curveCanvas.addEventListener("contextmenu", (e) => {
				e.preventDefault();
				if (curvePoints.length > 2) {
					const { x, y } = getCurveCanvasXY(e);
					const pointIndex = findClosestCurvePoint(x, y);
					if (pointIndex !== null && pointIndex !== 0 && pointIndex !== curvePoints.length - 1) {
						curvePoints.splice(pointIndex, 1);
						drawCurveEditor();
					}
				}
			});

			// Function to open curve editor
			function openGradientCurveEditor(attractorIndex) {
				currentEditingAttractorIndex = attractorIndex;
				const ar = attractorsRepulsors[attractorIndex];
				
				// Initialize curve points from stored control points or create default
				if (ar.gradientCurveControlPoints && Array.isArray(ar.gradientCurveControlPoints) && ar.gradientCurveControlPoints.length > 0) {
					// Load existing control points (make a copy to avoid reference issues)
					curvePoints = ar.gradientCurveControlPoints.map(p => ({ x: p.x, y: p.y }));
				} else {
					// Create default curve based on gradient mode
					if (ar.gradientMode === 'forward') {
						// Forward: strong at start, weak at end
						curvePoints = [
							{ x: 0, y: 1.0 },
							{ x: 1, y: 0.0 }
						];
					} else if (ar.gradientMode === 'backward') {
						// Backward: weak at start, strong at end
						curvePoints = [
							{ x: 0, y: 0.0 },
							{ x: 1, y: 1.0 }
						];
					} else {
						// Default: constant
						curvePoints = [
							{ x: 0, y: 1.0 },
							{ x: 1, y: 1.0 }
						];
					}
				}
				
				// Load temporal settings (with backward compatibility)
				const temporalMode = ar.temporalMode || 'none';
				const temporalFrequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
				const temporalAmplitude = ar.temporalAmplitude !== undefined ? ar.temporalAmplitude : 0.5;
				const shiftDirection = ar.shiftDirection || 'forward';
				
				// Update UI controls
				$("temporalModeSelect").value = temporalMode;
				$("temporalFrequencySlider").value = temporalFrequency;
				$("temporalFrequencyValue").textContent = temporalFrequency.toFixed(1) + " Hz";
				$("temporalAmplitudeSlider").value = temporalAmplitude;
				$("temporalAmplitudeValue").textContent = temporalAmplitude.toFixed(2);
				$("shiftDirectionSelect").value = shiftDirection;
				
				// Show/hide temporal controls based on mode
				updateTemporalControlsVisibility();
				
				// Ensure canvas is properly sized
				const rect = curveCanvas.getBoundingClientRect();
				if (curveCanvas.width !== 560 || curveCanvas.height !== 300) {
					curveCanvas.width = 560;
					curveCanvas.height = 300;
				}
				drawCurveEditor();
				$("gradientCurveBackdrop").style.display = "flex";
				startCurveEditorAnimation(); // Start preview animation
			}
			
			// Function to update temporal controls visibility
			function updateTemporalControlsVisibility() {
				const mode = $("temporalModeSelect").value;
				const temporalControls = $("temporalControls");
				const shiftDirectionDiv = $("shiftDirectionDiv");
				const temporalAmplitudeDiv = $("temporalAmplitudeDiv");
				
				if (mode === 'none') {
					temporalControls.style.display = 'none';
				} else {
					temporalControls.style.display = 'flex';
					if (mode === 'shift') {
						shiftDirectionDiv.style.display = 'flex';
					} else {
						shiftDirectionDiv.style.display = 'none';
					}
					// Hide amplitude for reverse mode (not used)
					if (mode === 'reverse') {
						temporalAmplitudeDiv.style.display = 'none';
					} else {
						temporalAmplitudeDiv.style.display = 'flex';
					}
				}
			}

			// Reset to linear (based on current gradient mode)
			$("gradientCurveResetBtn").onclick = () => {
				if (currentEditingAttractorIndex !== null) {
					const ar = attractorsRepulsors[currentEditingAttractorIndex];
					if (ar.gradientMode === 'forward') {
						curvePoints = [
							{ x: 0, y: 1.0 },
							{ x: 1, y: 0.0 }
						];
					} else if (ar.gradientMode === 'backward') {
						curvePoints = [
							{ x: 0, y: 0.0 },
							{ x: 1, y: 1.0 }
						];
					} else {
						curvePoints = [
							{ x: 0, y: 1.0 },
							{ x: 1, y: 1.0 }
						];
					}
					drawCurveEditor();
				}
			};

			// Set to constant (top)
			$("gradientCurveConstantBtn").onclick = () => {
				curvePoints = [
					{ x: 0, y: 1.0 },
					{ x: 1, y: 1.0 }
				];
				drawCurveEditor();
			};

			// Apply curve
			$("gradientCurveApplyBtn").onclick = () => {
				if (currentEditingAttractorIndex !== null) {
					const ar = attractorsRepulsors[currentEditingAttractorIndex];
					
					// Store the original control points (sorted)
					const sortedPoints = [...curvePoints].sort((a, b) => a.x - b.x);
					ar.gradientCurveControlPoints = sortedPoints.map(p => ({ x: p.x, y: p.y }));
					
					// Also create sampled curve for physics calculations
					const curve = [];
					for (let i = 0; i < CURVE_RESOLUTION; i++) {
						const pos = i / (CURVE_RESOLUTION - 1);
						curve.push(getCurveValue(sortedPoints, pos));
					}
					ar.gradientCurve = curve;
					
					// Store temporal settings
					ar.temporalMode = $("temporalModeSelect").value;
					ar.temporalFrequency = parseFloat($("temporalFrequencySlider").value);
					ar.temporalAmplitude = parseFloat($("temporalAmplitudeSlider").value);
					ar.shiftDirection = $("shiftDirectionSelect").value;
					
					history.push({ type: "attractorRepulsor" });
					toast("Gradient curve updated", 1500);
					
					stopCurveEditorAnimation();
					$("gradientCurveBackdrop").style.display = "none";
					currentEditingAttractorIndex = null;
				}
			};
			
			// Temporal controls event handlers
			$("temporalModeSelect").addEventListener("change", () => {
				updateTemporalControlsVisibility();
				drawCurveEditor(); // Redraw to show/hide preview
				startCurveEditorAnimation(); // Restart animation if needed
			});
			
			$("temporalFrequencySlider").addEventListener("input", (e) => {
				$("temporalFrequencyValue").textContent = parseFloat(e.target.value).toFixed(1) + " Hz";
				drawCurveEditor(); // Redraw to update preview
			});
			
			$("temporalAmplitudeSlider").addEventListener("input", (e) => {
				$("temporalAmplitudeValue").textContent = parseFloat(e.target.value).toFixed(2);
				drawCurveEditor(); // Redraw to update preview
			});
			
			$("shiftDirectionSelect").addEventListener("change", () => {
				drawCurveEditor(); // Redraw to update preview
			});
			
			// Animation loop for temporal preview
			let curveEditorAnimationId = null;
			function startCurveEditorAnimation() {
				if (curveEditorAnimationId) {
					cancelAnimationFrame(curveEditorAnimationId);
					curveEditorAnimationId = null;
				}
				
				function animate() {
					const backdrop = $("gradientCurveBackdrop");
					if (backdrop && backdrop.style.display === "flex") {
						const temporalMode = $("temporalModeSelect").value;
						if (temporalMode !== 'none') {
							drawCurveEditor(); // Redraw with updated time
							curveEditorAnimationId = requestAnimationFrame(animate);
						} else {
							curveEditorAnimationId = null;
						}
					} else {
						curveEditorAnimationId = null;
					}
				}
				animate();
			}
			
			function stopCurveEditorAnimation() {
				if (curveEditorAnimationId) {
					cancelAnimationFrame(curveEditorAnimationId);
					curveEditorAnimationId = null;
				}
			}

			// Cancel
			$("gradientCurveCancelBtn").onclick = () => {
				stopCurveEditorAnimation();
				$("gradientCurveBackdrop").style.display = "none";
				currentEditingAttractorIndex = null;
			};

			// Close dialog on backdrop click
			$("gradientCurveBackdrop").addEventListener("click", (e) => {
				if (e.target.id === "gradientCurveBackdrop") {
					stopCurveEditorAnimation();
					$("gradientCurveBackdrop").style.display = "none";
					currentEditingAttractorIndex = null;
				}
			});

			$("iconGravity").addEventListener("click", () => {
  gravityEnabled = !gravityEnabled;
  $("iconGravity").classList.toggle("icon-active", gravityEnabled);
  if (gravityEnabled) SFX.gravityOn(); else SFX.gravityOff();
  toast(gravityEnabled ? "Gravity ON" : "Gravity OFF");
});

// Optional keyboard shortcut: G
window.addEventListener("keydown", (e) => {
  if (e.key === "g" || e.key === "G") $("iconGravity").click();
});

			/* -----------------------------------
			   DRAW MODE ICONS
			----------------------------------- */
			$("iconBlob").onclick = () => setDrawMode('blob');
			$("iconLine").onclick   = () => setDrawMode("line");
			$("iconCircle").onclick = () => setDrawMode("circle");

			// Particle emitter icon — show settings dialog
			$("iconParticle").onclick = () => {
				// If already in particle mode, toggle off
				if (drawMode === "particle") {
					setDrawMode("particle"); // toggles off
					return;
				}
				// Show settings dialog
				$("particleEmitRate").value = particleEmitRate;
				$("particleRenderSize").value = particleRenderSize;
				$("particleSettingsBackdrop").style.display = "flex";
			};

			$("particleSettingsApply").onclick = () => {
				particleEmitRate = Math.max(1, Math.min(100,
					parseInt($("particleEmitRate").value, 10) || 10));
				particleRenderSize = Math.max(1, Math.min(30,
					parseFloat($("particleRenderSize").value) || 4));
				$("particleSettingsBackdrop").style.display = "none";
				setDrawMode("particle");
			};

			$("particleSettingsCancel").onclick = () => {
				$("particleSettingsBackdrop").style.display = "none";
			};

			// Close particle dialog on backdrop click
			{
				const pBackdrop = $("particleSettingsBackdrop");
				if (pBackdrop) {
					pBackdrop.onclick = (e) => {
						if (e.target === pBackdrop) {
							pBackdrop.style.display = "none";
						}
					};
				}
			}

			// Attractor/Repulsor dialog handlers (handles both new drawing and conversion)
			$("attractorBtn").onclick = () => {
				$("attractorRepulsorBackdrop").style.display = "none";

				// If converting a chain, convert it to attractor
				if (chainToConvertIndex !== null && chainToConvertIndex < chains.length) {
					const chain = chains[chainToConvertIndex];
					// Convert chain path to attractor/repulsor path format
					const path = chain.chain.map(dot => ({ x: dot.x, y: dot.y }));

					attractorsRepulsors.push({
						path: path,
						type: "attractor",
						gradientMode: null, // null, 'forward', or 'backward'
						gradientCurve: null,
						gradientCurveControlPoints: null,
						temporalMode: 'none',
						temporalFrequency: 1.0,
						temporalAmplitude: 0.5,
						shiftDirection: 'forward'
					});

					// Remove the original chain
					chains.splice(chainToConvertIndex, 1);
					history.push({ type: "attractorRepulsor" });
					chainToConvertIndex = null;
					toast("Converted to Attractor", 1500);
				} else {
					// Normal drawing mode
					attractorRepulsorType = "attractor";
					setDrawMode("attractor");
				}
			};

			$("repulsorBtn").onclick = () => {
				$("attractorRepulsorBackdrop").style.display = "none";

				// If converting a chain, convert it to repulsor
				if (chainToConvertIndex !== null && chainToConvertIndex < chains.length) {
					const chain = chains[chainToConvertIndex];
					// Convert chain path to attractor/repulsor path format
					const path = chain.chain.map(dot => ({ x: dot.x, y: dot.y }));

					attractorsRepulsors.push({
						path: path,
						type: "repulsor",
						gradientMode: null, // null, 'forward', or 'backward'
						gradientCurve: null,
						gradientCurveControlPoints: null,
						temporalMode: 'none',
						temporalFrequency: 1.0,
						temporalAmplitude: 0.5,
						shiftDirection: 'forward'
					});

					// Remove the original chain
					chains.splice(chainToConvertIndex, 1);
					history.push({ type: "attractorRepulsor" });
					chainToConvertIndex = null;
					toast("Converted to Repulsor", 1500);
				} else {
					// Normal drawing mode
					attractorRepulsorType = "repulsor";
					setDrawMode("repulsor");
				}
			};

			// Attractor/Repulsor icon - show dialog to choose type
			$("iconAttractorRepulsor").onclick = () => {
				chainToConvertIndex = null; // Clear any pending conversion
				const backdrop = $("attractorRepulsorBackdrop");
				if (backdrop) {
					backdrop.style.display = "flex";
				}
			};

			$("attractorRepulsorCancelBtn").onclick = () => {
				$("attractorRepulsorBackdrop").style.display = "none";
				chainToConvertIndex = null; // Clear pending conversion
			};

			// Close dialog on backdrop click
			{
				const arBackdrop = $("attractorRepulsorBackdrop");
				if (arBackdrop) {
					arBackdrop.onclick = (e) => {
						if (e.target === arBackdrop) {
							arBackdrop.style.display = "none";
						}
					};
				}
			}

			/* -----------------------------------
			   UPDATE CANVAS CURSOR
			----------------------------------- */
			function updateCanvasCursor() {
				canvas.classList.remove(
					"canvas-blob-mode",
					"canvas-line-mode",
					"canvas-circle-mode",
					"canvas-particle-mode",
					"canvas-attractor-mode",
					"canvas-repulsor-mode",
					"canvas-drag-mode",
					"canvas-pin-mode",
					"canvas-slicing-mode",
					"canvas-freeze-mode",
					"canvas-delete-mode"
				);
				// Draw mode
				if (drawMode === 'blob') canvas.classList.add("canvas-blob-mode");
				if (drawMode === 'line') canvas.classList.add("canvas-line-mode");
				if (drawMode === 'circle') canvas.classList.add("canvas-circle-mode");
				if (drawMode === 'particle') canvas.classList.add("canvas-particle-mode");
				if (drawMode === 'attractor') canvas.classList.add("canvas-attractor-mode");
				if (drawMode === 'repulsor') canvas.classList.add("canvas-repulsor-mode");

				// Edit tools
				if (slicingMode) canvas.classList.add("canvas-slicing-mode");
				if (dragMode) canvas.classList.add("canvas-drag-mode");
				if (pinMode) canvas.classList.add("canvas-pin-mode");
				if (freezeMode) canvas.classList.add("canvas-freeze-mode");
				if (deleteMode) canvas.classList.add("canvas-delete-mode");
			}

			/* -----------------------------------
			   FILE MENU LOGIC (SAVE/LOAD)
			----------------------------------- */
			function getCurrentSettings() {
			    return {
			        timeStep,
			        springConstant,
			        repulsionConstant,
			        damping,
			        dotScaleFactor,
			        currentLineThickness,
			        globalRadiusAvg,
			        globalRadiusVar,
			        colorValue: colorInput.value,
			        turgorPressure,      // NEW: 0..1
			        // Appearance settings
			        showOutline,
			        showFilled,
			        outlineWidth,
			        canvasBackgroundColor,
			        showGrid,
			        travelingSegmentEnabled,
			        travelingSegmentLength,
			        travelingSegmentSpeed
			    };
			}


			function applySettings(obj) {
				if (typeof obj.timeStep === "number") {
					timeStep = obj.timeStep;
					$("timeStepSlider").value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
					$("timeStepValue").textContent = $("timeStepSlider").value + "%";
				}
				if (typeof obj.springConstant === "number") {
					springConstant = obj.springConstant;
					$("springConstantSlider").value = springConstant * 100;
					$("springConstantValue").textContent = $("springConstantSlider").value + "%";
				}
				if (typeof obj.repulsionConstant === "number") {
					repulsionConstant = obj.repulsionConstant;
					$("repulsionConstantSlider").value = repulsionConstant * 200;
					$("repulsionConstantValue").textContent = $("repulsionConstantSlider").value + "%";
				}
				if (typeof obj.damping === "number") {
					damping = obj.damping;
					$("dampingSlider").value = damping * 100;
					$("dampingValue").textContent = $("dampingSlider").value + "%";
				}
				if (typeof obj.dotScaleFactor === "number") {
					dotScaleFactor = obj.dotScaleFactor;
					$("dotScaleSlider").value = ((dotScaleFactor - 0.1) / (5 - 0.1)) * 100;
					$("dotScaleValue").textContent = $("dotScaleSlider").value + "%";
				}
				if (typeof obj.currentLineThickness === "number") {
					currentLineThickness = obj.currentLineThickness;
					$("iconThickness").title = (currentLineThickness === 1) ?
						"Line Thickness: Thin" :
						"Line Thickness: Thick";
					$("iconThickness").style.fontWeight = (currentLineThickness === 5) ? "bold" : "normal";
					$("iconThickness").style.backgroundColor = (currentLineThickness === 5) ? "#D3D3D3" : "";
					toggleActiveIcon($("iconThickness"), currentLineThickness > 1);
				}
				if (typeof obj.globalRadiusAvg === "number") {
					globalRadiusAvg = obj.globalRadiusAvg;
					$("radiusAvgInput").value = obj.globalRadiusAvg;
				}
				if (typeof obj.globalRadiusVar === "number") {
					globalRadiusVar = obj.globalRadiusVar;
					$("radiusVarInput").value = obj.globalRadiusVar;
				}
				if (typeof obj.colorValue === "string") {
					colorInput.value = obj.colorValue;
				}
				if (typeof obj.turgorPressure === "number") {
			    // clamp just in case incoming JSON is slightly out of range
			    turgorPressure = Math.max(0, Math.min(1, obj.turgorPressure));

			    const s = $("turgorPressureSlider");
			    const v = $("turgorPressureValue");

			    if (s && v) {
			        s.value = Math.round(turgorPressure * 100);
			        v.textContent = s.value + "%";
			    }
			}

			// Appearance settings
			if (typeof obj.showOutline === "boolean") {
				showOutline = obj.showOutline;
			}
			if (typeof obj.showFilled === "boolean") {
				showFilled = obj.showFilled;
			}
			if (typeof obj.outlineWidth === "number") {
				outlineWidth = obj.outlineWidth;
				currentLineThickness = outlineWidth;
			}
			if (obj.canvasBackgroundColor && Array.isArray(obj.canvasBackgroundColor) && obj.canvasBackgroundColor.length >= 3) {
				canvasBackgroundColor = obj.canvasBackgroundColor.slice(0, 4); // Ensure we have rgba
				if (canvasBackgroundColor.length === 3) canvasBackgroundColor.push(1.0); // Add alpha if missing
				gl.clearColor(canvasBackgroundColor[0], canvasBackgroundColor[1], canvasBackgroundColor[2], canvasBackgroundColor[3]);
				updateTextColorsForBackground();
			}
			if (typeof obj.showGrid === "boolean") {
				showGrid = obj.showGrid;
			}
			if (typeof obj.travelingSegmentEnabled === "boolean") {
				travelingSegmentEnabled = obj.travelingSegmentEnabled;
			}
			if (typeof obj.travelingSegmentLength === "number") {
				travelingSegmentLength = obj.travelingSegmentLength;
			}
			if (typeof obj.travelingSegmentSpeed === "number") {
				travelingSegmentSpeed = obj.travelingSegmentSpeed;
			}

			}

			function downloadJSON(filename, dataObj) {
				const dataStr = JSON.stringify(dataObj, null, 2);
				const blob = new Blob([dataStr], { type: "application/json" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = filename;
				link.click();
				URL.revokeObjectURL(url);
			}

			/* ---------- SAVE ---------- */
			$("saveBlobsOption").onclick = e => {
				e.stopPropagation();
				$("fileSubmenu").style.display = "none";
				$("saveOptionsBackdrop").style.display = "flex";
			};
			$("cancelSaveBtn").onclick = () =>
				$("saveOptionsBackdrop").style.display = "none";

			$("confirmSaveBtn").onclick = () => {
				const payload = {};
				if ($("saveIncludeChains").checked) payload.chains = chains;
				if ($("saveIncludeCircles").checked) payload.circles = circles;
				if ($("saveIncludeSettings").checked) payload.settings = getCurrentSettings();
				// Always include attractors/repulsors if they exist
				if (attractorsRepulsors.length > 0) {
					payload.attractorsRepulsors = attractorsRepulsors;
				}
				downloadJSON("blobs.json", payload);
				$("saveOptionsBackdrop").style.display = "none";
			};

			/* ---------- IMPORT (file ➜ dialog) ---------- */
			let pendingImport = null; // temp storage

			$("loadBlobsOption").onclick = e => {
				e.stopPropagation();
				$("fileSubmenu").style.display = "none";





				const fi = document.createElement("input");
				fi.type = "file";
				fi.accept = ".json,application/json"; // broader accept

				fi.style.display = "none";
				document.body.appendChild(fi);

				fi.onchange = ev => {
					const file = ev.target.files && ev.target.files[0];
					if (!file) { fi.remove(); return; }

					const reader = new FileReader();
					reader.onload = evt => {
						try {
							pendingImport = JSON.parse(evt.target.result);
							$("importIncludeChains").disabled = !pendingImport.chains;
							$("importIncludeCircles").disabled = !pendingImport.circles;
							$("importIncludeSettings").disabled = !pendingImport.settings;
							$("importIncludeChains").checked = !!pendingImport.chains;
							$("importIncludeCircles").checked = !!pendingImport.circles;
							$("importIncludeSettings").checked = !!pendingImport.settings;
							// Note: attractors/repulsors are always imported if present
							$("importOptionsBackdrop").style.display = "flex";
							$("importOptionsBackdrop").style.pointerEvents = "auto";
						} catch {
							alert("Error parsing JSON file!");
						} finally {
							fi.remove(); // clean up
						}
					};
					reader.readAsText(file);
				};

				fi.value = ""; // lets you import the same file twice
				fi.click();
			};

			/* user clicks Import / Cancel */
			$("confirmImportBtn").onclick = () => {
				if (!pendingImport) return;

				// Close NOW so iPad can paint the hide
				const b = $("importOptionsBackdrop");
				if (b) {
					b.style.display = "none";
					b.style.pointerEvents = "none"; // prevents any “ghost” hitbox
					void document.body.offsetHeight; // iOS paint nudge
				}

				// Defer heavy import/physics so the hide actually commits
				setTimeout(() => {
					try {
						if ($("importIncludeChains")?.checked && pendingImport.chains)
							pendingImport.chains.forEach(c => chains.push(c));

						if ($("importIncludeCircles")?.checked && pendingImport.circles)
							pendingImport.circles.forEach(c => circles.push(c));

						if ($("importIncludeSettings")?.checked && pendingImport.settings) {
							try { applySettings(pendingImport.settings); } catch (e) { console.warn(e); }
						}

						// Always import attractors/repulsors if present
						if (pendingImport.attractorsRepulsors && Array.isArray(pendingImport.attractorsRepulsors)) {
							attractorsRepulsors.length = 0; // Clear existing
							pendingImport.attractorsRepulsors.forEach(ar => {
								// Ensure gradientMode exists for backward compatibility
								if (ar.gradientMode === undefined) {
									ar.gradientMode = null;
								}
								// Ensure gradientCurve exists for backward compatibility
								if (ar.gradientCurve === undefined) {
									ar.gradientCurve = null;
								}
								// Ensure gradientCurveControlPoints exists for backward compatibility
								if (ar.gradientCurveControlPoints === undefined) {
									ar.gradientCurveControlPoints = null;
								}
								// Ensure temporal properties exist for backward compatibility
								if (ar.temporalMode === undefined) {
									ar.temporalMode = 'none';
								}
								if (ar.temporalFrequency === undefined) {
									ar.temporalFrequency = 1.0;
								}
								if (ar.temporalAmplitude === undefined) {
									ar.temporalAmplitude = 0.5;
								}
								if (ar.shiftDirection === undefined) {
									ar.shiftDirection = 'forward';
								}
								attractorsRepulsors.push(ar);
							});
						}

						if ($("importIncludePhysics")?.checked) {
							applyImportedPhysics?.(pendingImport) ?? startPhysicsFromImport?.(pendingImport);
						}
					} finally {
						pendingImport = null;
					}
				}, 0);
			};
			$("cancelImportBtn").onclick = () => {
				pendingImport = null;
				$("importOptionsBackdrop").style.display = "none";
			};

			/* ---------- PRESENTATION MODE ---------- */
			let isPresentationMode = false;

			$("presentationModeOption").onclick = e => {
				e.stopPropagation();
				$("fileSubmenu").style.display = "none";
				togglePresentationMode();
			};

			function togglePresentationMode() {
				isPresentationMode = !isPresentationMode;
				const body = document.body;
				const instruction = $("presentationModeInstruction");
				const exitBtn = $("presentationExitBtn");

				if (isPresentationMode) {
					body.classList.add("presentation-mode");

					// Update instruction text for iPad (no ESC key)
					if (instruction) {
						instruction.textContent = _isIPad
							? "Triple-tap to exit Presentation Mode"
							: "Press ESC to exit Presentation Mode";
						instruction.classList.add("showing");
						instruction.style.display = "block";
					}

					// Show the X exit button on iPad
					if (exitBtn && _isIPad) {
						exitBtn.classList.add("showing");
					}

					// Auto-hide the instruction after 3 seconds
					setTimeout(() => {
						if (instruction) {
							instruction.classList.remove("showing");
							instruction.style.display = "none";
						}
					}, 3000);
				} else {
					body.classList.remove("presentation-mode");
					if (instruction) {
						instruction.classList.remove("showing");
						instruction.style.display = "none";
					}
					if (exitBtn) {
						exitBtn.classList.remove("showing");
					}
					toast("Presentation Mode OFF", 1500);
				}
			}

			// Exit button click handler (iPad)
			$("presentationExitBtn").onclick = () => {
				if (isPresentationMode) togglePresentationMode();
			};

			// Triple-tap on canvas to exit presentation mode (iPad)
			{
				let _presTapCount = 0;
				let _presTapTimer = null;
				const TRIPLE_TAP_WINDOW = 500; // ms – all 3 taps must happen within this window

				canvas.addEventListener("pointerup", (e) => {
					if (!isPresentationMode || !_isIPad) return;
					// Only count quick taps (not drags) — ignore if pointer moved far
					_presTapCount++;
					if (_presTapCount === 1) {
						_presTapTimer = setTimeout(() => { _presTapCount = 0; }, TRIPLE_TAP_WINDOW);
					}
					if (_presTapCount >= 3) {
						clearTimeout(_presTapTimer);
						_presTapCount = 0;
						togglePresentationMode();
					}
				});
			}

			// Allow ESC key to exit presentation mode
			document.addEventListener("keydown", (e) => {
				if (e.key === "Escape" && isPresentationMode) {
					togglePresentationMode();
				}
				// Track shift key for straight line drawing
				if (e.key === "Shift") {
					shiftKeyHeld = true;
					// If already drawing, update the start point
					if (isDrawing && !straightLineStart) {
						straightLineStart = { x: currentMouseX, y: currentMouseY };
					}
				}
			});

			document.addEventListener("keyup", (e) => {
				// Release shift key tracking
				if (e.key === "Shift") {
					shiftKeyHeld = false;
					straightLineStart = null;
				}
			});

			/* -----------------------------------
			   PARTICLE EMITTER HELPERS
			----------------------------------- */
			function emitParticle(x, y) {
				SFX.particleEmit();
				// Add slight random spread around the cursor position
				const spread = 3;
				const px = x + (Math.random() - 0.5) * spread;
				const py = y + (Math.random() - 0.5) * spread;

				// Give a small random initial velocity for organic feel
				const vSpread = 0.3;
				const vx = (Math.random() - 0.5) * vSpread;
				const vy = (Math.random() - 0.5) * vSpread;

				const chosenColor = hexToRGBA(colorInput.value);

				// Each particle is a single-vertex chain marked as a particle
				chains.push({
					chain: [{ x: px, y: py, vx, vy, pinned: false }],
					color: chosenColor,
					baseDotRadius: particleRenderSize * 1.15,
					isClosed: false,
					frozen: false,
					isParticle: true,
					particleRenderSize: particleRenderSize
				});
				history.push({ type: "chain" });
			}

			function startParticleEmission() {
				if (particleEmitting) return;
				particleEmitting = true;

				// Emit one immediately
				emitParticle(currentMouseX, currentMouseY);

				// Then emit at the configured rate
				const intervalMs = Math.max(10, 1000 / particleEmitRate);
				particleEmitTimer = setInterval(() => {
					if (particleEmitting) {
						emitParticle(currentMouseX, currentMouseY);
					}
				}, intervalMs);
			}

			function stopParticleEmission() {
				particleEmitting = false;
				if (particleEmitTimer) {
					clearInterval(particleEmitTimer);
					particleEmitTimer = null;
				}
			}

			/* -----------------------------------
			   MOUSE EVENTS & DRAWING
			----------------------------------- */
			let currentPathPoints = [];
			let currentAttractorRepulsorPath = []; // For drawing attractor/repulsor paths
			let currentMouseX = 0,
				currentMouseY = 0;

			const dotSlider = $("dotScaleSlider");

			/* Wheel on canvas */
			canvas.addEventListener("wheel", handleDotWheel, { passive: false });
			/* Wheel directly on the slider (nice for trackpads) */
			dotSlider.addEventListener("wheel", handleDotWheel, { passive: false });

			function handleDotWheel(e) {
				e.preventDefault(); // stop page scroll
				const delta = e.deltaY; // +120, −120, etc.
				const current = parseFloat(dotSlider.value);
				const next = current - delta * DOT_SCROLL_STEP;
				setDotScale(next);
				SFX.scrollTick();
			}

			canvas.addEventListener("mousemove", e => {
				const rect = canvas.getBoundingClientRect();
				currentMouseX = e.clientX - rect.left;
				currentMouseY = e.clientY - rect.top;

				// PERFORMANCE: Don't add vertices here - pointermove already handles this
				// Having both causes duplicate vertex creation in Chrome
				// The pointermove handler (line 3249) already handles blob/line drawing

				// If resizing a new circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					const r = Math.sqrt(
						(currentMouseX - currentCircle.x) ** 2 +
						(currentMouseY - currentCircle.y) ** 2
					);
					currentCircle.radius = r;
					SFX.circleResize(r);

					circleInfo.textContent = "r: " + Math.round(r);
					circleInfo.style.left = (e.clientX + 14) + "px";
					circleInfo.style.top = (e.clientY + 18) + "px";
					circleInfo.style.display = "block";
				} else {
					circleInfo.style.display = "none";
				}

				// If dragging an existing circle
				if ((dragMode || drawMode === "none") && draggingCircleIndex !== null) {
				  circles[draggingCircleIndex].x = currentMouseX;
				  circles[draggingCircleIndex].y = currentMouseY;
				}


				// Highlight nearest dot if pinMode/dragMode
				if ((pinMode || dragMode) && (e.movementX || e.movementY)) {
					pinHoverChainIndex = null;
					pinHoverDotIndex = null;

					let bestDist = Infinity;
					const hoverRad = 20; // hover radius in px

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = currentMouseX - dot.x;
							const dy = currentMouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < hoverRad && dist < bestDist) {
								bestDist = dist;
								pinHoverChainIndex = c;
								pinHoverDotIndex = i;
							}
						}
					}
				}

			});

			function polygonArea(points) {
				let sum = 0;
				for (let i = 0; i < points.length; i++) {
					const j = (i + 1) % points.length;
					sum += points[i].x * points[j].y -
						points[j].x * points[i].y;
				}
				return Math.abs(sum) / 2;
			}

			function measurePerimeterArea(pts, isClosed=true) {
  const N = pts.length;
  if (N < 2) return { L: 0, A: 0 };
  let L = 0, twiceA = 0;
  const M = isClosed ? N : N - 1;
  for (let i = 0; i < M; i++) {
    const j = (i + 1) % N;
    const ex = pts[j].x - pts[i].x;
    const ey = pts[j].y - pts[i].y;
    L += Math.hypot(ex, ey);
    twiceA += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
  }
  return { L, A: 0.5 * twiceA };
}

			/**
			 * Ray-casting test for point-in-polygon
			 */
			function pointInPolygon(px, py, polygon) {
				if (!polygon || !Array.isArray(polygon) || polygon.length < 3) return false;
				let inside = false;
				for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
					const xi = polygon[i].x,
						yi = polygon[i].y;
					const xj = polygon[j].x,
						yj = polygon[j].y;
					const intersect = ((yi > py) !== (yj > py)) &&
						(px < (xj - xi) * (py - yi) / (yj - yi) + xi);
					if (intersect) inside = !inside;
				}
				return inside;
			}

			canvas.addEventListener("mousedown", e => {
				if (e.button !== 0) return;
				const rect = canvas.getBoundingClientRect();
				const mouseX = e.clientX - rect.left;
				const mouseY = e.clientY - rect.top;

				if (dragMode && drawMode !== "circle") {
					for (let i = 0; i < circles.length; i++) {
						const c = circles[i],
							dx = mouseX - c.x,
							dy = mouseY - c.y;
						if (Math.hypot(dx, dy) < c.radius + 5) { // inside any circle?
							toast("Hint: turn Circle draw mode ON to move circles.",
								3000);
							break;
						}
					}
				}

				// Circle creation or circle dragging
				if (drawMode === 'circle') {
					if (dragMode) {
						// If we're in dragMode AND circle draw mode, we only do circle dragging:
						// (Try to pick up an existing circle but do NOT create a new one)
						for (let i = 0; i < circles.length; i++) {
							const c = circles[i];
							const dx = mouseX - c.x;
							const dy = mouseY - c.y;
							if (Math.sqrt(dx * dx + dy * dy) < c.radius + 5) {
								draggingCircleIndex = i;
								return;
							}
						}

						// If we didn’t find a circle to drag, just return without creating one:
						return;

					} else {
						// Otherwise (dragMode is OFF), start a new circle
						isCircleDrawing = true;
						currentCircle = { x: mouseX, y: mouseY, radius: 0 };
						return;
					}
				}

				// Slicing mode
				if (slicingMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const sliceRadius = 15;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = mouseX - dot.x;
							const dy = mouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < sliceRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const ch = chains[bestChainIndex].chain;
						if (bestDotIndex > 0 && bestDotIndex < ch.length - 1) {
							const firstHalf = ch.slice(0, bestDotIndex);
							const secondHalf = ch.slice(bestDotIndex);
							chains[bestChainIndex].chain = firstHalf;
							chains.push({
								...chains[bestChainIndex],
								chain: secondHalf
							});
							history.push({ type: "chain" });
							SFX.slice();
						}
					}
					return;
				}

				// Freeze mode
				if (freezeMode) {
					// 1) find all blobs under the mouse
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						const ch = chains[i];
						if (!ch.isClosed) continue;
						if (pointInPolygon(mouseX, mouseY, ch.chain)) {
							hits.push(i);
						}
					}

					if (hits.length) {
						// 2) pick the smallest one
						let bestIndex = hits[0];
						let bestArea = polygonArea(chains[bestIndex].chain);

						for (let k = 1; k < hits.length; k++) {
							const idx = hits[k];
							const area = polygonArea(chains[idx].chain);
							if (area < bestArea) {
								bestArea = area;
								bestIndex = idx;
							}
						}

						// 3) toggle only that blob
						chains[bestIndex].frozen = !chains[bestIndex].frozen;
						chains[bestIndex].alpha = chains[bestIndex].frozen ? 0.3 : 1.0;
					}
					return;
				}
				// ----- DELETE MODE: remove the smallest blob under cursor -----
				if (deleteMode) {

					/* a) test circles first */
					for (let i = 0; i < circles.length; i++) {
						const c = circles[i],
							dx = mouseX - c.x,
							dy = mouseY - c.y;
						if (Math.hypot(dx, dy) < c.radius) {
							circles.splice(i, 1);
							history.push({ type: "circle" });
							return;
						}
					}

					/* b) test open lines: nearest segment within 6 px */
					const SEG_TOL = 6;
					for (let k = 0; k < chains.length; k++) {
						const obj = chains[k];
						if (obj.isClosed) continue; // skip blobs (do later)
						const pts = obj.chain;
						for (let i = 0; i < pts.length - 1; i++) {
							const a = pts[i],
								b = pts[i + 1];
							const t = ((mouseX - a.x) * (b.x - a.x) + (mouseY - a.y) * (b.y - a.y)) /
								((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
							const clamped = Math.max(0, Math.min(1, t));
							const px = a.x + clamped * (b.x - a.x);
							const py = a.y + clamped * (b.y - a.y);
							if (Math.hypot(mouseX - px, mouseY - py) < SEG_TOL) {
								chains.splice(k, 1);
								history.push({ type: "chain" });
								return;
							}
						}
					}

					/* c) fall back to old “blob” logic (smallest closed shape) */
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						if (!chains[i].isClosed) continue;
						if (pointInPolygon(mouseX, mouseY, chains[i].chain)) hits.push(i);
					}
					if (hits.length) {
						let best = hits[0],
							bestArea = polygonArea(chains[best].chain);
						for (let j = 1; j < hits.length; j++) {
							const area = polygonArea(chains[hits[j]].chain);
							if (area < bestArea) {
								best = hits[j];
								bestArea = area;
							}
						}
						chains.splice(best, 1);
						history.push({ type: "chain" });
					}
					return;
				}
				// Pin mode
				if (pinMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = mouseX - dot.x;
							const dy = mouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < pickRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const dot = chains[bestChainIndex].chain[bestDotIndex];
						dot.pinned = !dot.pinned;
						SFX.pin();
						return;
					}
					return;
				}

				const wantDrag = (dragMode || drawMode === "none");

	if (wantDrag) {
	  // 1) Prefer dragging blob dots first
	  let bestChainIndex = null;
	  let bestDotIndex = null;
	  let bestDist = Infinity;
	  const pickRadius = 20;

	  for (let c = 0; c < chains.length; c++) {
	    const ch = chains[c].chain;
	    for (let i = 0; i < ch.length; i++) {
	      const dot = ch[i];
	      const dx = mouseX - dot.x;
	      const dy = mouseY - dot.y;
	      const dist = Math.sqrt(dx * dx + dy * dy);
	      if (dist < pickRadius && dist < bestDist) {
	        bestDist = dist;
	        bestChainIndex = c;
	        bestDotIndex = i;
	      }
	    }
	  }

	  if (bestChainIndex !== null) {
	    draggingChainIndex = bestChainIndex;
	    draggingDotIndex = bestDotIndex;
	    return;
	  }

	  // 2) Only if no blob dot was hit, allow circle dragging
	  const circlePad = 3; // was effectively 5; smaller reduces accidental grabs
	  const ci = pickCircleIndex(mouseX, mouseY, circlePad);
	  if (ci !== null) {
	    draggingCircleIndex = ci;
	    return;
	  }
	}


				// Otherwise, if in blob or line mode, start freehand
				if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
					isDrawing = true;
					currentPathPoints = [{
						x: mouseX,
						y: mouseY,
						vx: 0,
						vy: 0,
						pinned: false
					}];
				}
			});

			window.addEventListener("mouseup", e => {
				if (e.button !== 0) return;

				// Finalize circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					if (currentCircle.radius > 5) {
						circles.push(currentCircle);
						history.push({ type: "circle" });
						SFX.circleComplete();
					}
					isCircleDrawing = false;
					currentCircle = null;
					draggingCircleIndex = null;

					circleInfo.style.display = "none"; // ← hide the live radius overlay
					return;
				}

				// Finalize blob/line
				if (isDrawing && currentPathPoints.length > 2 && (drawMode === 'blob' || drawMode === 'line')) {
					let r = globalRadiusAvg + (Math.random() * 2 - 1) * globalRadiusVar;
					if (r < 1) r = 1;
					const chosenColor = hexToRGBA(colorInput.value);

					const isClosed = (drawMode === 'blob');
					if (isClosed) {
						// close shape
						const f = currentPathPoints[0];
						currentPathPoints.push({ ...f });
						SFX.blobComplete(colorInput.value);
					} else {
						SFX.lineComplete();
					}

					// NEW: initialize reference geometry for turgor controller
				   const { L, A } = measurePerimeterArea(currentPathPoints, isClosed);
				   const _L0 = Math.max(L, 1e-6);
				   const _A0 = Math.max(Math.abs(A), 1e-6);


					chains.push({
						chain: currentPathPoints.slice(),
						color: chosenColor,
						baseDotRadius: r,
						isClosed,
						_L0,
						_A0,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				// End all "mouseDown" states
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
			});

			window.addEventListener("mouseleave", () => {
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
			});

			/* -----------------------------------
			   SHADERS & PROGRAM
			----------------------------------- */
			function compileShader(type, src) {
				const s = gl.createShader(type);
				gl.shaderSource(s, src);
				gl.compileShader(s);
				if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
					console.error("Shader compile error:", gl.getShaderInfoLog(s));
					gl.deleteShader(s);
					return null;
				}
				return s;
			}

			function createProgram(vsSrc, fsSrc) {
				// Don't modify shaders - compile them as-is
				// WebGL 1.0 shaders should not have #version directive
				// WebGL 2.0 shaders should already have #version 300 es
				const vs = vsSrc;
				const fs = fsSrc;

				const vsShader = compileShader(gl.VERTEX_SHADER, vs);
				const fsShader = compileShader(gl.FRAGMENT_SHADER, fs);

				if (!vsShader || !fsShader) {
					console.error("Shader compilation failed - vertex:", vsShader ? "OK" : "FAIL", "fragment:", fsShader ? "OK" : "FAIL");
					return null;
				}

				const p = gl.createProgram();
				gl.attachShader(p, vsShader);
				gl.attachShader(p, fsShader);
				gl.linkProgram(p);
				if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
					console.error("Program link error:", gl.getProgramInfoLog(p));
					return null;
				}
				return p;
			}
			const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    void main(){
      vec2 clipSpace = (a_position / u_resolution)*2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace,0,1);
    }
  `;
			const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main(){
      gl_FragColor = u_color;
    }
  `;
			const lineProgram = createProgram(vsSource, fsSource);
			const linePosLoc = gl.getAttribLocation(lineProgram, "a_position");
			const lineResLoc = gl.getUniformLocation(lineProgram, "u_resolution");
			const lineColorLoc = gl.getUniformLocation(lineProgram, "u_color");
			const positionBuffer = gl.createBuffer();
			let thickScratch = new Float32Array(0);

			/* -----------------------------------
			   INSTANCED PARTICLE RENDERING (WebGL 2.0)
			   Draws ALL particles in a single instanced draw call
			   instead of one draw call per particle.
			----------------------------------- */
			const PARTICLE_SEG = 12;
			// Pre-compute unit circle as TRIANGLES (shared geometry)
			const _particleUnitCircle = [];
			for (let _pi = 0; _pi < PARTICLE_SEG; _pi++) {
				const _t0 = _pi * (2 * Math.PI / PARTICLE_SEG);
				const _t1 = (_pi + 1) * (2 * Math.PI / PARTICLE_SEG);
				_particleUnitCircle.push(0, 0);
				_particleUnitCircle.push(Math.cos(_t0), Math.sin(_t0));
				_particleUnitCircle.push(Math.cos(_t1), Math.sin(_t1));
			}
			const _particleUnitData = new Float32Array(_particleUnitCircle);
			const _particleUnitBuf = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, _particleUnitBuf);
			gl.bufferData(gl.ARRAY_BUFFER, _particleUnitData, gl.STATIC_DRAW);

			const _particleInstBuf = gl.createBuffer();
			let _particleInstData = new Float32Array(0);
			let particleProgram = null;
			let _ppUnitPosLoc, _ppInstPosLoc, _ppInstColorLoc, _ppResLoc;

			if (isWebGL2) {
				const _ppVS = `#version 300 es
					in vec2 a_unitPos;
					in vec3 a_instPos;
					in vec4 a_instColor;
					uniform vec2 u_resolution;
					out vec4 v_color;
					void main() {
						vec2 wp = a_instPos.xy + a_unitPos * a_instPos.z;
						vec2 cs = (wp / u_resolution) * 2.0 - 1.0;
						cs.y = -cs.y;
						gl_Position = vec4(cs, 0.0, 1.0);
						v_color = a_instColor;
					}
				`;
				const _ppFS = `#version 300 es
					precision mediump float;
					in vec4 v_color;
					out vec4 fragColor;
					void main() { fragColor = v_color; }
				`;
				particleProgram = createProgram(_ppVS, _ppFS);
				if (particleProgram) {
					_ppUnitPosLoc = gl.getAttribLocation(particleProgram, "a_unitPos");
					_ppInstPosLoc = gl.getAttribLocation(particleProgram, "a_instPos");
					_ppInstColorLoc = gl.getAttribLocation(particleProgram, "a_instColor");
					_ppResLoc = gl.getUniformLocation(particleProgram, "u_resolution");
				}
			}

			function drawParticlesBatched(list, count) {
				if (!particleProgram || count === 0) {
					for (let i = 0; i < count; i++) drawParticle(list[i]);
					return;
				}
				const stride = 7; // x, y, r, cr, cg, cb, ca
				const needed = count * stride;
				if (_particleInstData.length < needed) {
					_particleInstData = new Float32Array(Math.max(needed, 256) * 2);
				}
				for (let i = 0; i < count; i++) {
					const ch = list[i];
					const dot = ch.chain[0];
					const r = (ch.particleRenderSize || 4) * dotScaleFactor;
					const c = ch.color;
					const base = i * stride;
					_particleInstData[base]     = dot.x;
					_particleInstData[base + 1] = dot.y;
					_particleInstData[base + 2] = r;
					_particleInstData[base + 3] = c[0];
					_particleInstData[base + 4] = c[1];
					_particleInstData[base + 5] = c[2];
					_particleInstData[base + 6] = ch.alpha ?? 1.0;
				}
				gl.useProgram(particleProgram);
				gl.uniform2f(_ppResLoc, canvas.width, canvas.height);
				// Shared unit circle
				gl.bindBuffer(gl.ARRAY_BUFFER, _particleUnitBuf);
				gl.enableVertexAttribArray(_ppUnitPosLoc);
				gl.vertexAttribPointer(_ppUnitPosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.vertexAttribDivisor(_ppUnitPosLoc, 0);
				// Per-instance data
				gl.bindBuffer(gl.ARRAY_BUFFER, _particleInstBuf);
				gl.bufferData(gl.ARRAY_BUFFER, _particleInstData.subarray(0, needed), gl.DYNAMIC_DRAW);
				gl.enableVertexAttribArray(_ppInstPosLoc);
				gl.vertexAttribPointer(_ppInstPosLoc, 3, gl.FLOAT, false, stride * 4, 0);
				gl.vertexAttribDivisor(_ppInstPosLoc, 1);
				gl.enableVertexAttribArray(_ppInstColorLoc);
				gl.vertexAttribPointer(_ppInstColorLoc, 4, gl.FLOAT, false, stride * 4, 3 * 4);
				gl.vertexAttribDivisor(_ppInstColorLoc, 1);
				// Single instanced draw call for ALL particles
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
				gl.drawArraysInstanced(gl.TRIANGLES, 0, PARTICLE_SEG * 3, count);
				// Reset divisors
				gl.vertexAttribDivisor(_ppInstPosLoc, 0);
				gl.vertexAttribDivisor(_ppInstColorLoc, 0);
				gl.disableVertexAttribArray(_ppInstPosLoc);
				gl.disableVertexAttribArray(_ppInstColorLoc);
			}

			/* -----------------------------------
			   GPU PHYSICS INITIALIZATION
			----------------------------------- */
			function initGPUPhysics() {
				// Check if WebGL 2.0 is available
				const isWebGL2Context = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

				if (!isWebGL2Context) {
					gpuPhysics.initialized = false;
					return;
				}

				try {
					// Create full-screen quad for rendering to textures
					const quadVerts = new Float32Array([
						-1, -1,  1, -1,  -1, 1,
						-1, 1,   1, -1,   1, 1
					]);
					gpuPhysics.quadBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, gpuPhysics.quadBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

					// Create physics shader program
					const physicsVS = `#version 300 es
						in vec2 a_position;
						void main() {
							gl_Position = vec4(a_position, 0.0, 1.0);
						}
					`;

					const physicsFS = `#version 300 es
						precision highp float;
						uniform sampler2D u_position; // Combined: .xy = position, .zw = velocity
						uniform sampler2D u_metadata; // chainIndex, vertexIndex, prevIndex, nextIndex
						uniform vec2 u_textureSize;
						uniform float u_timeStep;
						uniform float u_damping;
						uniform float u_springConstant;
						uniform float u_repulsionConstant;
						uniform float u_interRepelMult;
						uniform float u_dotRadius;
						uniform vec2 u_resolution;
						uniform float u_noiseActive;
						uniform float u_noiseTime;
						uniform float u_noiseRampTime;
						uniform int u_numCircles;
						uniform vec3 u_circles[32]; // x, y, radius (max 32 circles)

						out vec4 outColor;

						vec2 getPosition(vec2 coord) {
							return texture(u_position, coord).xy;
						}

						vec2 getVelocity(vec2 coord) {
							// FIXED: velocity stored in .zw channels of combined state texture
							return texture(u_position, coord).zw;
						}

						vec4 getMetadata(vec2 coord) {
							return texture(u_metadata, coord);
						}

						// Fast inverse square root (Quake III algorithm) - much faster than 1.0/sqrt(x)
						// Used for distance calculations throughout the shader
						float fastInvSqrt(float x) {
							float xhalf = 0.5 * x;
							int i = floatBitsToInt(x);
							i = 0x5f3759df - (i >> 1);
							x = intBitsToFloat(i);
							x = x * (1.5 - xhalf * x * x);
							return x;
						}

						// Simple noise function for GPU
						float hash(float n) {
							return fract(sin(n) * 43758.5453);
						}

						float smoothNoise(float x, float t) {
							float i = floor(x);
							float f = fract(x);
							f = f * f * (3.0 - 2.0 * f);
							float a = hash(i + t);
							float b = hash(i + 1.0 + t);
							return mix(a, b, f);
						}

						void main() {
							vec2 coord = (gl_FragCoord.xy - 0.5) / u_textureSize;
							vec2 pos = getPosition(coord);
							vec2 vel = getVelocity(coord);
							vec4 meta = getMetadata(coord);

							// Metadata: x=chainIndex, y=vertexIndex, z=prevIndex, w=nextIndex
							// We'll use chainIndex and vertexIndex to determine neighbors
							float chainIdx = meta.x;
							float vertIdx = meta.y;
							float prevIdx = meta.z;
							float nextIdx = meta.w;
							float isClosed = meta.x > 0.0 ? 1.0 : 0.0; // Simplified check
							float dotR = u_dotRadius;

							vec2 force = vec2(0.0);

							// 1. SPRING FORCES - optimized with fast inverse square root and step()
							// Process prev neighbor (use step() instead of if to avoid branching)
							float prevValid = step(0.0, prevIdx);
							float prevTexIdx = prevIdx * prevValid;
							vec2 prevCoord = vec2(mod(prevTexIdx, u_textureSize.x) + 0.5, floor(prevTexIdx / u_textureSize.x) + 0.5) / u_textureSize;
							vec2 prevPos = mix(pos, getPosition(prevCoord), prevValid);
							vec2 prevSpringDir = pos - prevPos;
							float prevDistSq = dot(prevSpringDir, prevSpringDir);
							float prevRestDist = dotR * 0.7;
							float prevInvDist = fastInvSqrt(prevDistSq);
							float prevDist = 1.0 / prevInvDist;
							float prevValidDist = step(0.001, prevDist);
							float prevSpringForce = u_springConstant * (prevDist - prevRestDist) * prevInvDist;
							force -= prevSpringDir * prevSpringForce * prevValid * prevValidDist;

							// Process next neighbor
							float nextValid = step(0.0, nextIdx);
							float nextTexIdx = nextIdx * nextValid;
							vec2 nextCoord = vec2(mod(nextTexIdx, u_textureSize.x) + 0.5, floor(nextTexIdx / u_textureSize.x) + 0.5) / u_textureSize;
							vec2 nextPos = mix(pos, getPosition(nextCoord), nextValid);
							vec2 nextSpringDir = pos - nextPos;
							float nextDistSq = dot(nextSpringDir, nextSpringDir);
							float nextRestDist = dotR * 0.7;
							float nextInvDist = fastInvSqrt(nextDistSq);
							float nextDist = 1.0 / nextInvDist;
							float nextValidDist = step(0.001, nextDist);
							float nextSpringForce = u_springConstant * (nextDist - nextRestDist) * nextInvDist;
							force -= nextSpringDir * nextSpringForce * nextValid * nextValidDist;

							// 2. INTER-CHAIN REPULSION - optimized with WebGL tricks
							// PERFORMANCE OPTIMIZATIONS:
							// 1. Unroll small loop (checkRadius=1 = 4 neighbors) to avoid loop overhead
							// 2. Use fast inverse square root approximation instead of sqrt()
							// 3. Use step() instead of if statements to avoid branching
							// 4. Early exit with step() for bounds checking
							float minD = dotR * 2.0;
							float minDSq = minD * minD;
							vec2 texelSize = 1.0 / u_textureSize;

							// Unroll loop for checkRadius=1 (4 neighbors: up, down, left, right)
							// This eliminates loop overhead and allows better GPU optimization
							vec2 offsets[4] = vec2[](
								vec2(-1.0, 0.0),  // left
								vec2(1.0, 0.0),   // right
								vec2(0.0, -1.0), // down
								vec2(0.0, 1.0)   // up
							);

							for (int i = 0; i < 4; i++) {
								vec2 neighborCoord = coord + offsets[i] * texelSize;

								// Early exit with step() - no branching, GPU-friendly
								float inBounds = step(0.0, neighborCoord.x) * step(neighborCoord.x, 1.0) *
								                step(0.0, neighborCoord.y) * step(neighborCoord.y, 1.0);

								// Only sample textures if in bounds (GPU can optimize this)
								vec2 otherPos = mix(vec2(0.0), getPosition(neighborCoord), inBounds);
								vec4 otherMeta = mix(vec4(0.0), getMetadata(neighborCoord), inBounds);

								// Skip if same chain and adjacent vertices (use step() instead of if)
								float isSameChain = step(abs(otherMeta.x - chainIdx), 0.1);
								float vertDist = abs(otherMeta.y - vertIdx);
								float skipAdjacent = step(1.5, vertDist); // 1.0 if vertDist >= 1.5, 0.0 otherwise
								float shouldProcess = inBounds * (1.0 - isSameChain + isSameChain * skipAdjacent);

								vec2 diff = pos - otherPos;
								float distSq = dot(diff, diff);

								// Early exit with step() - check distance bounds without branching
								float inRange = step(0.001, distSq) * step(distSq, minDSq);
								float process = shouldProcess * inRange;

								// Use fast inverse square root instead of sqrt()
								float invDist = fastInvSqrt(distSq);
								float dist = 1.0 / invDist;
								float overlap = minD - dist;
								vec2 dir = diff * invDist; // Multiply by invDist instead of dividing by dist
								float repelMult = mix(u_interRepelMult, 1.0, isSameChain);

								// Accumulate force only if process > 0 (GPU-friendly)
								force += dir * u_repulsionConstant * repelMult * overlap * process;
							}

							// 4. CIRCLE REPULSION - optimized with fast inverse square root and step()
							// Limit to 8 circles for performance (most scenes don't need more)
							int maxCircles = min(u_numCircles, 8);
							float isHardWall = step(2.9, u_interRepelMult);

							for (int i = 0; i < maxCircles; i++) {
								vec3 circle = u_circles[i];
								vec2 circlePos = circle.xy;
								float circleRadius = circle.z;

								vec2 diff = pos - circlePos;
								float distSq = dot(diff, diff);
								float minDist = circleRadius + dotR;
								float minDistSq = minDist * minDist;

								// Early exit with step() - no branching
								float inRange = step(0.001, distSq) * step(distSq, minDistSq);

								// Use fast inverse square root
								float invDist = fastInvSqrt(distSq);
								float dist = 1.0 / invDist;
								vec2 dir = diff * invDist;

								// Hard wall mode (use mix instead of if)
								vec2 hardWallPos = circlePos + dir * minDist;
								pos = mix(pos, hardWallPos, isHardWall * inRange);
								vel = mix(vel, vec2(0.0), isHardWall * inRange);

								// Soft mode
								float overlap = minDist - dist;
								force += dir * u_repulsionConstant * overlap * (1.0 - isHardWall) * inRange;
							}

							// 5. NOISE FORCES
							if (u_noiseActive > 0.5) {
								float noiseScale = 0.01;
								float rampPhase = (sin(u_noiseRampTime) + 1.0) / 2.0;
								float easedRamp = rampPhase < 0.5
									? 2.0 * rampPhase * rampPhase
									: 1.0 - pow(-2.0 * rampPhase + 2.0, 2.0) / 2.0;
								float strengthMultiplier = 0.5 + easedRamp * 0.5;
								float baseNoiseStrength = 0.2;
								float currentNoiseStrength = baseNoiseStrength * strengthMultiplier;

								float nx = smoothNoise(pos.x * noiseScale, u_noiseTime);
								float ny = smoothNoise(pos.y * noiseScale, u_noiseTime + 1000.0);
								vec2 noiseDir = vec2((nx - 0.5) * 2.0, (ny - 0.5) * 2.0);
								force += noiseDir * currentNoiseStrength;
							}

							// 6. BOUNDARY CONSTRAINTS
							if (pos.x < dotR) {
								force.x += (dotR - pos.x) * 0.5;
							} else if (pos.x > u_resolution.x - dotR) {
								force.x -= (pos.x - (u_resolution.x - dotR)) * 0.5;
							}

							if (pos.y < dotR) {
								force.y += (dotR - pos.y) * 0.5;
							} else if (pos.y > u_resolution.y - dotR) {
								force.y -= (pos.y - (u_resolution.y - dotR)) * 0.5;
							}

							// Apply forces to velocity
							vel += force * u_timeStep;

							// Apply damping
							vel *= u_damping;

							// Update position
							pos += vel * u_timeStep;

							// Final boundary constraints
							if (pos.x < dotR) {
								pos.x = dotR;
								vel.x = 0.0;
							}
							if (pos.x > u_resolution.x - dotR) {
								pos.x = u_resolution.x - dotR;
								vel.x = 0.0;
							}
							if (pos.y < dotR) {
								pos.y = dotR;
								vel.y = 0.0;
							}
							if (pos.y > u_resolution.y - dotR) {
								pos.y = u_resolution.y - dotR;
								vel.y = 0.0;
							}

							// Output: position in RG, velocity in BA
							outColor = vec4(pos.x, pos.y, vel.x, vel.y);
						}
					`;

					// Create GPU physics program (we're already in WebGL 2.0 context)
					gpuPhysics.updateProgram = createProgram(physicsVS, physicsFS);

					if (!gpuPhysics.updateProgram) {
						console.warn("GPU physics shader compilation failed, falling back to CPU physics");
						gpuPhysics.initialized = false;
						return;
					}

					// Cache uniform and attribute locations (PERFORMANCE: avoid per-frame lookups)
					const prog = gpuPhysics.updateProgram;
					gpuPhysics.uniformLocations = {
						u_position: gl.getUniformLocation(prog, "u_position"),
						u_velocity: gl.getUniformLocation(prog, "u_velocity"),
						u_metadata: gl.getUniformLocation(prog, "u_metadata"),
						u_textureSize: gl.getUniformLocation(prog, "u_textureSize"),
						u_timeStep: gl.getUniformLocation(prog, "u_timeStep"),
						u_damping: gl.getUniformLocation(prog, "u_damping"),
						u_springConstant: gl.getUniformLocation(prog, "u_springConstant"),
						u_repulsionConstant: gl.getUniformLocation(prog, "u_repulsionConstant"),
						u_interRepelMult: gl.getUniformLocation(prog, "u_interRepelMult"),
						u_dotRadius: gl.getUniformLocation(prog, "u_dotRadius"),
						u_resolution: gl.getUniformLocation(prog, "u_resolution"),
						u_noiseActive: gl.getUniformLocation(prog, "u_noiseActive"),
						u_noiseTime: gl.getUniformLocation(prog, "u_noiseTime"),
						u_noiseRampTime: gl.getUniformLocation(prog, "u_noiseRampTime"),
						u_numCircles: gl.getUniformLocation(prog, "u_numCircles"),
						u_circles: gl.getUniformLocation(prog, "u_circles")
					};
					gpuPhysics.attribLocations = {
						a_position: gl.getAttribLocation(prog, "a_position")
					};

					gpuPhysics.initialized = true;

					if (console && console.log) {
						console.log("GPU physics initialized successfully");
						console.log("WebGL 2.0:", isWebGL2Context);
						console.log("Transform feedback available:", hasTransformFeedback);
						console.log("Using texture-based GPU physics (works on iPad/Safari)");
					}
				} catch (e) {
					console.error("GPU physics initialization failed:", e);
					gpuPhysics.initialized = false;
				}
			}

			// Initialize GPU rendering shaders
			function initGPURendering() {
				if (!gpuPhysics.initialized) return;

				// GPU rendering vertex shader - reads positions from texture and calculates splines
				const gpuRenderVS = `#version 300 es
					in float a_splineIndex; // Spline segment index (0 to chainLength-1 for closed, 0 to chainLength-2 for open)

					uniform sampler2D u_positionTexture;
					uniform vec2 u_textureSize;
					uniform vec2 u_resolution;
					uniform float u_chainStartIndex;
					uniform float u_chainLength;
					uniform float u_isClosed;
					uniform float u_splineSegments; // Number of spline segments per edge (typically 10)

					out vec2 v_position;

					vec2 getPositionFromTexture(float texIndex) {
						if (texIndex < 0.0) return vec2(0.0);
						float x = mod(texIndex, u_textureSize.x) + 0.5;
						float y = floor(texIndex / u_textureSize.x) + 0.5;
						vec2 coord = vec2(x, y) / u_textureSize;
						return texture(u_positionTexture, coord).xy;
					}

					// Catmull-Rom spline interpolation
					vec2 catmullRom(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {
						float t2 = t * t;
						float t3 = t2 * t;
						return 0.5 * (
							(2.0 * p1) +
							(-p0 + p2) * t +
							(2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +
							(-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t3
						);
					}

					void main() {
						// Calculate which vertex segment we're in
						float segmentIdx = floor(a_splineIndex / u_splineSegments);
						float localT = mod(a_splineIndex, u_splineSegments) / u_splineSegments;

						// Get vertex indices for Catmull-Rom (p0, p1, p2, p3)
						float i1 = segmentIdx;
						float i0, i2, i3;

						if (u_isClosed > 0.5) {
							// Closed chain - wrap around
							i0 = mod(i1 - 1.0 + u_chainLength, u_chainLength);
							i2 = mod(i1 + 1.0, u_chainLength);
							i3 = mod(i1 + 2.0, u_chainLength);
						} else {
							// Open chain
							i0 = max(0.0, i1 - 1.0);
							i2 = min(u_chainLength - 1.0, i1 + 1.0);
							i3 = min(u_chainLength - 1.0, i1 + 2.0);

							// Handle edge cases for open chains
							if (i1 == 0.0) {
								i0 = i1; // Duplicate first point
							}
							if (i1 >= u_chainLength - 1.0) {
								i2 = i1; // Duplicate last point
								i3 = i1;
							}
						}

						// Get positions from GPU texture
						vec2 p0 = getPositionFromTexture(u_chainStartIndex + i0);
						vec2 p1 = getPositionFromTexture(u_chainStartIndex + i1);
						vec2 p2 = getPositionFromTexture(u_chainStartIndex + i2);
						vec2 p3 = getPositionFromTexture(u_chainStartIndex + i3);

						// Interpolate spline point
						vec2 pos = catmullRom(p0, p1, p2, p3, localT);

						// Convert to clip space
						vec2 clipSpace = (pos / u_resolution) * 2.0 - 1.0;
						clipSpace.y = -clipSpace.y;

						gl_Position = vec4(clipSpace, 0.0, 1.0);
						v_position = pos;
					}
				`;

				// GPU rendering fragment shader
				const gpuRenderFS = `#version 300 es
					precision mediump float;
					uniform vec4 u_color;
					void main() {
						gl_FragColor = u_color;
					}
				`;

				gpuPhysics.renderProgram = createProgram(gpuRenderVS, gpuRenderFS);

				if (!gpuPhysics.renderProgram) {
					console.warn("GPU rendering shader compilation failed, will use CPU rendering");
					return;
				}

				// Cache render shader uniform and attribute locations
				const renderProg = gpuPhysics.renderProgram;
				gpuPhysics.renderUniformLocations = {
					u_positionTexture: gl.getUniformLocation(renderProg, "u_positionTexture"),
					u_textureSize: gl.getUniformLocation(renderProg, "u_textureSize"),
					u_resolution: gl.getUniformLocation(renderProg, "u_resolution"),
					u_chainStartIndex: gl.getUniformLocation(renderProg, "u_chainStartIndex"),
					u_chainLength: gl.getUniformLocation(renderProg, "u_chainLength"),
					u_isClosed: gl.getUniformLocation(renderProg, "u_isClosed"),
					u_splineSegments: gl.getUniformLocation(renderProg, "u_splineSegments"),
					u_color: gl.getUniformLocation(renderProg, "u_color")
				};
				gpuPhysics.renderAttribLocations = {
					a_splineIndex: gl.getAttribLocation(renderProg, "a_splineIndex")
				};

				// Create buffer for spline rendering
				gpuPhysics.splineBuffer = gl.createBuffer();

				if (console && console.log) {
					console.log("GPU rendering initialized successfully");
				}
			}

			// Rebuild GPU texture layout when chains change
			function rebuildGPUTextures() {
				if (!gpuPhysics.initialized) return;

				// Calculate total vertices across all chains
				gpuPhysics.totalVertices = 0;
				gpuPhysics.vertexMapping = [];

				// Build chain start indices for fast lookup
				gpuPhysics.chainStartIndices = [];

				for (let c = 0; c < chains.length; c++) {
					const chain = chains[c];
					const startIdx = gpuPhysics.totalVertices;
					gpuPhysics.chainStartIndices[c] = startIdx;
					for (let i = 0; i < chain.chain.length; i++) {
						gpuPhysics.vertexMapping.push({ chainIndex: c, vertexIndex: i, texCoord: gpuPhysics.totalVertices });
						gpuPhysics.totalVertices++;
					}
				}

				if (gpuPhysics.totalVertices === 0) return;

				// Calculate texture dimensions (power of 2, square-ish)
				const sqrt = Math.ceil(Math.sqrt(gpuPhysics.totalVertices));
				gpuPhysics.textureWidth = Math.pow(2, Math.ceil(Math.log2(sqrt)));
				gpuPhysics.textureHeight = Math.ceil(gpuPhysics.totalVertices / gpuPhysics.textureWidth);

				// Create textures for positions and velocities (ping-pong)
				for (let i = 0; i < 2; i++) {
					// Position textures
					if (gpuPhysics.positionTextures[i]) {
						gl.deleteTexture(gpuPhysics.positionTextures[i]);
					}
					gpuPhysics.positionTextures[i] = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.positionTextures[i]);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, gpuPhysics.textureWidth, gpuPhysics.textureHeight, 0, gl.RGBA, gl.FLOAT, null);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

					// Velocity textures
					if (gpuPhysics.velocityTextures[i]) {
						gl.deleteTexture(gpuPhysics.velocityTextures[i]);
					}
					gpuPhysics.velocityTextures[i] = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.velocityTextures[i]);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, gpuPhysics.textureWidth, gpuPhysics.textureHeight, 0, gl.RGBA, gl.FLOAT, null);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

					// Framebuffers - delete old ones first
					if (gpuPhysics.framebuffers[i]) {
						// Unbind framebuffer if it's currently bound
						gl.bindFramebuffer(gl.FRAMEBUFFER, null);
						gl.deleteFramebuffer(gpuPhysics.framebuffers[i]);
					}
					gpuPhysics.framebuffers[i] = gl.createFramebuffer();

					// Attach position texture to framebuffer to make it complete
					gl.bindFramebuffer(gl.FRAMEBUFFER, gpuPhysics.framebuffers[i]);
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gpuPhysics.positionTextures[i], 0);

					// Verify framebuffer is complete
					const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
					if (status !== gl.FRAMEBUFFER_COMPLETE) {
						console.warn("Framebuffer not complete after rebuild:", status);
						// Fallback: disable GPU physics if framebuffer can't be created
						gpuPhysics.initialized = false;
					}

					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				}

				// Create metadata texture (chainIndex, vertexIndex, prevIndex, nextIndex)
				if (gpuPhysics.metadataTexture) {
					gl.deleteTexture(gpuPhysics.metadataTexture);
				}
				gpuPhysics.metadataTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.metadataTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, gpuPhysics.textureWidth, gpuPhysics.textureHeight, 0, gl.RGBA, gl.FLOAT, null);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				// Upload initial positions, velocities, and metadata
				uploadToGPU();
			}

			// Upload CPU data to GPU textures
			function uploadToGPU() {
				if (!gpuPhysics.initialized || gpuPhysics.totalVertices === 0) return;

				// FIXED: Combined state texture — pos in .xy, vel in .zw
				const data = new Float32Array(gpuPhysics.textureWidth * gpuPhysics.textureHeight * 4);
				const metaData = new Float32Array(gpuPhysics.textureWidth * gpuPhysics.textureHeight * 4);

				for (let i = 0; i < gpuPhysics.vertexMapping.length; i++) {
					const mapping = gpuPhysics.vertexMapping[i];
					const chain = chains[mapping.chainIndex];
					const vertex = chain.chain[mapping.vertexIndex];

					const idx = i * 4;
					// Combined: position in .xy, velocity in .zw
					data[idx] = vertex.x;
					data[idx + 1] = vertex.y;
					data[idx + 2] = vertex.vx || 0.0;
					data[idx + 3] = vertex.vy || 0.0;

					// Metadata: chainIndex, vertexIndex, prevIndex, nextIndex
					// Find previous and next vertex indices in texture
					let prevIdx = -1.0;
					let nextIdx = -1.0;

					if (chain.isClosed) {
						const prevVertIdx = (mapping.vertexIndex - 1 + chain.chain.length) % chain.chain.length;
						const nextVertIdx = (mapping.vertexIndex + 1) % chain.chain.length;
						// Find texture indices for prev/next
						for (let j = 0; j < gpuPhysics.vertexMapping.length; j++) {
							const m = gpuPhysics.vertexMapping[j];
							if (m.chainIndex === mapping.chainIndex) {
								if (m.vertexIndex === prevVertIdx) prevIdx = j;
								if (m.vertexIndex === nextVertIdx) nextIdx = j;
							}
						}
					} else {
						if (mapping.vertexIndex > 0) {
							const prevVertIdx = mapping.vertexIndex - 1;
							for (let j = 0; j < gpuPhysics.vertexMapping.length; j++) {
								const m = gpuPhysics.vertexMapping[j];
								if (m.chainIndex === mapping.chainIndex && m.vertexIndex === prevVertIdx) {
									prevIdx = j;
									break;
								}
							}
						}
						if (mapping.vertexIndex < chain.chain.length - 1) {
							const nextVertIdx = mapping.vertexIndex + 1;
							for (let j = 0; j < gpuPhysics.vertexMapping.length; j++) {
								const m = gpuPhysics.vertexMapping[j];
								if (m.chainIndex === mapping.chainIndex && m.vertexIndex === nextVertIdx) {
									nextIdx = j;
									break;
								}
							}
						}
					}

					metaData[idx] = mapping.chainIndex;
					metaData[idx + 1] = mapping.vertexIndex;
					metaData[idx + 2] = prevIdx;
					metaData[idx + 3] = nextIdx;
				}

				// Upload combined state to both ping-pong buffers
				for (let i = 0; i < 2; i++) {
					gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.positionTextures[i]);
					gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gpuPhysics.textureWidth, gpuPhysics.textureHeight, gl.RGBA, gl.FLOAT, data);
				}

				// Upload metadata (only once, doesn't change)
				gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.metadataTexture);
				gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gpuPhysics.textureWidth, gpuPhysics.textureHeight, gl.RGBA, gl.FLOAT, metaData);
			}

			// Download GPU data back to CPU (single read — combined state texture)
			let _gpuReadbackBuf = null;
			function downloadFromGPU() {
				if (!gpuPhysics.initialized || gpuPhysics.totalVertices === 0) return;

				const current = gpuPhysics.currentBuffer;
				const texSize = gpuPhysics.textureWidth * gpuPhysics.textureHeight * 4;
				if (!_gpuReadbackBuf || _gpuReadbackBuf.length < texSize) {
					_gpuReadbackBuf = new Float32Array(texSize);
				}

				// Single readPixels — pos in .xy, vel in .zw
				gl.bindFramebuffer(gl.FRAMEBUFFER, gpuPhysics.framebuffers[current]);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gpuPhysics.positionTextures[current], 0);
				gl.readPixels(0, 0, gpuPhysics.textureWidth, gpuPhysics.textureHeight, gl.RGBA, gl.FLOAT, _gpuReadbackBuf);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);

				// Update CPU data
				for (let i = 0; i < gpuPhysics.vertexMapping.length; i++) {
					const mapping = gpuPhysics.vertexMapping[i];
					const chain = chains[mapping.chainIndex];
					const vertex = chain.chain[mapping.vertexIndex];
					const idx = i * 4;
					vertex.x = _gpuReadbackBuf[idx];
					vertex.y = _gpuReadbackBuf[idx + 1];
					vertex.vx = _gpuReadbackBuf[idx + 2];
					vertex.vy = _gpuReadbackBuf[idx + 3];
				}
			}

			// Run physics step on GPU
			function simulateGPUPhysics() {
				if (!gpuPhysics.initialized || gpuPhysics.totalVertices === 0) return;

				// PERFORMANCE: Skip physics every other frame on iPad for better performance
				// This reduces GPU load significantly while maintaining visual quality
				const isIPadDevice = /iPad/i.test(navigator.userAgent) ||
					(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
				if (isIPadDevice && (Math.floor(performance.now() / 16) % 2 === 0)) {
					return; // Skip every other frame on iPad
				}

				const current = gpuPhysics.currentBuffer;
				const next = 1 - current;
				const locs = gpuPhysics.uniformLocations;
				const attrs = gpuPhysics.attribLocations;

				// Bind framebuffer for output
				gl.bindFramebuffer(gl.FRAMEBUFFER, gpuPhysics.framebuffers[next]);

				// Attach both position and velocity textures (we'll render twice)
				gl.viewport(0, 0, gpuPhysics.textureWidth, gpuPhysics.textureHeight);

				// Use physics shader
				gl.useProgram(gpuPhysics.updateProgram);

				// Bind input textures — combined state in position texture (.xy=pos, .zw=vel)
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.positionTextures[current]);
				gl.uniform1i(locs.u_position, 0);

				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.metadataTexture);
				gl.uniform1i(locs.u_metadata, 1);

				// Set uniforms (PERFORMANCE: using cached uniform locations)
				gl.uniform2f(locs.u_textureSize, gpuPhysics.textureWidth, gpuPhysics.textureHeight);
				gl.uniform1f(locs.u_timeStep, timeStep);
				gl.uniform1f(locs.u_damping, damping);
				gl.uniform1f(locs.u_springConstant, springConstant);
				gl.uniform1f(locs.u_repulsionConstant, repulsionConstant);
				gl.uniform1f(locs.u_interRepelMult, interRepelMult);
				const avgRadius = chains.length > 0 ? chains[0].baseDotRadius * dotScaleFactor : 5.0;
				gl.uniform1f(locs.u_dotRadius, avgRadius);
				gl.uniform2f(locs.u_resolution, canvas.width, canvas.height);
				gl.uniform1f(locs.u_noiseActive, noiseActive ? 1.0 : 0.0);
				gl.uniform1f(locs.u_noiseTime, noiseTime);
				gl.uniform1f(locs.u_noiseRampTime, noiseRampTime);

				// Upload circles (max 8 for now due to uniform array limitations)
				const numCircles = Math.min(circles.length, 8);
				gl.uniform1i(locs.u_numCircles, numCircles);
				for (let i = 0; i < numCircles; i++) {
					const loc = gl.getUniformLocation(gpuPhysics.updateProgram, `u_circles[${i}]`);
					if (loc) {
						gl.uniform3f(loc, circles[i].x, circles[i].y, circles[i].radius);
					}
				}

				// Render combined state to position texture (single draw call)
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gpuPhysics.positionTextures[next], 0);
				gl.bindBuffer(gl.ARRAY_BUFFER, gpuPhysics.quadBuffer);
				gl.enableVertexAttribArray(attrs.a_position);
				gl.vertexAttribPointer(attrs.a_position, 2, gl.FLOAT, false, 0, 0);
				gl.drawArrays(gl.TRIANGLES, 0, 6);

				// Swap buffers
				gpuPhysics.currentBuffer = next;

				// Restore viewport
				gl.viewport(0, 0, canvas.width, canvas.height);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			}

			/* -----------------------------------
			   CATMULL–ROM SPLINE HELPERS
			----------------------------------- */
			function getClosedSmoothCurve(points, seg = _splineSeg) {
				const n = points.length;
				if (n < 2) return new Float32Array([]);
				// PERFORMANCE: Pre-allocate exact size, fill directly (no JS array + copy)
				const out = new Float32Array(n * seg * 2 + 2);
				let idx = 0;
				const invSeg = 1 / seg;
				for (let i = 0; i < n; i++) {
					const p0 = points[(i - 1 + n) % n],
						p1 = points[i],
						p2 = points[(i + 1) % n],
						p3 = points[(i + 2) % n];
					const p0x = p0.x, p0y = p0.y, p1x = p1.x, p1y = p1.y;
					const p2x = p2.x, p2y = p2.y, p3x = p3.x, p3y = p3.y;
					const ax = -p0x + p2x, bx = 2*p0x - 5*p1x + 4*p2x - p3x, cx = -p0x + 3*p1x - 3*p2x + p3x;
					const ay = -p0y + p2y, by = 2*p0y - 5*p1y + 4*p2y - p3y, cy = -p0y + 3*p1y - 3*p2y + p3y;
					const dx = 2 * p1x, dy = 2 * p1y;
					for (let s = 0; s < seg; s++) {
						const t = s * invSeg, t2 = t * t, t3 = t2 * t;
						out[idx++] = 0.5 * (dx + ax * t + bx * t2 + cx * t3);
						out[idx++] = 0.5 * (dy + ay * t + by * t2 + cy * t3);
					}
				}
				out[idx++] = points[0].x;
				out[idx++] = points[0].y;
				return out;
			}

			function getOpenSmoothCurve(points, seg = _splineSeg) {
				const n = points.length;
				if (n < 2) return new Float32Array([]);
				const out = new Float32Array((n - 1) * seg * 2 + 2);
				let idx = 0;
				const invSeg = 1 / seg;
				for (let i = 0; i < n - 1; i++) {
					const p0 = (i === 0 ? points[0] : points[i - 1]),
						p1 = points[i],
						p2 = points[i + 1],
						p3 = (i === n - 2 ? points[n - 1] : points[i + 2]);
					const p0x = p0.x, p0y = p0.y, p1x = p1.x, p1y = p1.y;
					const p2x = p2.x, p2y = p2.y, p3x = p3.x, p3y = p3.y;
					const ax = -p0x + p2x, bx = 2*p0x - 5*p1x + 4*p2x - p3x, cx = -p0x + 3*p1x - 3*p2x + p3x;
					const ay = -p0y + p2y, by = 2*p0y - 5*p1y + 4*p2y - p3y, cy = -p0y + 3*p1y - 3*p2y + p3y;
					const dx = 2 * p1x, dy = 2 * p1y;
					for (let s = 0; s < seg; s++) {
						const t = s * invSeg, t2 = t * t, t3 = t2 * t;
						out[idx++] = 0.5 * (dx + ax * t + bx * t2 + cx * t3);
						out[idx++] = 0.5 * (dy + ay * t + by * t2 + cy * t3);
					}
				}
				out[idx++] = points[n - 1].x;
				out[idx++] = points[n - 1].y;
				return out;
			}

			function buildStencilTris(flat, outX, outY) {
				// flat = [x0,y0,x1,y1, ... ,xn,yn]  (closed, last!=first)
				const segs = flat.length / 2;
				const arr = new Float32Array(segs * 3 * 2); // 3 verts × 2 coords
				let p = 0;
				for (let i = 0; i < segs; i++) {
					const i2 = (i + 1) % segs;
					arr[p++] = flat[i * 2];
					arr[p++] = flat[i * 2 + 1];
					arr[p++] = flat[i2 * 2];
					arr[p++] = flat[i2 * 2 + 1];
					arr[p++] = outX;
					arr[p++] = outY; // far point
				}
				return arr;
			}

			function getThickLineVertices(splinePts, thickness) {
				const n = splinePts.length >> 1; // points count
				const needed = n * 4; // 2 verts per point
				if (thickScratch.length < needed) thickScratch = new Float32Array(needed);

				const half = thickness * 0.5;
				for (let i = 0; i < n; i++) {
					const currX = splinePts[i * 2],
						currY = splinePts[i * 2 + 1];
					const prevX = splinePts[((i - 1 + n) % n) * 2],
						prevY = splinePts[((i - 1 + n) % n) * 2 + 1];
					const nextX = splinePts[((i + 1) % n) * 2],
						nextY = splinePts[((i + 1) % n) * 2 + 1];

					// tangential = next - prev
					const tx = nextX - prevX,
						ty = nextY - prevY;
					const invLen = 1 / Math.hypot(tx, ty || 1); // avoid /0
					const nx = -ty * invLen,
						ny = tx * invLen; // normal

					const base = i * 4;
					thickScratch[base] = currX + nx * half;
					thickScratch[base + 1] = currY + ny * half;
					thickScratch[base + 2] = currX - nx * half;
					thickScratch[base + 3] = currY - ny * half;
				}
				return thickScratch.subarray(0, needed);
			}

			// Version for open segments (non-closed paths)
			function getThickLineVerticesOpen(splinePts, thickness) {
				const n = splinePts.length >> 1; // points count
				if (n < 2) return new Float32Array(0);
				const needed = n * 4; // 2 verts per point
				if (thickScratch.length < needed) thickScratch = new Float32Array(needed);

				const half = thickness * 0.5;
				for (let i = 0; i < n; i++) {
					const currX = splinePts[i * 2],
						currY = splinePts[i * 2 + 1];

					let tx, ty;
					if (i === 0) {
						// First point: use direction to next
						const nextX = splinePts[(i + 1) * 2],
							nextY = splinePts[(i + 1) * 2 + 1];
						tx = nextX - currX;
						ty = nextY - currY;
					} else if (i === n - 1) {
						// Last point: use direction from previous
						const prevX = splinePts[(i - 1) * 2],
							prevY = splinePts[(i - 1) * 2 + 1];
						tx = currX - prevX;
						ty = currY - prevY;
					} else {
						// Middle points: average of both directions
						const prevX = splinePts[(i - 1) * 2],
							prevY = splinePts[(i - 1) * 2 + 1];
						const nextX = splinePts[(i + 1) * 2],
							nextY = splinePts[(i + 1) * 2 + 1];
						tx = nextX - prevX;
						ty = nextY - prevY;
					}

					const invLen = 1 / Math.hypot(tx, ty || 1); // avoid /0
					const nx = -ty * invLen,
						ny = tx * invLen; // normal

					const base = i * 4;
					thickScratch[base] = currX + nx * half;
					thickScratch[base + 1] = currY + ny * half;
					thickScratch[base + 2] = currX - nx * half;
					thickScratch[base + 3] = currY - ny * half;
				}
				return thickScratch.subarray(0, needed);
			}

			/* -----------------------------------
			   "DASHED" RENDER FOR FROZEN
			----------------------------------- */
			// PERFORMANCE: Batch all dash segments into one buffer + one draw call
			let _dashBatchBuf = new Float32Array(1024); // grows as needed

			function drawDashedSpline(spline, color) {
			    gl.useProgram(lineProgram);
			    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
			    gl.uniform4fv(lineColorLoc, color);
			    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			    gl.enableVertexAttribArray(linePosLoc);
			    gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);

			    // PERFORMANCE: Collect all dash segments, upload once, draw with gl.LINES
			    const pts = spline;
			    const dashCount = Math.floor((pts.length - 2) / 4); // every other segment pair
			    if (dashCount <= 0) return;
			    const needed = dashCount * 4; // 2 points * 2 coords per dash
			    if (_dashBatchBuf.length < needed) _dashBatchBuf = new Float32Array(needed * 2);
			    let idx = 0;
			    for (let i = 0; i < pts.length - 3; i += 4) {
			        _dashBatchBuf[idx++] = pts[i];
			        _dashBatchBuf[idx++] = pts[i + 1];
			        _dashBatchBuf[idx++] = pts[i + 2];
			        _dashBatchBuf[idx++] = pts[i + 3];
			    }
			    gl.bufferData(gl.ARRAY_BUFFER, _dashBatchBuf.subarray(0, idx), gl.DYNAMIC_DRAW);
			    gl.drawArrays(gl.LINES, 0, idx / 2);
			}


			/* -----------------------------------
			   PHYSICS
			----------------------------------- */
			function applySpring(chain, forces, i, j, restDist) {
				const a = chain[i],
					b = chain[j];
				const dx = b.x - a.x,
					dy = b.y - a.y;
				let dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < 1e-4) dist = 1e-4;
				const invDist = 1 / dist; // Cache inverse
				const f = springConstant * (dist - restDist);
				const nx = dx * invDist;
				const ny = dy * invDist;
				forces[i].x += f * nx;
				forces[i].y += f * ny;
				forces[j].x -= f * nx;
				forces[j].y -= f * ny;
			}

			function simulateChain(chainObj, cIndex) {
				if (chainObj.frozen) return; // skip frozen

				const arr = chainObj.chain;

				// PERFORMANCE: Fast path for single-vertex particles
				// Skip springs, self-repulsion, turgor — just apply damping + boundaries
				if (arr.length <= 1) {
					if (arr.length === 1) {
						const d = arr[0];
						const isDraggingThisDot = (dragMode && cIndex === draggingChainIndex && draggingDotIndex === 0);
						
						if (!d.pinned) {
							const dotR = chainObj.baseDotRadius * dotScaleFactor;
							
							// Apply drag force if this particle is being dragged (matches regular blob drag behavior)
							if (isDraggingThisDot) {
								const dx = currentMouseX - d.x;
								const dy = currentMouseY - d.y;
								const dist = Math.sqrt(dx * dx + dy * dy);
								if (dist > 1e-4) {
									const nx = dx / dist;
									const ny = dy / dist;
									const f = 0.2 * dist;
									// Apply force as velocity change (equivalent to adding to forces array then integrating)
									d.vx += f * nx * timeStep;
									d.vy += f * ny * timeStep;
								}
							}
							
							if (gravityEnabled) d.vy += gravityAccel * (timeStep / 60);
							d.vx *= damping;
							d.vy *= damping;
							d.x += d.vx * timeStep;
							d.y += d.vy * timeStep;
							if (d.x < dotR) { d.x = dotR; d.vx = 0; }
							if (d.x > canvas.width - dotR) { d.x = canvas.width - dotR; d.vx = 0; }
							if (d.y < dotR) { d.y = dotR; d.vy = 0; }
							if (d.y > canvas.height - dotR) { d.y = canvas.height - dotR; d.vy = 0; }
						}
					}
					return;
				}

				let forces = chainObj._forces;
				// (re‑create if first time or if the point count changed)
				if (!forces || forces.length !== arr.length) {
					forces = chainObj._forces = Array.from({ length: arr.length },
						() => ({ x: 0, y: 0 }));
				}
				// zero the existing vectors instead of allocating new objects
				for (let i = 0; i < forces.length; i++) {
					forces[i].x = 0;
					forces[i].y = 0;
				}
				const dotR = chainObj.baseDotRadius * dotScaleFactor;
				const restDist = Math.max(dotR, 4) * 0.7;

				// Springs
				if (chainObj.isClosed) {
					for (let i = 0; i < arr.length; i++) {
						const j = (i + 1) % arr.length;
						applySpring(arr, forces, i, j, restDist);
					}
				} else {
					for (let i = 0; i < arr.length - 1; i++) {
						applySpring(arr, forces, i, i + 1, restDist);
					}
				}

				// Self repulsion - OPTIMIZED: spatial hash with forward-only offsets
				// No Set/Map allocation per frame — reuses module-level _selfRepulsionMap
				const minD = dotR * 2;
				const minDSq = minD * minD;
				const selfHashCellSize = minD * 1.5;
				const invSelfCell = 1 / selfHashCellSize;

				// Reuse module-level Map (clear is cheaper than new Map)
				_selfRepulsionMap.clear();
				for (let i = 0; i < arr.length; i++) {
					const p = arr[i];
					const cx = (p.x * invSelfCell) | 0;
					const cy = (p.y * invSelfCell) | 0;
					const key = hashKey(cx, cy);
					let bucket = _selfRepulsionMap.get(key);
					if (bucket === undefined) { bucket = []; _selfRepulsionMap.set(key, bucket); }
					bucket.push(i);
				}

				// Forward-only offsets: each cell-pair visited exactly once (no Set needed)
				for (const [key, indices] of _selfRepulsionMap) {
					const len = indices.length;
					// Same-cell pairs (i < j ensures each pair once)
					for (let ii = 0; ii < len; ii++) {
						const i = indices[ii];
						const a = arr[i];
						for (let jj = ii + 1; jj < len; jj++) {
							const j = indices[jj];
							const b = arr[j];
							const dx = b.x - a.x;
							const dy = b.y - a.y;
							const distSq = dx * dx + dy * dy;
							if (distSq > 0 && distSq < minDSq) {
								const dist = Math.sqrt(distSq);
								const overlap = minD - dist;
								const invDist = 1 / dist;
								const nx = dx * invDist;
								const ny = dy * invDist;
								const f = repulsionConstant * overlap;
								forces[i].x -= f * nx;
								forces[i].y -= f * ny;
								forces[j].x += f * nx;
								forces[j].y += f * ny;
							}
						}
					}
					// Forward neighbors only (right, up, up-right, up-left)
					const cx = key >> 16;
					const cy = (key << 16) >> 16;
					for (let k = 0; k < 4; k++) {
						const off = _selfFwdOffsets[k];
						const nKey = hashKey(cx + off[0], cy + off[1]);
						const nIndices = _selfRepulsionMap.get(nKey);
						if (nIndices === undefined) continue;
						const nLen = nIndices.length;
						for (let ii = 0; ii < len; ii++) {
							const i = indices[ii];
							const a = arr[i];
							for (let jj = 0; jj < nLen; jj++) {
								const j = nIndices[jj];
								const b = arr[j];
								const dx = b.x - a.x;
								const dy = b.y - a.y;
								const distSq = dx * dx + dy * dy;
								if (distSq > 0 && distSq < minDSq) {
									const dist = Math.sqrt(distSq);
									const overlap = minD - dist;
									const invDist = 1 / dist;
									const nx = dx * invDist;
									const ny = dy * invDist;
									const f = repulsionConstant * overlap;
									forces[i].x -= f * nx;
									forces[i].y -= f * ny;
									forces[j].x += f * nx;
									forces[j].y += f * ny;
								}
							}
						}
					}
				}

				// Boundary push-back
				for (let i = 0; i < arr.length; i++) {
					const a = arr[i];
					if (a.x < dotR) forces[i].x += (dotR - a.x) * 0.5;
					else if (a.x > canvas.width - dotR) forces[i].x -= (a.x - (canvas.width - dotR)) * 0.5;

					if (a.y < dotR) forces[i].y += (dotR - a.y) * 0.5;
					else if (a.y > canvas.height - dotR) forces[i].y -= (a.y - (canvas.height - dotR)) * 0.5;
				}

				// --- Internal vs External Pressure Equilibrium (runaway-proof) ---
		if (chainObj.isClosed && turgorPressure > 0) {
		  const pts = chainObj.chain; const N = pts.length; if (N >= 3) {

				// Perimeter & orientation
				let L = 0, twiceA = 0;
				for (let i = 0; i < N; i++) {
				  const j  = (i + 1) % N;
				  const ex = pts[j].x - pts[i].x;
				  const ey = pts[j].y - pts[i].y;
				  L       += Math.hypot(ex, ey);
				  twiceA  += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
				}
				const A   = 0.5 * twiceA;
				const sgn = (A >= 0) ? 1 : -1;

				// --- perimeter baseline: still used for membrane tension ---
				if (chainObj._L0 == null || chainObj._L0 < 1e-6) {
				  chainObj._L0 = Math.max(L, 1e-6);
				}
				const L0 = chainObj._L0;

				// keep the size-follow logic for membrane tension
				if (chainObj._dotScale0 == null) chainObj._dotScale0 = dotScaleFactor;
				const sizeScale = dotScaleFactor / chainObj._dotScale0;
				const L0_eff    = L0 * sizeScale;

				// --- AREA-BASED baseline from the *drawn* shape ---
				// Use the precomputed A0 from finalize; fall back to current area if missing.
				const Aabs = Math.abs(A);
				const A0   = (chainObj._A0 && chainObj._A0 > 1e-6) ? chainObj._A0 : Aabs;

				// Baseline area = the drawn blob; turgor is "how much bigger than drawn"
				const A_base = A0;

				// How much extra area at full turgor (0–1 slider)
				const areaGain = 1.5;  // tweak to taste

				// Target area at this turgor
				const A_goal = A_base * (1 + areaGain * turgorPressure);


				// Base stiffness for the area controller
				const kA = springConstant * 0.12;

				// ------------------------------
				// 1) "Balloon" mode (original-ish)
				// ------------------------------
				const areaErr   = A_goal - Aabs;
				const P_balloon = 1.25 * kA * (areaErr / Math.max(A_base, 1e-6));

				// ------------------------------
				// 2) "Soft" mode (saturated)
				// ------------------------------
				const relErrRaw = areaErr / Math.max(A_base, 1e-6);

				// How quickly saturation kicks in:
				//   bigger satWidth => more balloon-like, less clamp
				//   smaller satWidth => gentler, more clamp
				const satWidth = 3.0;  // try 1.5–3.0

				// Overall strength of soft mode pressure
				const pressureScale = 1.3; // try 1.0–1.6

				const relErr   = Math.tanh(relErrRaw * satWidth);
				const P_soft   = pressureScale * kA * relErr;

				// ------------------------------
				// 3) Blend based on turgor slider
				// ------------------------------
				// Below blendStart: 100% soft
				// Above blendEnd:   100% balloon
				const blendStart = 0.0;  // where balloon influence starts
				const blendEnd   = 0.5;  // where it's fully balloon

				let blend;
				if (turgorPressure <= blendStart) {
				  blend = 0.0;
				} else if (turgorPressure >= blendEnd) {
				  blend = 1.0;
				} else {
				  blend = (turgorPressure - blendStart) / (blendEnd - blendStart);
				}

				// Final pressure: linear mix of soft + balloon
				let P_in = (1.0 - blend) * P_soft + blend * P_balloon;

		    // ---- EXTERNAL membrane tension (resists stretch) ----
		    // Hookean surface tension: grows with perimeter strain.
		    // kT sets stiffness of the membrane; tune 0.20–0.50.
		    const strain = Math.max(0, (L - L0_eff) / L0_eff);    // 0 when at/below rest length
		    const kT = springConstant * 0.30;             // membrane tension coefficient
		    const P_tension = kT * strain;                // also force/length

		    // Effective pressure
		    let P_eff = P_in - P_tension;

		    // Small hysteresis: if we overshoot a bit, allow mild inward pressure
		    // to pull back; otherwise clamp to avoid oscillation at rest.
		    const hysteresis = 0.03; // 3% perimeter over baseline
		    if (L <= L0_eff * (1 + hysteresis)) {
		      if (P_eff < 0) P_eff = 0;
		    } else {
		      // allow inward up to 50% of springConstant scale
		      const inwardCap = springConstant * 0.05;
		      if (P_eff < -inwardCap) P_eff = -inwardCap;
		    }

		    // Optional: light damping to avoid breathing
		    const hasVel = !!(chainObj._vel || (pts[0] && ("vx" in pts[0] || "xv" in pts[0])));
		    const kd = 0.5 * springConstant * 0.02;

		    // Apply along outward normals (split to endpoints)
		    for (let i = 0; i < N; i++) {
		      const j = (i + 1) % N;

		      const ex = pts[j].x - pts[i].x;
		      const ey = pts[j].y - pts[i].y;
		      let elen = Math.hypot(ex, ey);
		      if (elen < 1e-12) continue;

		      // outward unit normal (winding-aware)
		      let nx =  ey / elen;
		      let ny = -ex / elen;
		      nx *= sgn; ny *= sgn;

		      // base pressure on this edge
		      let fMag = P_eff * elen;

		      // damping against normal motion at the edge midpoint
		      if (hasVel && kd > 0) {
		        const vi = (chainObj._vel && chainObj._vel[i]) ? chainObj._vel[i] : pts[i];
		        const vj = (chainObj._vel && chainObj._vel[j]) ? chainObj._vel[j] : pts[j];
		        const vix = ("vx" in vi) ? vi.vx : ("xv" in vi ? vi.xv : 0);
		        const viy = ("vy" in vi) ? vi.vy : ("yv" in vi ? vi.yv : 0);
		        const vjx = ("vx" in vj) ? vj.vx : ("xv" in vj ? vj.xv : 0);
		        const vjy = ("vy" in vj) ? vj.vy : ("yv" in vj ? vj.yv : 0);
		        const vmx = 0.5 * (vix + vjx), vmy = 0.5 * (viy + vjy);
		        const vNormal = vmx * nx + vmy * ny; // outward positive
		        fMag -= kd * vNormal * elen;
		      }

		      // per-edge safety clamp
		      const maxPerEdge = springConstant * 0.15 * elen;
		      if (fMag >  maxPerEdge) fMag =  maxPerEdge;
		      if (fMag < -maxPerEdge) fMag = -maxPerEdge;

		      const fx = (fMag * nx) * 0.5;
		      const fy = (fMag * ny) * 0.5;

		      if (!pts[i].pinned) { chainObj._forces[i].x += fx; chainObj._forces[i].y += fy; }
		      if (!pts[j].pinned) { chainObj._forces[j].x += fx; chainObj._forces[j].y += fy; }
		    }
		  }
		}
		// --- end equilibrium ---


				// If this chain is currently being dragged
				if (dragMode && cIndex === draggingChainIndex && draggingDotIndex !== null) {
					SFX.drag();
					const dot = arr[draggingDotIndex],
						dx = currentMouseX - dot.x,
						dy = currentMouseY - dot.y,
						dist = Math.sqrt(dx * dx + dy * dy);
					if (dist > 1e-4) {
						const nx = dx / dist,
							ny = dy / dist,
							f = 0.2 * dist;
						forces[draggingDotIndex].x += f * nx;
						forces[draggingDotIndex].y += f * ny;
					}
				}

				// Integrate
				for (let i = 0; i < arr.length; i++) {
					const d = arr[i];
					const isDraggingThisDot = (dragMode && cIndex === draggingChainIndex && i === draggingDotIndex);
					if (d.pinned && !isDraggingThisDot) {
						d.vx = 0;
						d.vy = 0;
						continue;
					}
					if (gravityEnabled) {
						d.vy += gravityAccel * (timeStep / 60);
					}
					d.vx = (d.vx + forces[i].x * timeStep) * damping;
					d.vy = (d.vy + forces[i].y * timeStep) * damping;

					d.x += d.vx * timeStep;
					d.y += d.vy * timeStep;
				}
			}

			function simulateInterChainRepulsion() {
				// PERFORMANCE: Rebuild spatial hash (positions changed during physics)
				spatialHashCache.needsRebuild = true;
				buildSpatialHash();

				// PERFORMANCE: Iterate Map directly — avoids Array.from(keys) allocation per frame
				for (const [key, points] of spatialHash) {
					const cx = key >> 16;
					const cy = (key << 16) >> 16;

					for (let pi = 0, pLen = points.length; pi < pLen; pi++) {
						const pt = points[pi];
						const A = chains[pt.c];
						if (A.frozen) continue;
						const dotA = pt.p;
						const rA = pt.r;
						const ptC = pt.c;
						const ptI = pt.i;

						for (let ni = 0; ni < 9; ni++) {
							const nKey = hashKey(cx + neighborOffsets[ni][0], cy + neighborOffsets[ni][1]);
							const neighborPoints = spatialHash.get(nKey);
							if (neighborPoints === undefined) continue;

							for (let npi = 0, npLen = neighborPoints.length; npi < npLen; npi++) {
								const nPt = neighborPoints[npi];
							    const sameChain = (nPt.c === ptC);

							    if (sameChain) {
							        let di = ptI - nPt.i;
							        if (di < 0) di = -di;
							        const chainLen = chains[ptC].chain.length;
							        const di2 = chainLen - di;
							        if (di2 < di) di = di2;
							        if (di <= 1) continue;
							    }

							    const B = chains[nPt.c];
							    if (B.frozen) continue;
							    const dotB = nPt.p;
							    const minD = rA + nPt.r;

							    const dx = dotB.x - dotA.x;
							    const dy = dotB.y - dotA.y;
							    const distSq = dx * dx + dy * dy;
							    const minDSq = minD * minD;

							    if (distSq > 0 && distSq < minDSq) {
							        const dist = Math.sqrt(distSq);
							        const overlap = minD - dist;
							        const invDist = 1 / dist;
							        const nx = dx * invDist;
							        const ny = dy * invDist;
							        const repelMult = sameChain ? 1.0 : interRepelMult;
							        const f = repulsionConstant * repelMult * overlap;
							        if (!dotA.pinned) {
							            dotA.vx -= f * nx * timeStep;
							            dotA.vy -= f * ny * timeStep;
							        }
							        if (!dotB.pinned) {
							            dotB.vx += f * nx * timeStep;
							            dotB.vy += f * ny * timeStep;
							        }
							    }
							}
						}
					}
				}
			}

			function simulateCircleRepulsion() {
				const hardWall = (interRepelMult === 3); // Cache this check outside loops
				const circleRadiusSq = circles.length > 0 ? circles[0].radius * circles[0].radius : 0; // Pre-calculate if all circles same size

				for (let c = 0; c < circles.length; c++) {
					const circle = circles[c];
					const circleRadius = circle.radius;
					const circleRadiusSq = circleRadius * circleRadius; // Squared for comparison

					for (let ch = 0; ch < chains.length; ch++) {
						if (chains[ch].frozen) continue;
						const arr = chains[ch].chain;
						const dotR = chains[ch].baseDotRadius * dotScaleFactor;

						if (hardWall) { // ─── HARD mode ───
							const minD = circleRadius + dotR;
							const minDSq = minD * minD;

							for (let i = 0; i < arr.length; i++) {
								const d = arr[i];
								const dx = d.x - circle.x;
								const dy = d.y - circle.y;
								const distSq = dx * dx + dy * dy;

								// Early exit with squared distance
								if (distSq < minDSq && distSq > 0) {
									const dist = Math.sqrt(distSq);
									const invDist = 1 / dist;
									const nx = dx * invDist;
									const ny = dy * invDist;
									d.x = circle.x + nx * minD;
									d.y = circle.y + ny * minD;
									d.vx = d.vy = 0;
								}
							}
						} else { // ─── SOFT mode ───
							for (let i = 0; i < arr.length; i++) {
								const d = arr[i];
								const dx = d.x - circle.x;
								const dy = d.y - circle.y;
								const distSq = dx * dx + dy * dy;

								// Early exit: only calculate sqrt if inside circle
								if (distSq > 1e-8 && distSq < circleRadiusSq) {
									const dist = Math.sqrt(distSq);
									const f = repulsionConstant * (circleRadius - dist);
									if (!d.pinned) {
										const invDist = 1 / dist;
										d.vx += f * (dx * invDist);
										d.vy += f * (dy * invDist);
									}
								}
							}
						}
					}
				}
			}

			// PERFORMANCE: Reusable point object for closest-point calculations (avoids per-vertex allocation)
			const _arClosestPt = { x: 0, y: 0 };

			// Simulate attractor/repulsor forces
			function simulateAttractorRepulsorForces() {
				const arLen = attractorsRepulsors.length;
				if (arLen === 0) return;

				// Force strength - make it stronger than noise to be noticeable
				const baseForceStrength = 0.3;
				const influenceRadius = 100;
				const influenceRadiusSq = influenceRadius * influenceRadius;
				const invInfluenceRadius = 1 / influenceRadius;

				// PERFORMANCE: Cache segment lengths on AR objects (only recalc when path changes)
				for (let ai = 0; ai < arLen; ai++) {
					const ar = attractorsRepulsors[ai];
					if (ar.path.length < 2) continue;
					const pLen = ar.path.length - 1;
					// Lazily compute and cache segment lengths + total path length
					if (!ar._segLens || ar._segLens.length !== pLen || ar._pathDirty !== false) {
						if (!ar._segLens || ar._segLens.length !== pLen) ar._segLens = new Float64Array(pLen);
						let total = 0;
						for (let i = 0; i < pLen; i++) {
							const p1 = ar.path[i], p2 = ar.path[i + 1];
							const dx = p2.x - p1.x, dy = p2.y - p1.y;
							const segLen = Math.sqrt(dx * dx + dy * dy);
							ar._segLens[i] = segLen;
							total += segLen;
						}
						ar._totalPathLen = total;
						ar._pathDirty = false;
					}
				}

				// PERFORMANCE: Hoist Date.now() outside all loops (one syscall per frame, not per vertex)
				const timeNow = Date.now() / 1000;
				const hardWall = (interRepelMult === 3);

				// PERFORMANCE: Use index-based loops instead of forEach (avoids closure allocation)
				for (let ci = 0, cLen = chains.length; ci < cLen; ci++) {
					const chainObj = chains[ci];
					if (chainObj.frozen) continue;
					const ch = chainObj.chain;
					const chLen = ch.length;

					for (let vi = 0; vi < chLen; vi++) {
						const dot = ch[vi];
						if (dot.pinned) continue;

						let closestAR = null;
						let minDistSq = Infinity;
						let closestPx = 0, closestPy = 0;
						let closestSegmentIndex = -1;
						let closestT = 0;
						let closestPathPosition = 0;

						for (let ai = 0; ai < arLen; ai++) {
							const ar = attractorsRepulsors[ai];
							const pathLen = ar.path.length;
							if (pathLen < 2) continue;

							let localMinDistSq = Infinity;
							let localPx = 0, localPy = 0;
							let localSegIdx = -1;
							let localT = 0;

							const segments = pathLen - 1;
							for (let i = 0; i < segments; i++) {
								const p1 = ar.path[i], p2 = ar.path[i + 1];
								const sdx = p2.x - p1.x, sdy = p2.y - p1.y;
								const lenSq = sdx * sdx + sdy * sdy;

								let distSq, px, py, t;
								if (lenSq < 1e-8) {
									px = p1.x; py = p1.y; t = 0;
									const ex = dot.x - p1.x, ey = dot.y - p1.y;
									distSq = ex * ex + ey * ey;
								} else {
									t = ((dot.x - p1.x) * sdx + (dot.y - p1.y) * sdy) / lenSq;
									if (t < 0) t = 0; else if (t > 1) t = 1;
									px = p1.x + t * sdx;
									py = p1.y + t * sdy;
									const ex = dot.x - px, ey = dot.y - py;
									distSq = ex * ex + ey * ey;
								}

								if (distSq < localMinDistSq) {
									localMinDistSq = distSq;
									localPx = px; localPy = py;
									localSegIdx = i; localT = t;
								}
							}

							if (localMinDistSq < minDistSq && localMinDistSq < influenceRadiusSq) {
								// Calculate path position using cached segment lengths
								let pathPosition = 0;
								const totalLen = ar._totalPathLen;
								if (totalLen > 0 && localSegIdx >= 0) {
									const segLens = ar._segLens;
									let posLength = 0;
									for (let i = 0; i < localSegIdx; i++) posLength += segLens[i];
									posLength += segLens[localSegIdx] * localT;
									pathPosition = posLength / totalLen;
								}

								minDistSq = localMinDistSq;
								closestAR = ar;
								closestPx = localPx; closestPy = localPy;
								closestSegmentIndex = localSegIdx;
								closestT = localT;
								closestPathPosition = pathPosition;
							}
						}

						// Apply force only from the closest attractor/repulsor (if any)
						if (closestAR && minDistSq < influenceRadiusSq) {
							const dist = Math.sqrt(minDistSq);
							const dx = closestPx - dot.x;
							const dy = closestPy - dot.y;

							if (dist > 1e-8) {
								const invDist = 1 / dist;
								const isAttractor = closestAR.type === 'attractor';

								if (isAttractor) {
									if (closestAR.gradientMode && closestSegmentIndex >= 0 && closestSegmentIndex < closestAR.path.length - 1) {
										const p1 = closestAR.path[closestSegmentIndex];
										const p2 = closestAR.path[closestSegmentIndex + 1];
										const segDx = p2.x - p1.x, segDy = p2.y - p1.y;
										const segLen = closestAR._segLens[closestSegmentIndex];

										if (segLen > 1e-8) {
											const invSegLen = 1 / segLen;
											const segDirX = segDx * invSegLen, segDirY = segDy * invSegLen;

											let direction = 1;
											if (closestAR.gradientMode === 'backward') direction = -1;

											let gradientStrength;
											const curve = closestAR.gradientCurve;
											if (curve && Array.isArray(curve) && curve.length > 0) {
												const curveIndex = Math.floor(closestPathPosition * (curve.length - 1));
												const nextIndex = Math.min(curveIndex + 1, curve.length - 1);
												const t = (closestPathPosition * (curve.length - 1)) - curveIndex;
												gradientStrength = curve[curveIndex] * (1 - t) + curve[nextIndex] * t;
											} else {
												gradientStrength = closestAR.gradientMode === 'forward'
													? 1.0 - closestPathPosition : closestPathPosition;
											}

											const temporalMode = closestAR.temporalMode || 'none';
											if (temporalMode !== 'none') {
												const frequency = closestAR.temporalFrequency !== undefined ? closestAR.temporalFrequency : 1.0;
												const amplitude = closestAR.temporalAmplitude !== undefined ? closestAR.temporalAmplitude : 0.5;

												if (temporalMode === 'oscillate') {
													const oscillation = Math.sin(timeNow * frequency * Math.PI * 2);
													gradientStrength = gradientStrength * (1.0 + oscillation * amplitude);
													if (gradientStrength < 0) gradientStrength = 0;
													else if (gradientStrength > 1) gradientStrength = 1;
												} else if (temporalMode === 'shift') {
													const shiftAmount = (Math.sin(timeNow * frequency * Math.PI * 2) * 0.5 + 0.5) * amplitude;
													const shiftDir = closestAR.shiftDirection === 'backward' ? -1 : 1;
													let shiftedPos = closestPathPosition + (shiftAmount * shiftDir);
													if (shiftedPos < 0) shiftedPos = 1 + shiftedPos;
													if (shiftedPos > 1) shiftedPos = shiftedPos - 1;

													if (curve && Array.isArray(curve) && curve.length > 0) {
														const ci2 = Math.floor(shiftedPos * (curve.length - 1));
														const ni = Math.min(ci2 + 1, curve.length - 1);
														const t = (shiftedPos * (curve.length - 1)) - ci2;
														gradientStrength = curve[ci2] * (1 - t) + curve[ni] * t;
													} else {
														gradientStrength = closestAR.gradientMode === 'forward'
															? 1.0 - shiftedPos : shiftedPos;
													}
												} else if (temporalMode === 'reverse') {
													const togglePeriod = 1.0 / frequency;
													if (Math.floor(timeNow / togglePeriod) % 2 === 1) direction = -direction;
												}
											}

											const distanceFactor = 1.0 - (dist * invInfluenceRadius);
											const force = baseForceStrength * distanceFactor * gradientStrength * 1.5;
											dot.vx += force * direction * segDirX;
											dot.vy += force * direction * segDirY;

											const pullForce = baseForceStrength * distanceFactor * 0.3;
											dot.vx += pullForce * (dx * invDist);
											dot.vy += pullForce * (dy * invDist);
										}
									} else {
										const distanceFactor = 1.0 - (dist * invInfluenceRadius);
										const force = baseForceStrength * distanceFactor;
										dot.vx += force * (dx * invDist);
										dot.vy += force * (dy * invDist);
									}
								} else {
									if (hardWall) {
										const boundaryThickness = 5;
										const dotR = chainObj.baseDotRadius * dotScaleFactor;
										const minDist = boundaryThickness + dotR;
										if (minDistSq < minDist * minDist) {
											const nx = dx * invDist, ny = dy * invDist;
											dot.x = closestPx - nx * minDist;
											dot.y = closestPy - ny * minDist;
											dot.vx = 0; dot.vy = 0;
										}
									} else {
										const distanceFactor = 1.0 - (dist * invInfluenceRadius);
										const force = baseForceStrength * distanceFactor;
										const repulsorForce = force * 1.5;
										dot.vx -= repulsorForce * repulsionConstant * (dx * invDist);
										dot.vy -= repulsorForce * repulsionConstant * (dy * invDist);
									}
								}
							}
						}
					}
				}
			}

			/* -----------------------------------
			   RENDERING
			----------------------------------- */
			function drawGrid(size = 20) {
				const w = canvas.width,
					h = canvas.height;
				// PERFORMANCE: Cache grid vertices — only rebuild when canvas size changes
				if (size !== _gridCacheSize || w !== _gridCacheW || h !== _gridCacheH) {
					let gridVerts = [];
					for (let x = 0; x <= w; x += size) {
						gridVerts.push(x, 0, x, h);
					}
					for (let y = 0; y <= h; y += size) {
						gridVerts.push(0, y, w, y);
					}
					_gridVerts = new Float32Array(gridVerts);
					_gridCacheSize = size;
					_gridCacheW = w;
					_gridCacheH = h;
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, _gridVerts, gl.STATIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, w, h);
				gl.uniform4fv(lineColorLoc, [0.45, 0.50, 0.45, 1.0]);
				gl.drawArrays(gl.LINES, 0, _gridVerts.length / 2);
			}

			// PERFORMANCE: Pre-compute pinned indicator unit circle and reuse Float32Array
			const _PIN_SEG = 12;
			const _pinUnitCircle = new Float32Array(_PIN_SEG * 2);
			for (let i = 0; i < _PIN_SEG; i++) {
				const t = i * (2 * Math.PI / _PIN_SEG);
				_pinUnitCircle[i * 2]     = Math.cos(t);
				_pinUnitCircle[i * 2 + 1] = Math.sin(t);
			}
			const _pinVerts = new Float32Array(_PIN_SEG * 2);
			const _pinColor = new Float32Array([1.0, 0.0, 0.0, 1.0]);

			function drawPinnedIndicator(x, y) {
				const rad = _isIPad ? 8 : 4;
				for (let i = 0; i < _PIN_SEG; i++) {
					_pinVerts[i * 2]     = x + rad * _pinUnitCircle[i * 2];
					_pinVerts[i * 2 + 1] = y + rad * _pinUnitCircle[i * 2 + 1];
				}
				gl.bufferData(gl.ARRAY_BUFFER, _pinVerts, gl.DYNAMIC_DRAW);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform4fv(lineColorLoc, _pinColor);
				gl.drawArrays(gl.LINE_LOOP, 0, _PIN_SEG);
			}

			// Draw attractors/repulsors with pulsating effect
			function drawAttractorsRepulsors() {
				// Don't draw during export (they should be invisible in exports)
				if (filmstripData.isExporting) return;
				// Don't draw in presentation mode
				if (isPresentationMode) return;
				if (attractorsRepulsors.length === 0) return;

				// Pulsating effect: opacity oscillates between 0.3 and 0.7
				const time = Date.now() / 1000; // Time in seconds
				const pulseSpeed = 2.0; // Pulses per second
				const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * pulseSpeed * Math.PI * 2));

				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

				attractorsRepulsors.forEach(ar => {
					if (ar.path.length < 2) return;

					const isAttractor = ar.type === 'attractor';
					const thickness = ar.gradientMode ? 10 : 8;
					const opacity = ar.gradientMode ? Math.min(1.0, pulse * 1.2) : pulse;

					// If gradient mode, draw with color gradient along path
					if (isAttractor && ar.gradientMode) {
						// Calculate total path length (used for both gradient and arrow indicators)
						let totalLength = 0;
						const segmentLengths = [];
						for (let i = 0; i < ar.path.length - 1; i++) {
							const p1 = ar.path[i];
							const p2 = ar.path[i + 1];
							const segLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
							segmentLengths.push(segLen);
							totalLength += segLen;
						}

						// Draw each segment with gradient color
						let accumulatedLength = 0;
						for (let i = 0; i < ar.path.length - 1; i++) {
							const p1 = ar.path[i];
							const p2 = ar.path[i + 1];

							// Calculate position along path (0 to 1)
							const segLen = segmentLengths[i];
							const posStart = totalLength > 0 ? accumulatedLength / totalLength : 0;
							const posEnd = totalLength > 0 ? (accumulatedLength + segLen) / totalLength : 1;

							// Interpolate color based on position and gradient mode
							let r1, g1, b1, r2, g2, b2;

							if (ar.gradientMode === 'forward') {
								// Forward: darker/stronger at start (0), lighter at end (1)
								// Start color (darker cyan)
								r1 = 0.0;
								g1 = 0.4;
								b1 = 1.0;
								// End color (lighter cyan)
								r2 = 0.3;
								g2 = 0.9;
								b2 = 1.0;
							} else {
								// Backward: lighter at start (0), darker/stronger at end (1)
								// Start color (lighter cyan)
								r1 = 0.3;
								g1 = 0.9;
								b1 = 1.0;
								// End color (darker cyan)
								r2 = 0.0;
								g2 = 0.4;
								b2 = 1.0;
							}

							// Draw segment with gradient color at midpoint for smoother transition
							const posMid = (posStart + posEnd) / 2;
							const r = r1 + (r2 - r1) * posMid;
							const g = g1 + (g2 - g1) * posMid;
							const b = b1 + (b2 - b1) * posMid;

							const thickVerts = getThickLineVerticesOpen([p1.x, p1.y, p2.x, p2.y], thickness);

							if (thickVerts.length > 0) {
								gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
								gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(thickVerts), gl.DYNAMIC_DRAW);
								gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
								gl.uniform4fv(lineColorLoc, [r, g, b, opacity]);
								gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
							}

							accumulatedLength += segLen;
						}

						// Draw arrow indicator at the end of the path to show direction
						if (ar.path.length >= 2) {
							let arrowX, arrowY, arrowDirX, arrowDirY;

							if (ar.gradientMode === 'forward') {
								// Arrow at the end, pointing forward
								const lastIdx = ar.path.length - 1;
								const prevIdx = lastIdx - 1;
								arrowX = ar.path[lastIdx].x;
								arrowY = ar.path[lastIdx].y;
								const dx = arrowX - ar.path[prevIdx].x;
								const dy = arrowY - ar.path[prevIdx].y;
								const len = Math.hypot(dx, dy);
								if (len > 0) {
									arrowDirX = dx / len;
									arrowDirY = dy / len;
								} else {
									arrowDirX = 1;
									arrowDirY = 0;
								}
							} else {
								// Arrow at the start, pointing backward
								arrowX = ar.path[0].x;
								arrowY = ar.path[0].y;
								const dx = ar.path[1].x - arrowX;
								const dy = ar.path[1].y - arrowY;
								const len = Math.hypot(dx, dy);
								if (len > 0) {
									arrowDirX = -dx / len;
									arrowDirY = -dy / len;
								} else {
									arrowDirX = -1;
									arrowDirY = 0;
								}
							}

							// Apply temporal morphogenesis effects to arrow
							const temporalMode = ar.temporalMode || 'none';
							let arrowSize = 12;
							let arrowOpacity = opacity;
							
							if (temporalMode === 'oscillate') {
								// Pulse the arrow size based on oscillation
								const frequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
								const amplitude = ar.temporalAmplitude !== undefined ? ar.temporalAmplitude : 0.5;
								const oscillation = Math.sin(time * frequency * Math.PI * 2);
								arrowSize = 12 * (1.0 + oscillation * amplitude * 0.5); // Scale between 0.5x and 1.5x
								arrowOpacity = opacity * (1.0 + oscillation * amplitude * 0.3); // Pulse opacity too
							} else if (temporalMode === 'shift') {
								// Show shifting effect with multiple arrows or pulsing
								const frequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
								const shiftPhase = Math.sin(time * frequency * Math.PI * 2);
								arrowSize = 12 * (1.0 + Math.abs(shiftPhase) * 0.3); // Pulse based on shift phase
								arrowOpacity = opacity * (0.7 + Math.abs(shiftPhase) * 0.3); // Vary opacity
							} else if (temporalMode === 'reverse') {
								// Reverse mode: toggle arrow direction to match the force direction
								const frequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
								const togglePeriod = 1.0 / frequency;
								const togglePhase = Math.floor(time / togglePeriod) % 2;
								
								// Reverse the arrow direction when togglePhase is 1 (same logic as force direction)
								if (togglePhase === 1) {
									arrowDirX = -arrowDirX;
									arrowDirY = -arrowDirY;
								}
								
								// Pulse arrow size slightly to show it's active
								arrowSize = 12 * 1.1;
								arrowOpacity = opacity;
							} else if (temporalMode === 'reverse') {
								// Reverse mode: smoothly oscillate arrow direction
								const frequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
								const amplitude = ar.temporalAmplitude !== undefined ? ar.temporalAmplitude : 0.5;
								const directionOscillation = Math.sin(time * frequency * Math.PI * 2);
								
								// Reverse the arrow direction based on oscillation
								// When oscillation is positive, keep original direction
								// When oscillation is negative, reverse direction
								if (directionOscillation < 0 && amplitude > 0.1) {
									// Reverse the arrow direction
									arrowDirX = -arrowDirX;
									arrowDirY = -arrowDirY;
								}
								
								// Pulse arrow size and opacity to show direction change
								arrowSize = 12 * (1.0 + Math.abs(directionOscillation) * amplitude * 0.3);
								arrowOpacity = opacity * (0.8 + Math.abs(directionOscillation) * 0.2);
							}

							// Perpendicular direction for arrow base
							const perpX = -arrowDirY;
							const perpY = arrowDirX;

							// Arrow tip
							const tipX = arrowX + arrowDirX * arrowSize;
							const tipY = arrowY + arrowDirY * arrowSize;

							// Arrow base points
							const baseX1 = arrowX + perpX * arrowSize * 0.5;
							const baseY1 = arrowY + perpY * arrowSize * 0.5;
							const baseX2 = arrowX - perpX * arrowSize * 0.5;
							const baseY2 = arrowY - perpY * arrowSize * 0.5;

							// Create arrow triangle vertices
							const arrowVerts = [
								tipX, tipY,
								baseX1, baseY1,
								baseX2, baseY2
							];

							gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
							gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arrowVerts), gl.DYNAMIC_DRAW);
							gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
							// Use end color for arrow (darker for visibility)
							const arrowR = ar.gradientMode === 'forward' ? 0.0 : 0.0;
							const arrowG = ar.gradientMode === 'forward' ? 0.4 : 0.4;
							const arrowB = ar.gradientMode === 'forward' ? 1.0 : 1.0;
							gl.uniform4fv(lineColorLoc, [arrowR, arrowG, arrowB, Math.min(1.0, arrowOpacity)]);
							gl.drawArrays(gl.TRIANGLES, 0, 3);
							
							// For shift mode, draw additional indicator arrows along the path
							if (temporalMode === 'shift' && ar.path.length > 2) {
								const frequency = ar.temporalFrequency !== undefined ? ar.temporalFrequency : 1.0;
								const shiftPhase = (Math.sin(time * frequency * Math.PI * 2) * 0.5 + 0.5); // 0 to 1
								const shiftDirection = ar.shiftDirection === 'backward' ? -1 : 1;
								
								// Draw a few small indicator arrows along the path to show shifting
								const numIndicators = 3;
								for (let i = 0; i < numIndicators; i++) {
									let indicatorPos = (i / (numIndicators - 1) + shiftPhase * shiftDirection) % 1.0;
									if (indicatorPos < 0) indicatorPos = 1 + indicatorPos;
									
									// Find position along path
									let accumulatedLength = 0;
									let targetLength = indicatorPos * totalLength;
									let found = false;
									
									for (let j = 0; j < ar.path.length - 1 && !found; j++) {
										const p1 = ar.path[j];
										const p2 = ar.path[j + 1];
										const segLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
										
										if (accumulatedLength + segLen >= targetLength) {
											const t = (targetLength - accumulatedLength) / segLen;
											const indX = p1.x + (p2.x - p1.x) * t;
											const indY = p1.y + (p2.y - p1.y) * t;
											
											// Draw small indicator arrow
											const indDx = p2.x - p1.x;
											const indDy = p2.y - p1.y;
											const indLen = Math.hypot(indDx, indDy);
											if (indLen > 0) {
												const indDirX = indDx / indLen;
												const indDirY = indDy / indLen;
												const indSize = 6;
												const indPerpX = -indDirY;
												const indPerpY = indDirX;
												
												const indVerts = [
													indX + indDirX * indSize, indY + indDirY * indSize,
													indX + indPerpX * indSize * 0.3, indY + indPerpY * indSize * 0.3,
													indX - indPerpX * indSize * 0.3, indY - indPerpY * indSize * 0.3
												];
												
												gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(indVerts), gl.DYNAMIC_DRAW);
												gl.uniform4fv(lineColorLoc, [arrowR, arrowG, arrowB, opacity * 0.4]);
												gl.drawArrays(gl.TRIANGLES, 0, 3);
											}
											found = true;
										}
										accumulatedLength += segLen;
									}
								}
							}
						}
					} else {
						// Normal mode: draw entire path with single color
						let r, g, b;

						// Normal colors: green for attractor, red for repulsor
						r = isAttractor ? 0.0 : 1.0;
						g = isAttractor ? 1.0 : 0.0;
						b = 0.0;

						const vertices = [];

						for (let i = 0; i < ar.path.length - 1; i++) {
							const p1 = ar.path[i];
							const p2 = ar.path[i + 1];
							const thickVerts = getThickLineVerticesOpen([p1.x, p1.y, p2.x, p2.y], thickness);
							vertices.push(...thickVerts);
						}

						if (vertices.length > 0) {
							gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
							gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
							gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
							gl.uniform4fv(lineColorLoc, [r, g, b, opacity]);
							gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
						}
					}
				});
			}

			function drawHoverIndicator(dot, isPinned) {
				const seg = 12,
					radius = 8;
				let verts = [];
				for (let i = 0; i < seg; i++) {
					const t = i * (2 * Math.PI / seg);
					verts.push(dot.x + radius * Math.cos(t),
						dot.y + radius * Math.sin(t));
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				const color = isPinned ? [1.0, 0.2, 0.2, 1.0] : [0.00, 1.00, 0.50, 1];
				gl.uniform4fv(lineColorLoc, color);
				gl.drawArrays(gl.LINE_LOOP, 0, seg);
			}

			/* -----------------------------------
			   TRAVELING SEGMENT FUNCTIONS
			----------------------------------- */
			// Calculate the total perimeter length of a spline
			function calculateSplineLength(spline) {
				let totalLength = 0;
				const n = spline.length / 2;
				for (let i = 0; i < n; i++) {
					const x1 = spline[i * 2];
					const y1 = spline[i * 2 + 1];
					const x2 = spline[((i + 1) % n) * 2];
					const y2 = spline[((i + 1) % n) * 2 + 1];
					const dx = x2 - x1;
					const dy = y2 - y1;
					totalLength += Math.sqrt(dx * dx + dy * dy);
				}
				return totalLength;
			}

			// Extract a segment from the spline starting at a given distance along the perimeter
			function extractTravelingSegment(spline, startDistance, segmentLength) {
				const n = spline.length / 2;
				const totalLength = calculateSplineLength(spline);

				// Normalize startDistance to be within [0, totalLength)
				startDistance = ((startDistance % totalLength) + totalLength) % totalLength;

				const segment = [];
				let currentDistance = 0;
				let segmentRemaining = segmentLength;
				let foundStart = false;
				let iterations = 0;
				const maxIterations = n * 2; // Prevent infinite loops

				// Iterate through spline points, potentially wrapping around
				for (let iter = 0; iter < maxIterations && segmentRemaining > 0.01; iter++) {
					const i = iter % n;
					const x1 = spline[i * 2];
					const y1 = spline[i * 2 + 1];
					const x2 = spline[((i + 1) % n) * 2];
					const y2 = spline[((i + 1) % n) * 2 + 1];

					const dx = x2 - x1;
					const dy = y2 - y1;
					const segmentLen = Math.sqrt(dx * dx + dy * dy);
					if (segmentLen < 0.001) continue; // Skip zero-length segments

					const nextDistance = currentDistance + segmentLen;

					if (!foundStart) {
						if (nextDistance >= startDistance) {
							// Start point is on this segment
							const t = (startDistance - currentDistance) / segmentLen;
							const startX = x1 + dx * t;
							const startY = y1 + dy * t;
							segment.push(startX, startY);
							foundStart = true;

							// Check if the entire segment fits in this spline segment
							const remainingInSegment = nextDistance - startDistance;
							if (remainingInSegment >= segmentRemaining) {
								// End point is also on this segment
								const endT = (startDistance + segmentRemaining - currentDistance) / segmentLen;
								const endX = x1 + dx * endT;
								const endY = y1 + dy * endT;
								segment.push(endX, endY);
								break;
							} else {
								// Continue to next segment
								segment.push(x2, y2);
								segmentRemaining -= remainingInSegment;
							}
						}
					} else {
						// We're collecting points for the segment
						if (segmentLen >= segmentRemaining) {
							// End point is on this segment
							const t = segmentRemaining / segmentLen;
							const endX = x1 + dx * t;
							const endY = y1 + dy * t;
							segment.push(endX, endY);
							break;
						} else {
							// Add this point and continue
							segment.push(x2, y2);
							segmentRemaining -= segmentLen;
						}
					}

					currentDistance = nextDistance;
				}

				return new Float32Array(segment);
			}

			// GPU-based rendering function (reads from GPU textures, no readPixels)
			function drawChainFromGPU(chainObj, chainIndex) {
				if (!gpuPhysics.initialized || !gpuPhysics.renderProgram || gpuPhysics.chainStartIndices[chainIndex] === undefined) {
					// Fallback to CPU rendering
					drawChain(chainObj, chainIndex);
					return;
				}

				// Get chain length from vertex mapping (avoid accessing chain.chain which requires CPU data)
				let chainLength = 0;
				for (let i = 0; i < gpuPhysics.vertexMapping.length; i++) {
					if (gpuPhysics.vertexMapping[i].chainIndex === chainIndex) {
						chainLength++;
					}
				}
				if (chainLength < 2) {
					// Fallback to CPU for very short chains
					drawChain(chainObj, chainIndex);
					return;
				}

				const chainStartIndex = gpuPhysics.chainStartIndices[chainIndex];
				// PERFORMANCE: Reduce spline segments on iPad for better performance
				// Fewer segments = fewer vertices = faster rendering
				const isIPadDevice = /iPad/i.test(navigator.userAgent) ||
					(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
				const splineSegments = isIPadDevice ? 5 : 10; // Half the segments on iPad
				const totalSplinePoints = chainObj.isClosed ? chainLength * splineSegments : (chainLength - 1) * splineSegments;

				// Generate spline indices (0, 1, 2, ... totalSplinePoints-1)
				if (!gpuPhysics.splineIndices || gpuPhysics.splineIndices.length < totalSplinePoints) {
					gpuPhysics.splineIndices = new Float32Array(totalSplinePoints);
					for (let i = 0; i < totalSplinePoints; i++) {
						gpuPhysics.splineIndices[i] = i;
					}
				}

				const locs = gpuPhysics.renderUniformLocations;
				const attrs = gpuPhysics.renderAttribLocations;

				// Use GPU render program
				gl.useProgram(gpuPhysics.renderProgram);

				// Bind position texture
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, gpuPhysics.positionTextures[gpuPhysics.currentBuffer]);
				gl.uniform1i(locs.u_positionTexture, 0);

				// Set uniforms
				gl.uniform2f(locs.u_textureSize, gpuPhysics.textureWidth, gpuPhysics.textureHeight);
				gl.uniform2f(locs.u_resolution, canvas.width, canvas.height);
				gl.uniform1f(locs.u_chainStartIndex, chainStartIndex);
				gl.uniform1f(locs.u_chainLength, chainLength);
				gl.uniform1f(locs.u_isClosed, chainObj.isClosed ? 1.0 : 0.0);
				gl.uniform1f(locs.u_splineSegments, splineSegments);
				gl.uniform4fv(locs.u_color, chainObj.color);

				// Set up vertex attribute
				gl.bindBuffer(gl.ARRAY_BUFFER, gpuPhysics.splineBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, gpuPhysics.splineIndices.subarray(0, totalSplinePoints), gl.DYNAMIC_DRAW);
				gl.enableVertexAttribArray(attrs.a_splineIndex);
				gl.vertexAttribPointer(attrs.a_splineIndex, 1, gl.FLOAT, false, 0, 0);

				// For filled blobs, use stencil technique (same as CPU version)
				if (showFilled && chainObj.isClosed) {
					gl.clear(gl.STENCIL_BUFFER_BIT);
					gl.enable(gl.STENCIL_TEST);
					gl.colorMask(false, false, false, false);
					gl.stencilFunc(gl.ALWAYS, 0, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);

					// Draw spline as line strip for stencil
					gl.drawArrays(gl.LINE_STRIP, 0, totalSplinePoints);

					// Fill stencil area
					const rgba = chainObj.color.slice();
					rgba[3] = chainObj.alpha ?? 1.0;
					gl.uniform4fv(locs.u_color, rgba);
					gl.colorMask(true, true, true, true);
					gl.stencilFunc(gl.EQUAL, 1, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

					// Draw full-screen quad for fill
					gl.useProgram(lineProgram);
					_fillQuad[0]=0; _fillQuad[1]=0;
					_fillQuad[2]=canvas.width; _fillQuad[3]=0;
					_fillQuad[4]=canvas.width; _fillQuad[5]=canvas.height;
					_fillQuad[6]=0; _fillQuad[7]=0;
					_fillQuad[8]=canvas.width; _fillQuad[9]=canvas.height;
					_fillQuad[10]=0; _fillQuad[11]=canvas.height;
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, _fillQuad, gl.STATIC_DRAW);
					gl.enableVertexAttribArray(linePosLoc);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform2f(lineResLoc, canvas.width, canvas.height);
					gl.uniform4fv(lineColorLoc, rgba);
					gl.drawArrays(gl.TRIANGLES, 0, 6);

					gl.disable(gl.STENCIL_TEST);

					// Draw outline if enabled
					if (showOutline && showFilled) {
						// For now, use CPU rendering for thick outlines (can be optimized later)
						drawChain(chainObj, chainIndex);
						return;
					}

					// Draw pinned indicators and hover
					// For GPU rendering, we skip these to avoid readPixels
					// They will be drawn by CPU rendering fallback if needed
					// (Pinned/hover indicators are rare, so this is acceptable)
					return;
				}

				// Draw outline
				if (showOutline) {
					const outlineColor = chainObj.color.slice();
					outlineColor[3] = chainObj.alpha ?? 1.0;
					gl.uniform4fv(locs.u_color, outlineColor);

					// For thin outlines, render directly
					if (outlineWidth === 1) {
						gl.drawArrays(gl.LINE_STRIP, 0, totalSplinePoints);
					} else {
						// For thick outlines, fall back to CPU (can optimize later)
						drawChain(chainObj, chainIndex);
						return;
					}
				} else {
					// No outline, just draw the spline
					gl.drawArrays(gl.LINE_STRIP, 0, totalSplinePoints);
				}
			}

			function drawChain(chainObj, chainIndex) {
				const ch = chainObj.chain;
				if (ch.length < 2) return;

				// PERFORMANCE: Cache spline calculations - only recalculate when positions change
				let spline;
				const positionHash = getChainPositionHash(chainObj);
				const cacheKey = chainIndex;
				const cached = splineCache.get(cacheKey);

				if (cached && cached.hash === positionHash && cached.isClosed === chainObj.isClosed) {
					// Use cached spline
					spline = cached.spline;
				} else {
					// Recalculate spline
					spline = chainObj.isClosed ?
						getClosedSmoothCurve(ch, 10) :
						getOpenSmoothCurve(ch, 10);
					// Cache it
					splineCache.set(cacheKey, { spline, hash: positionHash, isClosed: chainObj.isClosed });
				}

				if (spline.length < 4) return;

				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.uniform4fv(lineColorLoc, chainObj.color);

				/* NEW — solid-fill branch */
				if (showFilled && chainObj.isClosed) {
					// PERFORMANCE: INVERT + ZERO self-cleaning stencil — no per-blob clear needed.
					// Step 1: INVERT toggles stencil bits for each triangle covering a pixel.
					// Inside the polygon (odd winding) → stencil becomes 0xFF.
					// Outside (even winding) → stencil stays 0x00.
					gl.enable(gl.STENCIL_TEST);
					gl.colorMask(false, false, false, false);
					gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);

					const OUT_X = -9999,
						OUT_Y = -9999; // any point off-canvas
					const tris = buildStencilTris(spline, OUT_X, OUT_Y);

					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, tris, gl.DYNAMIC_DRAW);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform4fv(lineColorLoc, chainObj.color); // colour doesn't matter
					gl.drawArrays(gl.TRIANGLES, 0, tris.length / 2);

					// PERFORMANCE: Reuse scratch array instead of .slice() per chain
					_rgbaScratch[0] = chainObj.color[0]; _rgbaScratch[1] = chainObj.color[1];
					_rgbaScratch[2] = chainObj.color[2]; _rgbaScratch[3] = chainObj.alpha ?? 1.0;
					gl.uniform4fv(lineColorLoc, _rgbaScratch);

					// Step 2: draw full-screen quad wherever stencil is non-zero (= inside the blob).
					// ZERO op resets stencil back to 0 as we draw, so next blob starts clean.
					gl.colorMask(true, true, true, true);
					gl.stencilFunc(gl.NOTEQUAL, 0, 0xFF);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.ZERO);

					_fillQuad[0]=0; _fillQuad[1]=0;
					_fillQuad[2]=canvas.width; _fillQuad[3]=0;
					_fillQuad[4]=canvas.width; _fillQuad[5]=canvas.height;
					_fillQuad[6]=0; _fillQuad[7]=0;
					_fillQuad[8]=canvas.width; _fillQuad[9]=canvas.height;
					_fillQuad[10]=0; _fillQuad[11]=canvas.height;
					gl.bufferData(gl.ARRAY_BUFFER, _fillQuad, gl.STATIC_DRAW);
					gl.enableVertexAttribArray(linePosLoc);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform2f(lineResLoc, canvas.width, canvas.height);
					gl.drawArrays(gl.TRIANGLES, 0, 6);

					// Restore line program for outline if needed
					if (showOutline && showFilled) {
						gl.useProgram(lineProgram);
					}

					gl.disable(gl.STENCIL_TEST);

					/* --- Draw outline stroke on filled blobs if both outline and filled are enabled --- */
					if (showOutline && showFilled) {
						gl.uniform4fv(lineColorLoc, _blackColor);
						const outlineVerts = getThickLineVertices(spline, outlineWidth);
						gl.bufferData(gl.ARRAY_BUFFER, outlineVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, outlineVerts.length / 2);
					}

					/* --- overlays drawn on top of the filled blob ----------------- */
					// pinned dots
					for (let i = 0; i < ch.length; i++) {
						if (ch[i].pinned) {
							gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
							drawPinnedIndicator(ch[i].x, ch[i].y);
						}
					}
					// hover ring in drag / pin mode
					if ((pinMode || dragMode) &&
						chainIndex === pinHoverChainIndex &&
						pinHoverDotIndex !== null) {
						const hoverDot = ch[pinHoverDotIndex];
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						drawHoverIndicator(hoverDot, hoverDot.pinned);
					}
					/* ---------------------------------------------------------------- */
					return; // done with this blob
					// done with this blob
				}

				/* --- existing outline code below --- */
				// Draw outline if enabled
				if (showOutline) {
					// PERFORMANCE: Reuse scratch array instead of .slice() per chain
					_rgbaScratch[0] = chainObj.color[0]; _rgbaScratch[1] = chainObj.color[1];
					_rgbaScratch[2] = chainObj.color[2]; _rgbaScratch[3] = chainObj.alpha ?? 1.0;
					gl.uniform4fv(lineColorLoc, _rgbaScratch);

					if (chainObj.frozen) {
						// Use dashed style for frozen blobs
						drawDashedSpline(spline, _rgbaScratch);
					} else if (travelingSegmentEnabled && chainObj.isClosed) {
						// Traveling segment mode - only render a segment that travels around
						const currentPerimeterLength = calculateSplineLength(spline);

						// Initialize normalized position for this chain if not exists
						if (!(chainIndex in travelingSegmentNormalizedPosition)) {
							travelingSegmentNormalizedPosition[chainIndex] = 0;
						}

						// Use normalized position (0-1) to avoid flickering when blob deforms
						// Position is updated once per frame in animate() function
						// Convert normalized position to absolute distance
						const currentPosition = travelingSegmentNormalizedPosition[chainIndex] * currentPerimeterLength;

						const segment = extractTravelingSegment(spline, currentPosition, travelingSegmentLength);

						if (segment.length >= 4) {
							if (outlineWidth === 1) {
								gl.bufferData(gl.ARRAY_BUFFER, segment, gl.DYNAMIC_DRAW);
								gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
								gl.drawArrays(gl.LINE_STRIP, 0, segment.length / 2);
							} else {
								const thickVerts = getThickLineVerticesOpen(segment, outlineWidth);
								gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
								gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
								gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
							}
						}
					} else {
						// normal stroke using outlineWidth
						if (outlineWidth === 1) {
							gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
							gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
							gl.drawArrays(gl.LINE_STRIP, 0, spline.length / 2);
						} else {
							const thickVerts = getThickLineVertices(spline, outlineWidth);
							gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
							gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
							gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
						}
					}
				}

				// pinned dots
				for (let i = 0; i < ch.length; i++) {
					if (ch[i].pinned) {
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						drawPinnedIndicator(ch[i].x, ch[i].y);
					}
				}

				// hover ring if this chain/dot is hovered in pinMode/dragMode
				if ((pinMode || dragMode) && chainIndex === pinHoverChainIndex && pinHoverDotIndex !== null) {
					const hoverDot = ch[pinHoverDotIndex];
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					drawHoverIndicator(hoverDot, hoverDot.pinned);
				}
			}

			/* ---- Render a single-vertex particle as a filled circle (always solid fill, no border) ---- */
			function drawParticle(chainObj) {
				const dot = chainObj.chain[0];
				const r = (chainObj.particleRenderSize || 4) * dotScaleFactor;
				const seg = 16; // segments for the circle fan

				// Build triangle-fan for a filled circle
				const verts = [dot.x, dot.y]; // centre
				for (let i = 0; i <= seg; i++) {
					const t = i * (2 * Math.PI / seg);
					verts.push(dot.x + r * Math.cos(t), dot.y + r * Math.sin(t));
				}

				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);

				const rgba = chainObj.color.slice();
				rgba[3] = chainObj.alpha ?? 1.0;
				gl.uniform4fv(lineColorLoc, rgba);
				gl.drawArrays(gl.TRIANGLE_FAN, 0, seg + 2);
			}

			function drawCircle(circle) {
				const seg = 32;
				let verts = [];
				for (let i = 0; i < seg; i++) {
					const t = i * (2 * Math.PI / seg);
					verts.push(
						circle.x + circle.radius * Math.cos(t),
						circle.y + circle.radius * Math.sin(t)
					);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				const rim = circle.__resizing ? [0.1, 0.6, 1.0, 1] : [0, 0, 0, 1];
				gl.uniform4fv(lineColorLoc, rim);
				gl.drawArrays(gl.LINE_LOOP, 0, seg);
			}

			let inProgressBuf = new Float32Array(1024); // or start small

			function drawInProgressPath() {
			    // Draw in-progress blob/line path
			    const n = currentPathPoints.length;
			    if (isDrawing && (drawMode === 'blob' || drawMode === 'line') && n >= 2) {
				    const needed = n * 2;
				    if (inProgressBuf.length < needed) {
				        // grow to next power-of-two-ish
				        inProgressBuf = new Float32Array(needed * 2);
				    }

				    for (let i = 0, j = 0; i < n; i++) {
				        const p = currentPathPoints[i];
				        inProgressBuf[j++] = p.x;
				        inProgressBuf[j++] = p.y;
				    }

				    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				    gl.bufferData(gl.ARRAY_BUFFER, inProgressBuf.subarray(0, needed), gl.DYNAMIC_DRAW);
					gl.useProgram(lineProgram);
					gl.enableVertexAttribArray(linePosLoc);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform2f(lineResLoc, canvas.width, canvas.height);
					gl.uniform4fv(lineColorLoc, hexToRGBA(colorInput.value));
					gl.drawArrays(gl.LINE_STRIP, 0, currentPathPoints.length);
			    }

			    // Draw in-progress attractor/repulsor path (but not in presentation mode)
			    const arN = currentAttractorRepulsorPath.length;
			    if (!isPresentationMode && isDrawing && (drawMode === 'attractor' || drawMode === 'repulsor') && arN >= 2) {
				    const needed = arN * 2;
				    if (inProgressBuf.length < needed) {
				        inProgressBuf = new Float32Array(needed * 2);
				    }

				    for (let i = 0, j = 0; i < arN; i++) {
				        const p = currentAttractorRepulsorPath[i];
				        inProgressBuf[j++] = p.x;
				        inProgressBuf[j++] = p.y;
				    }

				    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				    gl.bufferData(gl.ARRAY_BUFFER, inProgressBuf.subarray(0, needed), gl.DYNAMIC_DRAW);
					gl.useProgram(lineProgram);
					gl.enableVertexAttribArray(linePosLoc);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform2f(lineResLoc, canvas.width, canvas.height);

					// Use green for attractor, red for repulsor
					const isAttractor = attractorRepulsorType === 'attractor';
					const r = isAttractor ? 0.0 : 1.0;
					const g = isAttractor ? 1.0 : 0.0;
					gl.uniform4fv(lineColorLoc, [r, g, 0.0, 0.6]);
					gl.drawArrays(gl.LINE_STRIP, 0, currentAttractorRepulsorPath.length);
			    }
			}

			function drawCurrentCircle() {
				if (!isCircleDrawing || !currentCircle) return;
				if (isPresentationMode) return; // Don't draw in presentation mode
				drawCircle(currentCircle);
			}

			// Draw first frame overlay (very faint) during playback
			// Draws each blob separately to avoid connecting lines between blobs
			function drawFirstFrameOverlay() {
				if (!filmstripData.overlaySplinesCache || filmstripData.overlaySplinesCache.length === 0) return;

				const overlayOpacity = 0.2; // Very faint - 20% opacity
				const thickness = 2;

				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);

				// Ensure blending is enabled for transparency
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

				// Use gray color with low opacity for faint overlay
				gl.uniform4fv(lineColorLoc, [0.3, 0.3, 0.3, overlayOpacity]);

				const tempEdge = new Float32Array(4); // Reuse edge buffer

				// Draw each blob separately to prevent connecting lines between blobs
				filmstripData.overlaySplinesCache.forEach(cached => {
					// Handle particle overlay entries
					if (cached.isParticle) {
						const r = (cached.particleRenderSize || 4) * dotScaleFactor;
						const seg = 12;
						const verts = [cached.x, cached.y];
						for (let i = 0; i <= seg; i++) {
							const t = i * (2 * Math.PI / seg);
							verts.push(cached.x + r * Math.cos(t), cached.y + r * Math.sin(t));
						}
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_FAN, 0, seg + 2);
						return;
					}

					const spline = cached.spline;
					if (!spline || spline.length < 4) return;

					// Collect vertices for this blob only
					const blobVertices = [];

					// Convert spline to line segments for thick lines
					for (let i = 0; i < spline.length - 2; i += 2) {
						tempEdge[0] = spline[i];
						tempEdge[1] = spline[i + 1];
						tempEdge[2] = spline[i + 2];
						tempEdge[3] = spline[i + 3];

						const thickVerts = getThickLineVerticesOpen(tempEdge, thickness);
						if (thickVerts.length > 0) {
							blobVertices.push(...thickVerts);
						}
					}

					// Close the loop if it's a closed chain
					if (cached.isClosed && spline.length >= 4) {
						tempEdge[0] = spline[spline.length - 2];
						tempEdge[1] = spline[spline.length - 1];
						tempEdge[2] = spline[0];
						tempEdge[3] = spline[1];

						const thickVerts = getThickLineVerticesOpen(tempEdge, thickness);
						if (thickVerts.length > 0) {
							blobVertices.push(...thickVerts);
						}
					}

					// Draw this blob separately (prevents connecting lines between blobs)
					if (blobVertices.length > 0) {
						// Reuse buffer if large enough, otherwise create new one
						if (!filmstripData.overlayBuffer || filmstripData.overlayBuffer.length < blobVertices.length) {
							filmstripData.overlayBuffer = new Float32Array(blobVertices.length);
						}
						filmstripData.overlayBuffer.set(blobVertices, 0);

						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, filmstripData.overlayBuffer.subarray(0, blobVertices.length), gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, blobVertices.length / 2);
					}
				});
			}

			function drawCaptureArea() {
				// Draw capture area bounding box if defined or being drawn
				let area = filmstripData.captureArea;
				if (filmstripData.isDraggingCaptureArea && filmstripData.captureAreaCurrent) {
					// Draw the area being dragged
					const start = filmstripData.captureAreaStart;
					const current = filmstripData.captureAreaCurrent;
					const x = Math.min(start.x, current.x);
					const y = Math.min(start.y, current.y);
					const w = Math.abs(current.x - start.x);
					const h = Math.abs(current.y - start.y);
					area = { x, y, width: w, height: h };
				}

				if (!area) return;

				// Draw rectangle outline for capture area using thick lines
				const x = area.x;
				const y = area.y;
				const w = area.width;
				const h = area.height;
				const thickness = 3;

				// Draw rectangle as four separate edges using thick line vertices
				const edges = [
					// Top edge
					new Float32Array([x, y, x + w, y]),
					// Right edge
					new Float32Array([x + w, y, x + w, y + h]),
					// Bottom edge
					new Float32Array([x + w, y + h, x, y + h]),
					// Left edge
					new Float32Array([x, y + h, x, y])
				];

				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				// Red color when recording, yellow otherwise
				if (filmstripData.isRecording) {
					// Blink red: use time-based opacity for blinking effect
					const blinkTime = Date.now() % 1000; // 0-1000ms cycle
					const opacity = blinkTime < 500 ? 1.0 : 0.3; // Blink between full and dim
					gl.uniform4fv(lineColorLoc, [1.0, 0.0, 0.0, opacity]);
				} else {
					// Yellow color for capture area
					gl.uniform4fv(lineColorLoc, [1.0, 1.0, 0.0, 1.0]);
				}

				edges.forEach(edge => {
					const thickVerts = getThickLineVerticesOpen(edge, thickness);
					if (thickVerts.length > 0) {
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
					}
				});
			}
            const isIpad = document.querySelector(".window").classList.contains("ipad");
			/* -----------------------------------
			   ANIMATION LOOP
			----------------------------------- */
			// Set initial canvas background color
			if (isIpad) {
			    gl.clearColor(1.0, 1.0, 1.0, 1.0);
			    canvasBackgroundColor = [1.0, 1.0, 1.0, 1.0];
			} else {
			    gl.clearColor(canvasBackgroundColor[0], canvasBackgroundColor[1], canvasBackgroundColor[2], canvasBackgroundColor[3]);
			}


			function animate() {
				// Update traveling segment positions once per frame
				if (travelingSegmentEnabled) {
					const currentTime = performance.now();
					const deltaTime = (currentTime - travelingSegmentLastTime) / 1000; // Delta in seconds
					travelingSegmentLastTime = currentTime;

					// Update normalized positions for all chains
					chains.forEach((chainObj, chainIndex) => {
						if (chainObj.isClosed && chainObj.chain.length >= 2) {
							// Initialize if needed
							if (!(chainIndex in travelingSegmentNormalizedPosition)) {
								travelingSegmentNormalizedPosition[chainIndex] = 0;
							}

							// Calculate current perimeter length
							const spline = getClosedSmoothCurve(chainObj.chain, 10);
							if (spline.length >= 4) {
								const currentPerimeterLength = calculateSplineLength(spline);
								if (currentPerimeterLength > 0) {
									// Calculate how much to advance the normalized position this frame
									const distanceTraveled = deltaTime * travelingSegmentSpeed;
									const normalizedAdvance = distanceTraveled / currentPerimeterLength;
									travelingSegmentNormalizedPosition[chainIndex] = (travelingSegmentNormalizedPosition[chainIndex] + normalizedAdvance) % 1.0;
								}
							}
						}
					});
				}

				// PERFORMANCE OPTIMIZATION: Skip physics when excitability is 0 (damping = 0)
				// When blobs aren't moving, skip all physics calculations
				const isPhysicsActive = damping > 0.001; // Small threshold to account for floating point

				if (isPhysicsActive) {
					// PERFORMANCE: Optimized CPU physics
					// GPU spatial hashing not available — CPU with spatial hash is fastest
					for (let ci = 0, cLen = chains.length; ci < cLen; ci++) simulateChain(chains[ci], ci);
					simulateInterChainRepulsion();
					simulateCircleRepulsion();
					applyNoiseForces();
					simulateAttractorRepulsorForces();

					// PERFORMANCE: Mark spatial hash for rebuild (positions changed)
					// Don't clear spline cache every frame — hash-based invalidation handles it
					// But cap cache size to prevent unbounded memory growth
					if (splineCache.size > 500) splineCache.clear();
					spatialHashCache.needsRebuild = true;
				} else {
					// PERFORMANCE: When physics is not active, positions don't change
					// Keep spatial hash cached (don't rebuild)
					spatialHashCache.needsRebuild = false;
				}

				// Clear & draw

				gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

				// PERFORMANCE: No downloadFromGPU needed - render directly from GPU textures
				// This eliminates the readPixels bottleneck completely

				if (showGrid) {
					drawGrid(20);
				}

				// PERFORMANCE: Single pass — draw chains inline, collect particles for batching
				let _pbLen = 0; // particle batch length
				for (let ci = 0; ci < chains.length; ci++) {
					const chainObj = chains[ci];
					if (chainObj.isParticle) {
						_particleBatch[_pbLen++] = chainObj;
					} else {
						drawChain(chainObj, ci);
					}
				}
				// Draw ALL particles in one instanced draw call (massive speedup)
				if (_pbLen > 0) {
					drawParticlesBatched(_particleBatch, _pbLen);
				}

				drawInProgressPath();
				// Don't draw circles in presentation mode
				if (!isPresentationMode) {
					circles.forEach(drawCircle);
					if (drawMode === 'circle') drawCurrentCircle();
				}

				// Draw attractors/repulsors (pulsating green/red)
				drawAttractorsRepulsors();

				// Draw lasso selection overlay (delete/freeze)
				drawEditLassoSelect();

				// Draw capture area bounding box (but not during export)
				if (!filmstripData.isExporting && (filmstripData.crosshairsMode || filmstripData.captureArea)) {
					drawCaptureArea();
				}

				requestAnimationFrame(animate);
			}
			animate();


			/* ---------- guided tour engine ---------- */
			const tourSteps = [
				/* 0 ─ Title-bar */
				{
					el: "#splashOverlay + .title-bar",
					text: "Title bar: File (save/load), Export (SVG/JPG), About, Help."
				},

				/* 1 ─ Draw Tools */
				{
					el: ".toolbar-section:first-of-type",
					text: "Choose what you create on the canvas: Blobs, Lines, or Repulsion Circles. Select which one you'd like then click-drag on the canvas to draw."
				},

				/* 2 ─ Edit Tools */
				{
					el: "#editToolsSection",
					text: "Edit items on the canvas with these tools: Drag, Freeze, Pin, or Delete existing items. Only one edit mode can be active at a time."
				},

				/* 3 ─ Shape Settings */
				{
					el: ".toolbar-section:nth-of-type(3)",
					text: "Set colour and average blob size before each draw."
				},

				/* 4 ─ Canvas Tools */
				{
					el: ".toolbar-section:nth-of-type(4)",
					text: "The canvas tools toggle stroke thickness, solid fill, high repulsion mode, or undo the last action."
				},

				/* 5 ─ Main Canvas */
				{
					el: "#glCanvas",
					text: "Canvas: the main playground: draw, drag, and experiment here."
				},

				/* 6 ─ Physics Sliders */
				{
					el: ".bottom-panel",
					text: "Physics Sliders: fine-tune the blob behaviour. Hover the ⓘ buttons to see what each slider does."
				}
			];

			let tourIndex = -1;

			function startTour() {
				if (tourIndex !== -1) return; // already running
				tourIndex = 0;
				$("tourOverlay").style.display = $("tourTip").style.display = "block";
				document.addEventListener("keydown", tourKey);
				showStep();
			}

			function endTour() {
				clearHighlight();
				$("tourOverlay").style.display = $("tourTip").style.display = "none";
				document.removeEventListener("keydown", tourKey);
				tourIndex = -1;
			}

			function showStep() {
				clearHighlight();
				const step = tourSteps[tourIndex];
				const el = document.querySelector(step.el);
				if (!el) { nextStep(); return; }
				el.classList.add("tour-highlight");
				$("tourText").textContent = step.text;
				positionTip(el);
				$("tourPrev").disabled = tourIndex === 0;
				$("tourNext").textContent = tourIndex === tourSteps.length - 1 ? "Done ✔" : "Next ▶";
			}

			function positionTip(target) {
				const rect = target.getBoundingClientRect();
				const tip = $("tourTip");
				const left = rect.right + 12 < window.innerWidth - 330 ?
					rect.right + 12 : rect.left - 332;
				tip.style.left = (left < 8 ? 8 : left) + "px";
				tip.style.top = rect.top + "px";
			}

			function clearHighlight() {
				document.querySelectorAll(".tour-highlight").forEach(e => e.classList.remove("tour-highlight"));
			}

			function nextStep() {
				if (tourIndex < tourSteps.length - 1) {
					tourIndex++;
					showStep();
				} else endTour();
			}

			function prevStep() {
				if (tourIndex > 0) {
					tourIndex--;
					showStep();
				}
			}

			function tourKey(e) {
				if (e.key === "Escape") endTour();
				else if (e.key === "ArrowRight") nextStep();
				else if (e.key === "ArrowLeft") prevStep();
			}
			$("tourNext").onclick = nextStep;
			$("tourPrev").onclick = prevStep;
			$("tourExit").onclick = endTour;

			/* -----------------------------------
			   EXPORT HELPERS
			----------------------------------- */
			function exportSVG() {
				// Get visual canvas dimensions (what user sees) instead of internal resolution
				// Use getBoundingClientRect for accurate visual size, fallback to style or internal dimensions
				const rect = canvas.getBoundingClientRect();
				const visualWidth = rect.width || parseInt(canvas.style.width) || canvas.width;
				const visualHeight = rect.height || parseInt(canvas.style.height) || canvas.height;
				const scaleX = visualWidth / canvas.width;
				const scaleY = visualHeight / canvas.height;
				const parts = [`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${visualWidth} ${visualHeight}" style="background:white;">`];

				chains.forEach(obj => {
					// Handle particle chains (single-vertex, rendered as circles)
					if (obj.isParticle && obj.chain.length === 1) {
						const dot = obj.chain[0];
						const r = (obj.particleRenderSize || 4) * dotScaleFactor;
						const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
						const cx = dot.x * scaleX;
						const cy = dot.y * scaleY;
						const sr = r * Math.min(scaleX, scaleY);
						parts.push(`<circle cx="${cx}" cy="${cy}" r="${sr}" fill="rgb(${rr},${gg},${bb})" />`);
						return;
					}

					if (obj.chain.length < 2) return;
					const spline = obj.isClosed ? getClosedSmoothCurve(obj.chain, 10) :
						getOpenSmoothCurve(obj.chain, 10);
					if (spline.length < 4) return;
					const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
					// Scale coordinates to visual dimensions
					let d = `M ${spline[0] * scaleX} ${spline[1] * scaleY}`;
					for (let i = 2; i < spline.length; i += 2) {
						d += ` L ${spline[i] * scaleX} ${spline[i+1] * scaleY}`;
					}
					if (obj.isClosed) d += " Z";

					// Use current appearance settings
					const shouldFill = (showFilled && obj.isClosed);
					const shouldStroke = showOutline;
					const strokeWidth = outlineWidth * Math.min(scaleX, scaleY);

					if (shouldFill && shouldStroke) {
						// Both fill and outline - draw filled with black border
						parts.push(`<path d="${d}" fill="rgb(${rr},${gg},${bb})" stroke="rgb(0,0,0)" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" />`);
					} else if (shouldFill) {
						// Only fill
						parts.push(`<path d="${d}" fill="rgb(${rr},${gg},${bb})" stroke="none" />`);
					} else if (shouldStroke) {
						// Only outline
						parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" fill="none" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" />`);
					}
				});
				parts.push("</svg>");
				const blob = new Blob([parts.join("")], { type: "image/svg+xml" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = "blobs.svg";
				link.click();
				URL.revokeObjectURL(url);
			}

			function exportJPG() {
				// Get visual canvas dimensions (what user sees) instead of internal resolution
				// Use getBoundingClientRect for accurate visual size, fallback to style or internal dimensions
				const rect = canvas.getBoundingClientRect();
				const visualWidth = rect.width || parseInt(canvas.style.width) || canvas.width;
				const visualHeight = rect.height || parseInt(canvas.style.height) || canvas.height;

				// Calculate aspect ratio and scale up to high resolution (2000px on longer side)
				const targetResolution = 2000;
				const aspectRatio = visualWidth / visualHeight;
				let exportWidth, exportHeight;
				if (visualWidth >= visualHeight) {
					// Landscape or square: scale based on width
					exportWidth = targetResolution;
					exportHeight = Math.round(targetResolution / aspectRatio);
				} else {
					// Portrait: scale based on height
					exportHeight = targetResolution;
					exportWidth = Math.round(targetResolution * aspectRatio);
				}

				// Calculate scale factors from canvas internal resolution to export resolution
				const scaleX = exportWidth / canvas.width;
				const scaleY = exportHeight / canvas.height;

				const offscreen = document.createElement("canvas");
				offscreen.width = exportWidth;
				offscreen.height = exportHeight;
				const ctx = offscreen.getContext("2d");

				// Draw white background (no canvas background color or grid in exports)
				ctx.fillStyle = "#fff";
				ctx.fillRect(0, 0, exportWidth, exportHeight);

				chains.forEach(obj => {
					// Handle particle chains (single-vertex, rendered as circles)
					if (obj.isParticle && obj.chain.length === 1) {
						const dot = obj.chain[0];
						const r = (obj.particleRenderSize || 4) * dotScaleFactor;
						const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
						ctx.beginPath();
						ctx.arc(dot.x * scaleX, dot.y * scaleY, r * Math.min(scaleX, scaleY), 0, Math.PI * 2);
						ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
						ctx.fill();
						return;
					}

					const ch = obj.chain;
					if (ch.length < 2) return;
					const spline = obj.isClosed ? getClosedSmoothCurve(ch, 10) :
						getOpenSmoothCurve(ch, 10);
					if (spline.length < 4) return;
					const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
					ctx.lineCap = "round";
					ctx.lineJoin = "round";
					ctx.beginPath();
					// Scale coordinates from canvas internal resolution to high-res export dimensions
					ctx.moveTo(spline[0] * scaleX, spline[1] * scaleY);
					for (let i = 2; i < spline.length; i += 2) {
						ctx.lineTo(spline[i] * scaleX, spline[i + 1] * scaleY);
					}
					if (obj.isClosed) ctx.closePath();

					// Use current appearance settings
					const shouldFill = (showFilled && obj.isClosed);
					const shouldStroke = showOutline;
					const strokeWidth = outlineWidth * Math.min(scaleX, scaleY);

					if (shouldFill && shouldStroke) {
						// Both fill and outline - draw filled with black border
						ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
						ctx.fill();
						ctx.strokeStyle = "rgb(0,0,0)";
						ctx.lineWidth = strokeWidth;
						ctx.stroke();
					} else if (shouldFill) {
						// Only fill
						ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
						ctx.fill();
					} else if (shouldStroke) {
						// Only outline
						ctx.strokeStyle = `rgb(${rr},${gg},${bb})`;
						ctx.lineWidth = strokeWidth;
						ctx.stroke();
					}
				});

				const url = offscreen.toDataURL("image/jpeg", 1.0);
				const link = document.createElement("a");
				link.href = url;
				link.download = "blobs.jpg";
				link.click();
			}

			$("exportSVGOption").onclick = e => {
				e.stopPropagation();
				exportSVG();
				$("exportSubmenu").style.display = "none";
			};
			$("exportJPGOption").onclick = e => {
				e.stopPropagation();
				exportJPG();
				$("exportSubmenu").style.display = "none";
			};

			/* -----------------------------------
			   SLIDER SETUP
			----------------------------------- */

			// 1) Blob Scale slider (0..100 => 0.1..5)
			{
				const s = $("dotScaleSlider");
				const v = $("dotScaleValue");
				s.value = ((dotScaleFactor - 0.1) / (5 - 0.1)) * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					setDotScale(parseFloat(s.value));
					SFX.sliderBlobSize(parseFloat(s.value));
				});
			}

			// 2) Damping slider (0..100 => 0..1)
			{
				const s = $("dampingSlider");
				const v = $("dampingValue");
				s.value = damping * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					damping = parseFloat(s.value) / 100;
					v.textContent = Math.round(s.value) + "%";
					SFX.sliderExcitability(parseFloat(s.value));
				});
			}

			// 3) Spring Constant slider (0..100 => 0..1)
			{
				const s = $("springConstantSlider");
				const v = $("springConstantValue");
				s.value = springConstant * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					springConstant = parseFloat(s.value) / 100;
					v.textContent = Math.round(s.value) + "%";
					SFX.sliderStiffness(parseFloat(s.value));
				});
			}

			// 4) Repulsion slider (0..100 => 0..1)
			{
				const s = $("repulsionConstantSlider");
				const v = $("repulsionConstantValue");
				s.value = repulsionConstant * 200;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					repulsionConstant = parseFloat(s.value) / 200;
					v.textContent = s.value + "%";
					SFX.sliderChaos(parseFloat(s.value));
				});
			}

			// 5) Simulation Speed slider (0..100 => 0.1..2)
			{
				const s = $("timeStepSlider");
				const v = $("timeStepValue");
				s.value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					const percent = parseFloat(s.value);
					timeStep = mapRange(percent, 0, 100, 0.1, 2);
					v.textContent = s.value + "%";
					SFX.sliderSpeed(percent);
				});
			}

			// 6) Turgor Pressure slider (0..100 => 0..1)
{
  const s = $("turgorPressureSlider");
  const v = $("turgorPressureValue");
  s.value = Math.round(turgorPressure * 100);
  v.textContent = s.value + "%";
  s.addEventListener("input", () => {
    turgorPressure = parseFloat(s.value) / 100;
    v.textContent = s.value + "%";
    SFX.sliderInflation(parseFloat(s.value));
  });
}

			/* -----------------------------------
			   DRUM PAD PANEL
			----------------------------------- */
			let originalDamping = damping;
			let dampingRestoreTimer = null;
			let dampingRestoreStartTime = null;
			let dampingRestoreDuration = 100; // ms for decay (increased from 500 for longer visible movement)

			// Attack/Decay damping restoration
			function restoreDampingWithDecay() {
				if (dampingRestoreTimer) {
					cancelAnimationFrame(dampingRestoreTimer);
				}

				const startDamping = damping;
				const targetDamping = originalDamping;
				const startTime = performance.now();

				function animate() {
					const elapsed = performance.now() - startTime;
					const progress = Math.min(elapsed / dampingRestoreDuration, 1);

					// Exponential decay for smooth transition
					const easeOut = 1 - Math.pow(1 - progress, 3);
					damping = startDamping + (targetDamping - startDamping) * easeOut;

					// Update UI
					const s = $("dampingSlider");
					const v = $("dampingValue");
					if (s && v) {
						s.value = damping * 100;
						v.textContent = Math.round(s.value) + "%";
					}

					if (progress < 1) {
						dampingRestoreTimer = requestAnimationFrame(animate);
					} else {
						damping = targetDamping;
						dampingRestoreTimer = null;
					}
				}

				dampingRestoreTimer = requestAnimationFrame(animate);
			}

			// Temporarily boost excitability (set damping to 0.001 = 99.9% excitability)
			function boostExcitability() {
				originalDamping = damping; // Store current value
				damping = 0.001; // 99.9% excitability (much more responsive)

				const s = $("dampingSlider");
				const v = $("dampingValue");
				if (s && v) {
					s.value = damping * 100;
					v.textContent = Math.round(s.value) + "%";
				}

				// Restore after a short delay with decay
				setTimeout(() => {
					restoreDampingWithDecay();
				}, 300); // Attack phase: 300ms at high excitability (longer for more movement)
			}

			// Simple 2D noise function (Perlin-like)
			function noise2D(x, y) {
				const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
				return n - Math.floor(n);
			}

			// Smooth noise interpolation
			function smoothNoise(x, y) {
				const intX = Math.floor(x);
				const intY = Math.floor(y);
				const fracX = x - intX;
				const fracY = y - intY;

				const v1 = noise2D(intX, intY);
				const v2 = noise2D(intX + 1, intY);
				const v3 = noise2D(intX, intY + 1);
				const v4 = noise2D(intX + 1, intY + 1);

				const i1 = v1 * (1 - fracX) + v2 * fracX;
				const i2 = v3 * (1 - fracX) + v4 * fracX;
				return i1 * (1 - fracY) + i2 * fracY;
			}

			// Apply noise-based forces to all blobs (called from animation loop)
			// Subtle per-vertex perturbations with organic ramping (0 -> peak -> down -> up)
			function applyNoiseForces() {
				if (!noiseActive) return;

				noiseTime += 0.003;
				noiseRampTime += 0.0015;
				const noiseScale = 0.01;
				const baseNoiseStrength = 0.2;

				const rampPhase = (Math.sin(noiseRampTime) + 1) / 2;
				const easedRamp = rampPhase < 0.5
					? 2 * rampPhase * rampPhase
					: 1 - Math.pow(-2 * rampPhase + 2, 2) / 2;
				const currentNoiseStrength = baseNoiseStrength * (0.5 + easedRamp * 0.5);

				// PERFORMANCE: Hoist invariants out of inner loops
				const centerX = canvas.width * 0.5;
				const centerY = canvas.height * 0.5;
				const invHalfW = 1 / centerX;
				const invHalfH = 1 / centerY;
				const centerSeekStrength = 0.12;
				const nt = noiseTime;
				const nt1000 = noiseTime + 1000;

				for (let ci = 0, cLen = chains.length; ci < cLen; ci++) {
					const chainObj = chains[ci];
					if (chainObj.frozen) continue;
					const ch = chainObj.chain;

					for (let vi = 0, vLen = ch.length; vi < vLen; vi++) {
						const vertex = ch[vi];
						if (vertex.pinned) continue;

						const distFromCenterX = Math.abs(vertex.x - centerX) * invHalfW;
						const distFromCenterY = Math.abs(vertex.y - centerY) * invHalfH;
						const edgeProximity = distFromCenterX > distFromCenterY ? distFromCenterX : distFromCenterY;

						const vx = vertex.vx, vy = vertex.vy;
						const vertexSpeed = Math.sqrt(vx * vx + vy * vy);

						const nx = smoothNoise(vertex.x * noiseScale, nt);
						const ny = smoothNoise(vertex.y * noiseScale, nt1000);

						const noiseModX = (nx - 0.5) * 2;
						const noiseModY = (ny - 0.5) * 2;

						let velocityScale = vertexSpeed * 0.5;
						if (velocityScale < 0.3) velocityScale = 0.3;
						else if (velocityScale > 1.0) velocityScale = 1.0;

						const noiseInfluence = currentNoiseStrength * velocityScale;
						let forceX = noiseModX * noiseInfluence;
						let forceY = noiseModY * noiseInfluence;

						// Center-seeking (only active near edges)
						if (edgeProximity > 0.3) {
							const centerSeekFactor = edgeProximity - 0.3;
							forceX += (centerX - vertex.x) * invHalfW * centerSeekStrength * centerSeekFactor;
							forceY += (centerY - vertex.y) * invHalfH * centerSeekStrength * centerSeekFactor;
						}

						vertex.vx += forceX;
						vertex.vy += forceY;
					}
				}
			}

			// Noise Movement: Random noise movement (ambient noise field) - TOGGLE
			$("iconNoise").addEventListener("click", () => {
				if (chains.length === 0) {
					toast("No blobs to move", 1500);
					return;
				}

				if (noiseActive) {
					// Turn OFF noise
					noiseActive = false;

					// Restore excitability
					restoreDampingWithDecay();

					// Update button visual state
					toggleActiveIcon($("iconNoise"), false);

					toast("Noise OFF", 800);
				} else {
					// Turn ON noise
					noiseActive = true;
					noiseTime = Math.random() * 1000; // Random starting point
					noiseRampTime = 0; // Start ramping from 0

					// STEP 1: Boost excitability to 99% (0.01 damping)
					originalDamping = damping;
					damping = 0.95; // 95% excitability

					const s = $("dampingSlider");
					const v = $("dampingValue");
					if (s && v) {
						s.value = damping * 100;
						v.textContent = Math.round(s.value) + "%";
					}

					// Update button visual state
					toggleActiveIcon($("iconNoise"), true);

					toast("Noise ON", 800);
				}
			});



			window.addEventListener("keydown", e => {
				// ignore ⇧/⌥/⌘ combos and when user is typing in an input / textarea
				if (e.ctrlKey || e.metaKey || e.altKey) return;
				const tgt = e.target;
				if (tgt && (tgt.tagName === "INPUT" || tgt.tagName === "TEXTAREA")) return;

				switch (e.key.toLowerCase()) {
					/* draw modes */
					case "q":
						setDrawMode("blob");
						break; // Blob
					case "w":
						setDrawMode("line");
						break; // Line
					case "e":
						setDrawMode("circle");
						break; // Circle
					case "r":
						// If not already in particle mode, open settings; if already, toggle off
						if (drawMode === "particle") {
							setDrawMode("particle");
						} else {
							$("iconParticle").click();
						}
						break; // Particle

						/* edit tools (toggle off if already on) */
					case "a":
						setEditTool("drag");
						break; // Drag
					case "s":
						setEditTool("freeze");
						break; // Freeze
					case "d":
						setEditTool("pin");
						break; // Pin
					case "z":
						setEditTool("slice");
						break; // Slice
					case "x":
						setEditTool("delete");
						break; // Delete
				}
			});

			window.addEventListener("keydown", e => {
				if (e.code === "Space" && !e.repeat) { // Space toggles
					if (damping !== 0) { // turn OFF
						prevDamping = damping; // remember
						damping = 0;
					} else { // turn ON
						damping = prevDamping || 0.85; // fallback default
					}

					// keep the UI slider in sync
					const s = $("dampingSlider"),
						v = $("dampingValue");
					s.value = damping * 100;
					v.textContent = Math.round(s.value) + "%";

					e.preventDefault(); // stop the page from scrolling
				}
			});
			// 6) Gap & ΔSize
			const radiusAvgInput = $("radiusAvgInput");
			const radiusVarInput = $("radiusVarInput");

			if (radiusAvgInput) {
				radiusAvgInput.oninput = e => {
					globalRadiusAvg = parseFloat(e.target.value);
				};
			}

			if (radiusVarInput) {
				radiusVarInput.oninput = e => {
					globalRadiusVar = parseFloat(e.target.value);
				};
			}
		});
	</script>
</body>

</html>
