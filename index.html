<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>blobSketch version 1.2</title>

	<style>
		/* ---------- Desktop defaults ---------- */
		/* Source: desktop.css */

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. Base / Reset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		body {
			margin: 0;
			padding: 0;
			font-family: "Courier New", monospace;
			background-color: #efefef;
			color: #000;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. Global Containers ‚îÄ‚îÄ‚îÄ‚îÄ */
		.window {
			width: 800px;
			margin: 40px auto;
			border: 2px solid #000;
			background-color: #fff;
			box-shadow: 4px 4px 0px #000;
			position: relative;
		}

		.content {
			display: flex;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. Title-bar & Menu ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		.title-bar {
			background-color: #c0c0c0;
			border-bottom: 2px solid #000;
			padding: 4px 8px;
			display: flex;
			gap: 12px;
			align-items: center;
			position: relative;
		}

		.menu-bar {
			display: flex;
			gap: 16px;
		}

		.menu-bar span {
			font-weight: bold;
			cursor: pointer;
			position: relative;
		}

		.menu-bar span:hover {
			text-decoration: underline;
		}

		.submenu {
			display: none;
			position: absolute;
			top: 24px;
			left: 0;
			background-color: #c0c0c0;
			border: 2px solid #000;
			padding: 4px;
			flex-direction: column;
			gap: 4px;
			z-index: 999;
		}

		.submenu span {
			display: block;
			padding: 2px 6px;
			cursor: pointer;
		}

		.submenu span:hover {
			background-color: #d9d9d9;
		}

		#exportSubmenu {
			width: 160px;
		}

		#fileSubmenu {
			width: 200px;
		}

		.reset-icon {
			margin-left: auto;
			font-weight: bold;
			font-size: 18px;
			cursor: pointer;
			user-select: none;
			text-decoration: none;
			padding: 0 8px;
		}

		.reset-icon:hover {
			background-color: #d9d9d9;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4. Workspace Layout ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		/* 4-A  Toolbar shell */
		.toolbar {
			width: 150px;
			border-right: 2px solid #000;
			background-color: #d9d9d9;
			padding: 6px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		/* 4-B  Toolbar sections */
		.toolbar-section {
			border: 1px solid #000;
			background-color: #efefef;
			padding: 4px;
			margin: 2px 0;
		}

		.toolbar-section h4 {
			margin: 0 0 4px;
			font-size: 12px;
			font-weight: bold;
			text-align: center;
			background-color: #b0b0b0;
			color: #000;
			border: 1px solid #000;
			padding: 2px;
		}

		.toolbar-section .icon-group {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			justify-content: center;
		}

		/* glowing outline when any edit mode is engaged */
		#editToolsSection.edit-on {
			outline: 3px solid #ff3b3b;
			/* neon red */
			box-shadow: 0 0 6px 2px #ff3b3b inset,
				0 0 6px 2px #ff3b3b;
			/* subtle outer glow */
			transition: outline-color .2s, box-shadow .2s;
		}

		/* 4-C  Icon buttons */
		.icon {
			width: 32px;
			height: 32px;
			border: 2px solid #000;
			background-color: #fff;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			user-select: none;
			font-weight: normal;
			position: relative;
			/* rounded corners */
			border-radius: 6px;
			/* or 50% for perfect circles */
			overflow: visible;
			/* ‚Üê allow the ON badge to stick out */
		}

		.icon img {
			width: 32px;
			height: 32px;
			border-radius: inherit;
		}

		#iconFill.icon-active {
			background-color: #D3D3D3;
			font-weight: bold;
		}

		/* ‚ÄúON‚Äù label */
		.icon.icon-active::after {
			content: "ON";
			position: absolute;
			top: -8px;
			right: -8px;
			background-color: #ff0;
			color: #000;
			font-size: 10px;
			font-weight: bold;
			border: 1px solid #000;
			padding: 2px 4px;
			border-radius: 4px;
			box-shadow: 2px 2px 0px #000;
			z-index: 5;
		}

		/* 4-D  Shape-settings mini-panel */
		.shape-settings {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 6px;
		}

		.shape-settings label {
			font-size: 12px;
			text-align: center;
			display: block;
		}

		.shape-settings input[type="color"],
		.shape-settings input[type="number"] {
			margin-top: 2px;
			width: 40px;
			min-width: 0;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5. Main Drawing Area ‚îÄ‚îÄ‚îÄ‚îÄ */
		.main-area {
			flex: 1;
			padding: 8px;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		#glCanvas {
			width: 500px;
			height: 500px;
			border: 2px solid #000;
			background-color: #fff;
			display: block;
			margin-bottom: 16px;
			-webkit-user-select: none;
			-moz-user-select: none;
			user-select: none;
			-webkit-user-drag: none;
			-khtml-user-drag: none;
			touch-action: none;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 6. Bottom Slider Panel ‚îÄ */
		.bottom-panel {
			display: flex;
			justify-content: center;
			align-items: center;
			flex-direction: column;
			border-top: 2px solid #000;
			padding: 8px;
			background-color: #c0c0c0;
			text-align: center;
		}

		#sliders>div {
			display: flex;
			align-items: center;
			margin: 8px 0;
		}

		#sliders label {
			width: 250px;
			text-align: center;
			margin-right: 8px;
		}

		#sliders label span {
			display: inline-block;
			font-weight: bold;
			vertical-align: middle;
		}

		input[type="range"] {
			-webkit-appearance: none;
			width: 300px;
			background: #fff;
			border: 1px solid #000;
		}

		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 14px;
			height: 20px;
			background: #c0c0c0;
			border: 1px solid #000;
			cursor: pointer;
			margin-top: -7px;
		}

		input[type="range"]::-moz-range-thumb {
			width: 14px;
			height: 20px;
			background: #c0c0c0;
			border: 1px solid #000;
			cursor: pointer;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 7. Dialogs & Modals ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		.dialog-backdrop {
			display: none;
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.4);
			justify-content: center;
			align-items: center;
			z-index: 99;
		}

		.dialog-content {
			background-color: #fff;
			border: 2px solid #000;
			padding: 16px;
			min-width: 200px;
			text-align: center;
			box-shadow: 4px 4px 0px #000;
			font-family: "Courier New", monospace;
		}

		.dialog-content button {
			margin-top: 12px;
			font-family: inherit;
			cursor: pointer;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 8. Splash Overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		#splashOverlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(255, 255, 255, 0.8);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 9999;
			cursor: pointer;
		}

		#splashOverlay img {
			max-width: 50%;
			max-height: 50%;
			pointer-events: none;
			margin-bottom: 50px;
			border: 2px solid #000;
			border-radius: 6px;
			padding: 0px;
		}

		.splashText {
			font-family: "Courier New", monospace;
			font-size: 18px;
			font-weight: bold;
			color: #000;
			background-color: #c0c0c0;
			padding: 8px 12px;
			border: 2px solid #000;
			box-shadow: 4px 4px 0px #000;
			user-select: none;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 9. Help Icon & Tooltip ‚îÄ */
		.inline-icon {
			width: 16px;
			height: 16px;
			vertical-align: middle;
			margin: 0 4px;
		}

		.help-icon-container {
			position: relative;
			display: inline-block;
		}

		.help-icon {
			display: inline-block;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background-color: #c0c0c0;
			border: 1px solid #000;
			color: #000;
			font-size: 12px;
			font-weight: bold;
			text-align: center;
			line-height: 16px;
			cursor: help;
			user-select: none;
		}

		.help-tooltip {
			display: none;
			position: absolute;
			bottom: 20px;
			left: 0;
			min-width: 120px;
			background-color: #efefef;
			color: #000;
			border: 1px solid #000;
			padding: 4px;
			font-size: 12px;
			box-shadow: 4px 4px 0 #000;
			z-index: 9999;
		}

		.help-icon-container:hover .help-tooltip {
			display: block;
		}



		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 10. Cursor Modes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
		.canvas-blob-mode {
			cursor: url("images/pencil.png"), auto;
		}

		.canvas-line-mode {
			cursor: url("images/pencil.png"), auto;
		}

		.canvas-circle-mode {
			cursor: url("images/CircleCursor.png"), auto;
		}

		.canvas-drag-mode {
			cursor: url("images/glove.png"), auto;
		}

		.canvas-pin-mode {
			cursor: url("images/PinCursor.png"), auto;
		}

		.canvas-slicing-mode {
			cursor: url("images/trim.png"), auto;
		}

		.canvas-freeze-mode {
			cursor: url("images/FreezeCursor.png"), auto;
		}

		.canvas-delete-mode {
			cursor: url("images/DeleteCursor.png"), auto;
		}

		/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 11. Mobile-only Warning ‚îÄ */
		#mobileWarning {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #fff;
			color: #000;
			font-family: sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			z-index: 10000;
			padding: 20px;
		}

		.icon:focus-visible {
			outline: 3px solid #ffbf00;
		}

		.icon[data-label]::before {
			content: attr(data-label);
			position: absolute;
			bottom: -24px;
			/* small gap below the icon */
			left: 50%;
			translate: -50% 0;
			font: 12px "Courier New", monospace;
			background: #000;
			color: #fff;
			padding: 2px 6px;
			border-radius: 4px;
			white-space: nowrap;
			pointer-events: none;
			opacity: 0;
			transition: opacity .15s;
			z-index: 50;
			/* sit above everything in the toolbar */
		}

		.icon:hover::before,
		.icon:focus-visible::before {
			opacity: 1;
		}

		/* ---------- toast notifications ---------- */
		#toastStack {
			position: absolute;
			top: 48px;
			right: 10px;
			display: flex;
			flex-direction: column;
			gap: 8px;
			align-items: flex-end;
			pointer-events: none;
			/* clicks fall through */
			z-index: 2000;
		}

		.toast {
			font: 14px "Courier New", monospace;
			background: #000;
			color: #fff;
			padding: 6px 10px;
			border-radius: 6px;
			opacity: 0;
			transform: translateY(-8px);
			transition: opacity .2s, transform .2s;
		}

		.toast.show {
			opacity: .9;
			transform: translateY(0);
		}

		.title-actions {
			margin-left: auto;
			/* pushes the pair to the far right */
			display: flex;
			gap: 6px;
			/* neat 6-px gap between the two icons */
		}

		/* ---------- guided tour ---------- */
		#tourOverlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, .55);
			z-index: 3000;
			pointer-events: none;
		}

		#tourTip {
			position: fixed;
			z-index: 3001;
			max-width: 320px;
			font: 13px "Courier New", monospace;
			background: #fff;
			color: #000;
			border: 2px solid #000;
			border-radius: 6px;
			padding: 10px 12px;
			box-shadow: 4px 4px 0 #000;
		}

		#tourCtrls {
			margin-top: 8px;
			text-align: right;
		}

		#tourCtrls button {
			font: inherit;
			margin-left: 4px;
			cursor: pointer;
		}

		.tour-highlight {
			outline: 3px solid #ffe600 !important;
			box-shadow: 0 0 8px 3px #ffe600 !important;
		}

		/* --- prettier Presets gallery ---------------------------------- */
		.presets-gallery {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			gap: 12px;
			padding: 4px;
			max-height: 60vh;
			/* scroll if many presets */
			overflow-y: auto;
		}

		.preset-card {
			aspect-ratio: 1/1;
			/* always square */
			background: #fafafa;
			border: 2px solid #000;
			box-shadow: 3px 3px 0 #000;
			position: relative;
			transition: transform .15s, box-shadow .15s;
		}

		.preset-card:hover {
			transform: translateY(-3px);
			box-shadow: 5px 5px 0 #000;
		}

		.preset-card:active {
			transform: translateY(0);
		}

		.preset-card img,
		.preset-card svg {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
		}

		.preset-card figcaption {
			position: absolute;
			inset: 0;
			background: rgba(0, 0, 0, .58);
			color: #fff;
			font: 12px "Courier New", monospace;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			padding: 4px;
			opacity: 0;
			transition: opacity .15s;
		}

		.preset-card:hover figcaption {
			opacity: 1;
		}

		/* highlight the card the user just applied */
		.preset-card.card-selected {
			outline: 3px solid #ffe600;
			box-shadow: 0 0 10px 3px #ffe600;
			transform: none;
		}




		/* ---------- iPad overrides (full ipad.css wrapped; no transformation) ---------- */
		@supports (-webkit-touch-callout: none) {
			@media (hover: none) and (pointer: coarse) {

				/* =========================================================
 BlobSketch CSS ‚Äî Clean Split: Desktop (default) + iPad
 Order matters: Tokens ‚Üí Base ‚Üí Components ‚Üí Layout ‚Üí States ‚Üí iPad
 ========================================================= */

				/* ------------------ 0. Tokens / Theme ------------------ */
				:root {
					/* Palette (light) */
					--bg: #f7f7f8;
					--panel: #ffffff;
					--panel-2: #fbfbfc;
					--text: #111317;
					--muted: #5a5f6a;
					--accent: #2563eb;

					/* blue rim/accent */
					--border: rgba(0, 0, 0, 0.10);

					/* Sizing */
					--radius-sm: 6px;
					--radius-md: 10px;
					--radius-lg: 12px;
					--gap-1: 6px;
					--gap-2: 10px;
					--gap-3: 12px;

					/* Icon */
					--icon-size: 36px;

					/* Z-index */
					--z-submenu: 900;
					--z-dialog: 2000;
					--z-splash: 9999;
				}

				/* ------------------ 1. Base / Reset ------------------ */
				* {
					box-sizing: border-box;
				}

				html,
				body {
					height: 100%;

				}

				body {
					margin: 0;
					padding: 0;
					background: var(--bg);
					color: var(--text);
					font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
				}

				img {
					max-width: 100%;
					display: block;
				}

				button {
					font: inherit;
					cursor: pointer;
				}

				/* Prevent gesture scrolling on canvas-driven apps where needed */
				#glCanvas {
					-webkit-user-select: none;
					-moz-user-select: none;
					user-select: none;
					-webkit-user-drag: none;
					touch-action: none;
					/* Apple Pencil / multi-touch */
				}

				/* ------------------ 2. App Shell ------------------ */
				.window {
					width: min(1100px, 96vw);
					margin: 28px auto;
					background: var(--panel);
					border: 1px solid var(--border);
					border-radius: 14px;
					box-shadow: 0 12px 28px rgba(0, 0, 0, 0.10);
					position: relative;
					overflow: clip;
				}

				.title-bar {
					height: 48px;
					padding: 8px 12px;
					display: flex;
					align-items: center;
					gap: 12px;
					background: linear-gradient(180deg, #ffffff, #f5f6f8);
					border-bottom: 1px solid var(--border);
				}

				.menu-bar {
					display: flex;
					gap: 16px;
				}

				.menu-bar span {
					font-weight: 600;
					cursor: pointer;
					position: relative;
				}

				.menu-bar span:hover {
					text-decoration: underline;
				}



				.title-actions {
					margin-left: auto;
					/* <-- pushes to the far right */
					display: flex;
					align-items: center;
					gap: 8px;
				}

				/* Make the icons render tightly without extra width */
				.reset-icon {
					display: inline-flex;
					align-items: center;
					justify-content: center;
					width: 32px;
					height: 32px;
					padding: 0;
				}

				/* Submenus */
				.submenu {
					display: none;
					position: absolute;
					top: 24px;
					left: 0;
					min-width: 160px;
					background: var(--panel-2);
					border: 1px solid var(--border);
					border-radius: 10px;
					padding: 8px;
					z-index: var(--z-submenu);
				}

				.submenu span {
					display: block;
					padding: 4px 6px;
					border-radius: var(--radius-sm);
					cursor: pointer;
				}

				.submenu span:hover {
					background: rgba(0, 0, 0, .04);
				}

				.reset-icon {
					margin-left: auto;
					font-weight: bold;
					font-size: 18px;
					padding: 0 8px;
					user-select: none;
				}

				/* Content columns (Desktop default) */
				.content {
					display: grid;
					grid-template-columns: 260px 1fr;
					gap: var(--gap-3);
					padding: var(--gap-3);
				}

				/* ------------------ 3. Toolbar & Sections ------------------ */
				.toolbar {
					display: flex;
					flex-direction: column;
					gap: var(--gap-3);
					background: transparent;
					border: 0;
					padding: 0;
				}

				.toolbar-section {
					background: var(--panel-2);
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					padding: 10px;
				}

				.toolbar-section h4 {
					margin: 0 0 8px;
					font-size: 12px;
					font-weight: 600;
					color: var(--muted);
				}

				.toolbar-section .icon-group {
					display: flex;
					flex-wrap: wrap;
					gap: var(--gap-1);
				}

				/* Edit tools ‚Äúglow‚Äù when active group is engaged */
				#editToolsSection.edit-on {
					outline: 3px solid #ff3b3b;
					box-shadow: 0 0 6px 2px #ff3b3b inset, 0 0 6px 2px #ff3b3b;
					transition: outline-color .2s, box-shadow .2s;
				}

				/* ------------------ 4. Icons ------------------ */
				.icon {
					width: var(--icon-size);
					height: var(--icon-size);
					display: flex;
					align-items: center;
					justify-content: center;
					border-radius: var(--radius-md);
					border: 1px solid rgba(0, 0, 0, 0.12);
					background: #f7f8fa;
					/* light tile */
					box-shadow:
						0 1px 0 rgba(255, 255, 255, 0.7) inset,
						0 8px 18px rgba(0, 0, 0, 0.08);
					transition: transform .12s ease;
					position: relative;
					user-select: none;
				}

				.icon:hover {
					transform: translateY(-1px);
				}

				.icon img {
					width: 100%;
					height: 100%;
					object-fit: contain;
					border-radius: inherit;
					filter: none;
					position: relative;
					z-index: 0;
					/* preserve dark glyphs */
				}

				/* Active icon rim */
				.icon.icon-active {
					background: #ffffff;
					border-color: rgba(37, 99, 235, 0.35);
					box-shadow:
						0 0 0 1px rgba(37, 99, 235, 0.18) inset,
						0 10px 22px rgba(37, 99, 235, 0.12);
				}

				/* Optional ‚ÄúON‚Äù badge */
				.icon.icon-active::after {
					content: "ON";
					position: absolute;
					top: -10px;
					right: -6px;
					font-size: 8px;
					font-weight: 700;
					color: #000;
					background: #ff0;
					border: 1px solid #000;
					border-radius: 4px;
					padding: 2px 4px;
					box-shadow: 2px 2px 0 #000;
					z-index: 100;
				}

				/* Tooltip label under icon (on hover/focus) */
				.icon[data-label]::before {
					content: attr(data-label);
					position: absolute;
					bottom: -24px;
					left: 50%;
					font: 12px "Courier New", monospace;
					color: #fff;
					background: #111317;
					border: 1px solid rgba(255, 255, 255, 0.18);
					padding: 2px 6px;
					border-radius: var(--radius-sm);
					white-space: nowrap;
					pointer-events: none;
					opacity: 0;
					transition: opacity .15s;
					z-index: 500;
				}

				.icon:hover::before,
				.icon:focus-visible::before {
					opacity: 1;
				}

				.icon:focus-visible {
					outline: 2px solid var(--accent);
					outline-offset: 2px;
				}

				/* ------------------ 5. Main Drawing Area ------------------ */
				.main-area {
					background: var(--panel);
					padding: 8px;
					border-radius: var(--radius-lg);
					display: flex;
					flex-direction: column;
					align-items: center;
				}

				#glCanvas {
					width: 500px;
					height: 500px;
					background: #fff;
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					display: block;
					margin-bottom: 16px;
				}

				/* ------------------ 6. Bottom Sliders Panel ------------------ */
				.bottom-panel {
					background: var(--panel);
					border-top: 1px solid var(--border);
					padding: 10px 12px;
					text-align: start;
					display: flex;
					flex-direction: column;
					align-items: stretch;
					justify-content: flex-start;
					/* was inheriting center from the base rule */
				}

				#sliders {
					display: grid;
					align-content: start;
					/* prevents ‚Äúsag‚Äù inside a tall panel */
					gap: var(--gap-2);
				}

				/* One row per control: label | (optional help) | input */
				#sliders>div {
					display: grid;
					grid-template-columns: max-content max-content 1fr;
					align-items: center;
					/* top-align in grid cells */
					column-gap: 10px;
				}

				/* Keep the info "i" a fixed square and stop stretching */
				#sliders .help-icon-container {
					justify-self: start;
				}

				#sliders .help-icon {
					width: 16px;
					height: 16px;
					line-height: 16px;
				}

				#sliders label {
					width: 220px;
					text-align: right;
					color: var(--muted);
					white-space: nowrap;
				}

				/* Shape-settings: Color + Size side by side */
				.shape-settings {
					display: flex;
					align-items: center;
					gap: 8px;
					flex-direction: row;
					flex-wrap: nowrap;
					/* keep them on one row */
				}

				.shape-settings label {
					margin: 0;
					font-size: 12px;
					white-space: nowrap;
					/* prevent wrapping */
					text-align: left;
					display: inline-block;
				}

				.shape-settings input[type="color"],
				.shape-settings input[type="number"] {
					margin-top: 0;
					width: auto;
					min-width: 60px;
					/* avoids collapse on iPad */
				}

				/* iPad override: still side by side */
				.window.ipad .shape-settings {
					flex-wrap: nowrap;
				}

				/* Range input */
				input[type="range"] {
					-webkit-appearance: none;
					width: 100%;
					height: 8px;
					background: #fff;
					border: 1px solid var(--border);
					border-radius: 999px;

				}

				input[type="range"]::-webkit-slider-thumb {
					-webkit-appearance: none;
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: var(--accent);
					border: none;
					margin-top: -5px;
				}

				input[type="range"]::-moz-range-thumb {
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: var(--accent);
					border: none;
				}

				/* ------------------ 7. Overlays / Dialogs / Toasts ------------------ */
				.dialog-backdrop {
					display: none;
					position: fixed;
					inset: 0;
					background: rgba(0, 0, 0, .55);
					justify-content: center;
					align-items: center;
					z-index: var(--z-dialog);
				}

				.dialog-content {
					background: var(--panel-2);
					color: var(--text);
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
					padding: 16px;
					min-width: 200px;
					text-align: center;
					box-shadow: 0 16px 40px rgba(0, 0, 0, .5);
				}

				/* Splash */
				#splashOverlay {
					position: absolute;
					inset: 0;
					background-color: rgba(255, 255, 255, 0.8);
					display: none;
					/* hidden by default; toggle via JS */
					flex-direction: column;
					align-items: center;
					justify-content: center;
					z-index: var(--z-splash);
					cursor: pointer;
				}

				#splashOverlay img {
					max-width: 50%;
					max-height: 50%;
					margin-bottom: 50px;
					border: 2px solid #000;
					border-radius: var(--radius-sm);
				}

				/* Help tooltip bubble */
				.help-icon-container {
					position: relative;
					display: inline-block;
				}

				.help-icon {
					width: 16px;
					height: 16px;
					line-height: 16px;
					text-align: center;
					border-radius: 50%;
					background: #e6e7ea;
					border: 1px solid #000;
					color: #000;
					font-size: 12px;
					font-weight: bold;
					user-select: none;
					cursor: help;
				}

				.help-tooltip {
					display: none;
					position: absolute;
					bottom: 20px;
					left: 0;
					min-width: 120px;
					padding: 4px;
					font-size: 12px;
					color: var(--text);
					background: var(--panel-2);
					border: 1px solid var(--border);
					box-shadow: 0 12px 28px rgba(0, 0, 0, .35);
					z-index: var(--z-splash);
				}

				.help-icon-container:hover .help-tooltip {
					display: block;
				}

				/* Toasts */
				#toastStack {
					position: absolute;
					top: 48px;
					right: 10px;
					display: flex;
					flex-direction: column;
					gap: 8px;
					align-items: flex-end;
					pointer-events: none;
					z-index: 2000;
				}

				.toast {
					font: 14px "Courier New", monospace;
					background: #0f1115;
					color: #fff;
					border: 1px solid var(--border);
					border-radius: 10px;
					padding: 6px 10px;
					opacity: 0;
					transform: translateY(-8px);
					transition: opacity .2s, transform .2s;
				}

				.toast.show {
					opacity: .9;
					transform: translateY(0);
				}

				/* Guided tour */
				#tourOverlay {
					position: fixed;
					inset: 0;
					background: rgba(0, 0, 0, .55);
					z-index: 3000;
					pointer-events: none;
				}

				#tourTip {
					position: fixed;
					z-index: 3001;
					max-width: 320px;
					background: #fff;
					color: #000;
					border: 2px solid #000;
					border-radius: var(--radius-sm);
					padding: 10px 12px;
					box-shadow: 4px 4px 0 #000;
					font: 13px "Courier New", monospace;
				}

				#tourCtrls {
					margin-top: 8px;
					text-align: right;
				}

				#tourCtrls button {
					margin-left: 4px;
				}

				.tour-highlight {
					outline: 3px solid #ffe600 !important;
					box-shadow: 0 0 8px 3px #ffe600 !important;
				}

				/* Presets gallery */
				.presets-gallery {
					display: grid;
					grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
					gap: 12px;
					padding: 4px;
					max-height: 60vh;
					overflow-y: auto;
				}

				.preset-card {
					aspect-ratio: 1/1;
					background: #fafafa;
					border: 2px solid #000;
					box-shadow: 3px 3px 0 #000;
					position: relative;
					transition: transform .15s, box-shadow .15s;
				}

				.preset-card:hover {
					transform: translateY(-3px);
					box-shadow: 5px 5px 0 #000;
				}

				.preset-card:active {
					transform: translateY(0);
				}

				.preset-card img,
				.preset-card svg {
					width: 100%;
					height: 100%;
					object-fit: cover;
					display: block;
				}

				.preset-card figcaption {
					position: absolute;
					inset: 0;
					display: flex;
					align-items: center;
					justify-content: center;
					color: #fff;
					background: rgba(0, 0, 0, .58);
					padding: 4px;
					text-align: center;
					font: 12px "Courier New", monospace;
					opacity: 0;
					transition: opacity .15s;
				}

				.preset-card:hover figcaption {
					opacity: 1;
				}

				.preset-card.card-selected {
					outline: 3px solid #ffe600;
					box-shadow: 0 0 10px 3px #ffe600;
				}

				/* Cursor modes (unchanged) */
				.canvas-blob-mode {
					cursor: url("images/pencil.png"), auto;
				}

				.canvas-line-mode {
					cursor: url("images/pencil.png"), auto;
				}

				.canvas-circle-mode {
					cursor: url("images/CircleCursor.png"), auto;
				}

				.canvas-drag-mode {
					cursor: url("images/glove.png"), auto;
				}

				.canvas-pin-mode {
					cursor: url("images/PinCursor.png"), auto;
				}

				.canvas-slicing-mode {
					cursor: url("images/trim.png"), auto;
				}

				.canvas-freeze-mode {
					cursor: url("images/FreezeCursor.png"), auto;
				}

				.canvas-delete-mode {
					cursor: url("images/DeleteCursor.png"), auto;
				}

				/* Optional page-wide mobile notice (if you still use it) */
				#mobileWarning {
					position: fixed;
					inset: 0;
					display: none;
					background: #fff;
					color: #000;
					padding: 20px;
					align-items: center;
					justify-content: center;
					text-align: center;
					z-index: 10000;
				}

				/* ------------------ 8. iPad Layout Overrides ------------------ */
				/* Scope to .window.ipad so you can toggle via UA detection or feature flag */
				/* Default (desktop) */

				/* iPad: larger touch target (tweak as you like) */
				.window.ipad {
					--icon-size: 39px;
					--icon-gap: 9px;
				}


				.window.ipad {
					width: 100%;
					height: 100dvh;
					margin: 0;
					border-radius: 0;
					border: 0;
					box-shadow: none;
					background: var(--panel);

					/* Grid rows: title | canvas | tools | sliders */
					display: grid;
					grid-template-rows: 40px 1fr 110px 210px;
				}

				.window.ipad .title-bar {
					height: 40px;
					padding: 4px 8px;
					border-bottom: 1px solid var(--border);
				}

				.window.ipad .content {
					display: flex;
					align-items: center;
					justify-content: center;
					border-bottom: 1px solid var(--border);
					padding: 8px;
				}

				/* Canvas fills the central row without changing visual style */
				.window.ipad #glCanvas {
					margin: 0;
					border: 1px solid var(--border);
				}

				/* Bottom toolbars: horizontal sections across the row */
				/* AFTER: each section sizes to its content; no equal widths /* iPad: full-width horizontal toolbar with scroll */
				.window.ipad .toolbar {
					width: 100%;
					/* override desktop width:150px */
					height: 100%;
					display: grid;
					grid-auto-flow: column;
					grid-template-columns: none;
					grid-auto-columns: max-content;
					align-items: start;
					justify-content: center;
					gap: 10px;
					padding: 6px 10px;
					border-right: 0;
					overflow-x: auto;
					/* was overflow: hidden */
					overflow-y: hidden;
					-webkit-overflow-scrolling: touch;
					scrollbar-gutter: stable both-edges;
					/* optional: avoids layout shift */
				}

				/* keep icon rows on one line per section */
				.window.ipad .toolbar-section .icon-group {
					flex-wrap: nowrap;
				}

				/* let a chosen section soak up leftover space (optional) */
				.window.ipad .toolbar-section.toolbar--fluid {
					width: auto;
					/* allow growth */
				}

				.window.ipad .toolbar-section {
					margin: 0;
					padding: 8px;
					border: 1px solid var(--border);
					border-radius: var(--radius-lg);
				}


				.window.ipad .icon,
				.window.ipad .icon img {
					width: var(--icon-size);
					height: var(--icon-size);
				}

				/* Sliders row: edge-to-edge grid with consistent rows */
				.window.ipad .bottom-panel {
					align-items: stretch;
					padding: 8px 80px;
					/* symmetric breathing room */
				}

				.window.ipad #sliders {
					grid-template-columns: 1fr;
					/* one control per line */
					grid-auto-rows: 28px;
					gap: 6px;
				}

				.window.ipad #sliders>div {
					grid-template-columns: auto auto 1fr;
					column-gap: 10px;
				}

				/* Larger thumb for touch; keeps track centered */
				.window.ipad input[type="range"]::-webkit-slider-thumb {
					width: 28px;
					height: 28px;
					border-radius: 50%;
					margin-top: 0;
					background: #2563eb;
					border: 2px solid #000;
				}

				.window.ipad input[type="range"]::-moz-range-thumb {
					width: 28px;
					height: 28px;
					border-radius: 50%;
					background: #c0c0c0;
					border: 2px solid #000;
				}

				/* Label comfort + alignment */
				.window.ipad #sliders label {
					width: 200px;
					/* give longer labels room */
					text-align: right;
					white-space: nowrap;
					margin: 0;
				}


				/* Keep splash/toast absolute on iPad, but dialogs must be fixed */
				.window.ipad #splashOverlay,
				.window.ipad #toastStack {
					position: absolute;
				}

				.window.ipad .dialog-backdrop {
					position: fixed;
					/* was absolute via grouped selector */
				}

				/* Make the start instruction look like a tappable button on iPad */
				.window.ipad #splashOverlay .splashText {
					display: inline-block;
					padding: 10px 16px;
					margin-top: 12px;
					background: #2563eb;
					/* bright blue */
					color: #fff;
					font-weight: bold;
					border-radius: 8px;
					box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.4);
					border: 2px solid #000;
					text-align: center;
				}

				/* Hide any legacy mobile warning while in iPad layout */
				.window.ipad~#mobileWarning {
					display: none !important;
				}

				#sliders .help-icon-container {
					display: flex;
					align-items: center;
					justify-content: center;
					/* centers the ‚ìò in its 32px cell */
				}

				#sliders .help-icon {
					width: 24px;
					/* fits comfortably in a 40px row */
					height: 24px;
					line-height: 24px;
				}

				/* Lighter grid lines to match light theme */


			}
		}
	</style>
</head>

<body>
	<div class="window">
		<!-- Splash Overlay -->
		<div id="splashOverlay">
			<img src="images/splash.png" alt="Splash Image" />
			<div class="splashText">Click and Drag to Start Blobbing</div>
		</div>
		<div id="toastStack"></div>
		<div id="tourOverlay" style="display:none;"></div>
		<div id="tourTip" style="display:none;">
			<div id="tourText"></div>
			<div id="tourCtrls">
				<button id="tourPrev">‚óÄ Prev</button>
				<button id="tourNext">Next ‚ñ∂</button>
				<button id="tourExit">End ‚úñ</button>
			</div>
		</div>
		<!-- Title Bar -->
		<div class="title-bar">
			<div class="menu-bar">
				<span id="menuFile">File
					<div class="submenu" id="fileSubmenu">
						<span id="saveBlobsOption">Save Blobs (JSON)</span>
						<span id="loadBlobsOption">Load Blobs (JSON)</span>
					</div>
				</span>
				<span id="menuExport">Export
					<div class="submenu" id="exportSubmenu">
						<span id="exportStrokedOption">...Lines&gt;SVG</span>
						<span id="exportStrokedJPGOption">...Lines&gt;JPG</span>
						<span id="exportFilledOption">...Fill&gt;SVG</span>
						<span id="exportFilledJPGOption">...Fill&gt;JPG</span>
					</div>
				</span>
				<span id="menuPresets">Presets</span>
				<span id="menuAbout">About</span>
				<span id="menuHelp">Help</span>
			</div>
			<div class="title-actions">
				<span id="resetIcon" class="reset-icon" title="Reset Canvas">üóëÔ∏è</span>
				<span id="notifToggle" class="reset-icon" title="Disable tips">üîî</span>
			</div>
		</div>

		<!-- Main Content -->
		<div class="content">
			<!-- Toolbar: grouped into Draw Tools, Edit Tools, Canvas Tools, and now Shape Settings -->
			<div class="toolbar">
				<!-- DRAW TOOLS -->
				<div class="toolbar-section">
					<h4>Draw Tools</h4>
					<div class="icon-group">
						<div class="icon" id="iconBlob" data-label="Blob (Q)">
							<img src="images/blob.png" alt="Blob Mode" />
						</div>
						<div class="icon" id="iconLine" data-label="Line (W)">
							<img src="images/line.png" alt="Line Mode" />
						</div>
						<div class="icon" id="iconCircle" data-label="Circle (E)">
							<img src="images/wrap.png" alt="Circle Mode" />
						</div>
					</div>
				</div>

				<!-- EDIT TOOLS -->
				<div class="toolbar-section" id="editToolsSection">
					<h4>Edit Tools</h4>
					<div class="icon-group">
						<div class="icon" id="iconDrag" data-label="Drag (A)">
							<img src="images/gloveIcon.png" alt="Drag Mode" />
						</div>
						<div class="icon" id="iconFreeze" data-label="Freeze (S)">
							<img src="images/freeze.png" alt="Freeze Mode" />
						</div>
						<div class="icon" id="iconPin" data-label="Pin (D)">
							<img src="images/pin.png" alt="Pin Mode" />
						</div>
						<div id="iconSlice">
						</div>
						<div class="icon" id="iconDelete" data-label="Delete (X)">
							<img src="images/delete.png" alt="Delete">
						</div>
					</div>
				</div>

				<!-- SHAPE SETTINGS (Color, Gap, ŒîSize) -->
				<div class="toolbar-section">
					<h4>Shape Settings</h4>
					<div class="shape-settings">
						<div>
							<label for="blobColor">Color</label>
							<input type="color" id="blobColor" value="#0066ff">
						</div>
						<div>
							<label for="radiusAvgInput">Size</label>
							<input type="number" id="radiusAvgInput" min="0.0" max="20" step="0.2" value="5">
						</div>
					</div>
				</div>

				<!-- CANVAS TOOLS -->
				<div class="toolbar-section">
					<h4>Canvas</h4>
					<div class="icon-group">
						<div class="icon" id="iconThickness" data-label="Line Thickness">T</div>
						<div class="icon" id="iconFill" data-label="Solid Fill">‚ñ£</div>
						<div class="icon" id="iconDiffusion" data-label="High Blob Repel"><img src="images/repel.png" alt="Overlap Guard" /></div>
						<div class="icon" id="iconUndo" data-label="Undo Last Item">‚éå</div>
					</div>
				</div>
			</div>

			<!-- Main Drawing Area -->
			<div class="main-area">
				<canvas id="glCanvas" width="500" height="500"></canvas>
			</div>
		</div>

		<!-- Bottom Panel: Sliders -->
		<div class="bottom-panel">
			<div id="sliders">
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = bigger blobs/lines.
						</div>
					</div>
					<label for="dotScaleSlider" class="slider-label">Blob Size: <span id="dotScaleValue">39%</span></label>
					<input type="range" id="dotScaleSlider" min="0" max="100" value="39" step="0.5">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = more wobble.
						</div>
					</div>
					<label for="dampingSlider">Excitability: <span id="dampingValue">85%</span></label>
					<input type="range" id="dampingSlider" min="0" max="100" value="85" step="0.5">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = tighter shapes.
						</div>
					</div>
					<label for="springConstantSlider">Rigidity: <span id="springConstantValue">30%</span></label>
					<input type="range" id="springConstantSlider" min="0" max="100" value="30" step="1">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Higher = more expansion.
						</div>
					</div>
					<label for="repulsionConstantSlider">Turmoil: <span id="repulsionConstantValue">10%</span></label>
					<input type="range" id="repulsionConstantSlider" min="0" max="100" value="10" step="1">
				</div>
				<div>
					<div class="help-icon-container">
						<span class="help-icon">i</span>
						<div class="help-tooltip">
							Shapes animate faster when higher.
						</div>
					</div>
					<label for="timeStepSlider">Animation Speed: <span id="timeStepValue">47%</span></label>
					<input type="range" id="timeStepSlider" min="0" max="100" value="47" step="1">
				</div>
			</div>
		</div>

		<!-- ‚ñë PRESETS DIALOG ‚ñë -->
		<div class="dialog-backdrop" id="presetsBackdrop">
			<div class="dialog-content presets-dialog">
				<h3>Select a Preset</h3>

				<div id="presetsGallery" class="presets-gallery">
					<!-- Grid preset card -->
					<div class="preset-card" id="presetGrid">
						<svg viewBox="0 0 100 100" width="100%" height="100%">
							<rect width="100" height="100" fill="#fff" />
							<g stroke="#000" stroke-width="2" fill="none">
								<!-- 5 √ó 5 grid preview -->
								<circle cx="10" cy="10" r="8" />
								<circle cx="30" cy="10" r="8" />
								<circle cx="50" cy="10" r="8" />
								<circle cx="70" cy="10" r="8" />
								<circle cx="90" cy="10" r="8" />

								<circle cx="10" cy="30" r="8" />
								<circle cx="30" cy="30" r="8" />
								<circle cx="50" cy="30" r="8" />
								<circle cx="70" cy="30" r="8" />
								<circle cx="90" cy="30" r="8" />

								<circle cx="10" cy="50" r="8" />
								<circle cx="30" cy="50" r="8" />
								<circle cx="50" cy="50" r="8" />
								<circle cx="70" cy="50" r="8" />
								<circle cx="90" cy="50" r="8" />

								<circle cx="10" cy="70" r="8" />
								<circle cx="30" cy="70" r="8" />
								<circle cx="50" cy="70" r="8" />
								<circle cx="70" cy="70" r="8" />
								<circle cx="90" cy="70" r="8" />

								<circle cx="10" cy="90" r="8" />
								<circle cx="30" cy="90" r="8" />
								<circle cx="50" cy="90" r="8" />
								<circle cx="70" cy="90" r="8" />
								<circle cx="90" cy="90" r="8" />
							</g>
						</svg>
						<figcaption>Grid of Circles</figcaption>
					</div>
					<div class="preset-card" id="presetBlobGrid">
						<img src="images/grid_of_blobs.png" alt="Grid of Blobs">
						<figcaption>Grid of Blobs</figcaption>
					</div>
					<div class="preset-card" id="presetAnthro">
						<!-- tiny 100√ó100 PNG or SVG is fine; use any placeholder for now -->
						<img src="images/anthro_blobs.png" alt="Anthro Blobs">
						<figcaption>Blob Face</figcaption>
					</div>
				</div>

				<button id="closePresets">Close</button>
			</div>
		</div>

		<div class="dialog-backdrop" id="gridBackdrop">
			<div class="dialog-content">
				<h3>Grid of Circles</h3>

				<label>Count
					<input type="number" id="gridCount" value="5" min="1" max="12">
				</label><br>

				<label>
					<input type="checkbox" id="autoRadius" checked>
					Fit circles to canvas
				</label><br>

				<div id="radiusRow" style="display:none;">
					<label>Radius
						<input type="number" id="gridRadius" value="20" min="2" max="200">
					</label><br>
				</div>

				<button id="applyGrid">Apply</button>
				<button id="cancelGrid">Cancel</button>
			</div>

		</div>
		<div class="dialog-backdrop" id="blobGridBackdrop">
			<div class="dialog-content">
				<h3>Grid of Blobs</h3>

				<label>Count (rows = cols)
					<input type="number" id="blobGridCount" value="5" min="1" max="10">
				</label><br>

				<label>
					<input type="checkbox" id="blobAutoSize" checked>
					Fit blobs to canvas
				</label><br>

				<div id="blobSizeRow" style="display:none;">
					<label>Base Radius
						<input type="number" id="blobBaseRadius" value="20" min="4" max="120">
					</label><br>
				</div>

				<button id="applyBlobGrid">Apply</button>
				<button id="cancelBlobGrid">Cancel</button>
			</div>
		</div>

		<!-- Modals/Dialogs: About and Help -->
		<div class="dialog-backdrop" id="aboutBackdrop">
			<div class="dialog-content">
				<p>blobSketch version 1.12</p>
				<p>by Colin Reid</p>
				<button id="closeAbout">OK</button>
			</div>
		</div>

		<!-- ‚ñë SAVE / IMPORT OPTION DIALOGS ‚ñë -->
		<div class="dialog-backdrop" id="saveOptionsBackdrop">
			<div class="dialog-content">
				<h3>Save Options</h3>
				<label><input type="checkbox" id="saveIncludeChains" checked>‚ÄØBlobs‚ÄØ/‚ÄØLines</label><br>
				<label><input type="checkbox" id="saveIncludeCircles" checked>‚ÄØCircles</label><br>
				<label><input type="checkbox" id="saveIncludeSettings">‚ÄØPhysics & UI Settings</label><br>
				<button id="confirmSaveBtn">Save</button>
				<button id="cancelSaveBtn">Cancel</button>
			</div>
		</div>

		<div class="dialog-backdrop" id="importOptionsBackdrop">
			<div class="dialog-content">
				<h3>Import Options</h3>
				<label><input type="checkbox" id="importIncludeChains" checked>‚ÄØBlobs‚ÄØ/‚ÄØLines</label><br>
				<label><input type="checkbox" id="importIncludeCircles" checked>‚ÄØCircles</label><br>
				<label><input type="checkbox" id="importIncludeSettings" checked>‚ÄØPhysics & UI Settings</label><br>
				<button id="confirmImportBtn">Import</button>
				<button id="cancelImportBtn">Cancel</button>
			</div>
		</div>

		<!-- ‚ñë END DIALOGS ‚ñë -->
	</div>
	<div id="circleInfo" style="
     position:fixed; display:none; z-index:10000;
     pointer-events:none; font:12px 'Courier New',monospace;
     padding:3px 6px; background:#ffffcc;
     border:1px solid #000; box-shadow:3px 3px 0 #000;">
	</div>
	<script>
		if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			document.addEventListener("DOMContentLoaded", function() {
				var warningDiv = document.createElement("div");
				warningDiv.id = "mobileWarning";
				warningDiv.innerHTML = '<h1>Desktop or iPad Only</h1><p>This application is best experienced on a desktop or iPad browser. Please switch to a desktop or ipad device.</p>';
				document.body.appendChild(warningDiv);
			});
		}

		document.addEventListener("DOMContentLoaded", () => {
			/* -----------------------------------
			   SHORTCUTS & UTILITIES
			----------------------------------- */
			const $ = id => document.getElementById(id);
			const circleInfo = $("circleInfo");

			// ==== Spatial Hash Setup ====
			const cellSize = 50; // adjust ~ to  max interaction distance
			let spatialHash = new Map();
			const neighborOffsets = [
				[0, 0],
				[1, 0],
				[-1, 0],
				[0, 1],
				[1, 1],
				[-1, 1],
				[0, -1],
				[1, -1],
				[-1, -1]
			];

			function hashKey(cx, cy) {
				return `${cx},${cy}`;
			}

			function buildSpatialHash() {
				spatialHash.clear();
				for (let c = 0; c < chains.length; c++) {
					const ch = chains[c].chain;
					const rA = chains[c].baseDotRadius * dotScaleFactor;
					for (let i = 0; i < ch.length; i++) {
						const p = ch[i];
						const cx = Math.floor(p.x / cellSize);
						const cy = Math.floor(p.y / cellSize);
						const key = hashKey(cx, cy);
						if (!spatialHash.has(key)) spatialHash.set(key, []);
						spatialHash.get(key).push({ c, i, p, r: rA });
					}
				}
			}

			// Helper for converting from one numeric range to another
			function mapRange(value, inMin, inMax, outMin, outMax) {
				return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
			}

			const hexToRGBA = hex => {
				if (hex[0] === "#") hex = hex.slice(1);
				const r = parseInt(hex.slice(0, 2), 16) / 255,
					g = parseInt(hex.slice(2, 4), 16) / 255,
					b = parseInt(hex.slice(4, 6), 16) / 255;
				return [r, g, b, 1.0];
			};

			function setDotScale(percent) {
				percent = Math.max(DOT_MIN_PERCENT,
					Math.min(DOT_MAX_PERCENT, percent));

				$("dotScaleSlider").value = percent;
				$("dotScaleValue").textContent = Math.round(percent) + "%";

				dotScaleFactor = mapRange(percent, 0, 100, 0.1, 5);
			}

			/* ---------- toast notifications ---------- */
			let tipsEnabled = false;
			$("notifToggle").onclick = () => {
				tipsEnabled = !tipsEnabled;
				$("notifToggle").textContent = tipsEnabled ? "üîî" : "üîï";
				$("notifToggle").title = tipsEnabled ? "Disable tips" : "Enable tips";
			};
			/* 2 ‚ñ∏ ensure the bell shows the muted state on first load */
			$("notifToggle").textContent = "üîï";
			$("notifToggle").title = "Enable tips";

			function toast(msg, ms = 2200) {
				if (!tipsEnabled) return;
				const el = document.createElement("div");
				el.className = "toast";
				el.textContent = msg;
				$("toastStack").appendChild(el);
				requestAnimationFrame(() => el.classList.add("show")); // fade in
				setTimeout(() => {
					el.classList.remove("show"); // fade out
					el.addEventListener("transitionend", () => el.remove(), { once: true });
				}, ms);
			}

			/* -----------------------------------
			   SPLASH OVERLAY
			----------------------------------- */
			$("splashOverlay").onclick = () => {
				$("splashOverlay").style.display = "none";
			};

			/* -----------------------------------
			   DIALOG SETUP (ABOUT, HELP)
			----------------------------------- */
			function setupDialog(openBtnId, backdropId, closeBtnId) {
				const openBtn = $(openBtnId),
					backdrop = $(backdropId),
					closeBtn = $(closeBtnId);
				openBtn.addEventListener("click", () => (backdrop.style.display = "flex"));
				closeBtn.addEventListener("click", () => (backdrop.style.display = "none"));
			}
			setupDialog("menuAbout", "aboutBackdrop", "closeAbout");
			$("menuHelp").addEventListener("click", startTour);
			window.addEventListener("keydown", e => { if (e.key === "h" || e.key === "H") startTour(); });

			/* -----------------------------------
			   FILE & EXPORT MENU
			----------------------------------- */
			function setupSubmenu(menuId, submenuId) {
				const menu = $(menuId),
					submenu = $(submenuId);
				let visible = false;
				menu.addEventListener("click", (e) => {
					e.stopPropagation();
					visible = !visible;
					submenu.style.display = visible ? "flex" : "none";
				});
				document.addEventListener("click", (e) => {
					if (!menu.contains(e.target) && visible) {
						visible = false;
						submenu.style.display = "none";
					}
				});
			}
			setupSubmenu("menuFile", "fileSubmenu");
			setupSubmenu("menuExport", "exportSubmenu");


			/* ---------- PRESETS ---------- */
			$("menuPresets").onclick = () => {
				$("presetsBackdrop").style.display = "flex";
			};

			/* close gallery */
			$("closePresets").onclick = () =>
				$("presetsBackdrop").style.display = "none";

			/* show the Grid-options dialog when the card is clicked */
			$("presetGrid").onclick = () => {
				$("presetsBackdrop").style.display = "none";
				$("gridBackdrop").style.display = "flex";
			};

			/* cancel grid dialog */
			$("cancelGrid").onclick = () =>
				$("gridBackdrop").style.display = "none";

			/* show / hide the custom-radius row */
			$("autoRadius").onchange = () =>
				$("radiusRow").style.display = $("autoRadius").checked ? "none" : "block";

			/* apply grid */
			$("applyGrid").onclick = () => {
				const count = Math.min(12,
					Math.max(1, parseInt($("gridCount").value, 10) || 1));
				/* this radius would make circles kiss each other and the edges */
				/* leave a 1px gap between adjacent circles */
				const maxR = (Math.min(canvas.width, canvas.height) - (count - 1)) / (count * 2);

				const radius = $("autoRadius").checked ?
					maxR :
					Math.min(parseFloat($("gridRadius").value) || 2, maxR);

				const spacing = 2 * maxR + 1; // +1 ensures 1px gap between centers

				for (let r = 0; r < count; r++) {
					for (let c = 0; c < count; c++) {
						circles.push({
							x: maxR + c * spacing,
							y: maxR + r * spacing,
							radius // may be < maxR ‚áí nice margin
						});
						history.push({ type: "circle" });
					}
				}

				/* set Blob Size slider to 0 % and Excitability to 85 % */
				setDotScale(0); // updates UI + dotScaleFactor
				damping = 0.85;
				$("dampingSlider").value = 85;
				$("dampingValue").textContent = "85%";
				/* ‚îÄ‚îÄ 1. High Repulsion ON ‚îÄ‚îÄ */
				if (interRepelMult !== 3) { // 1 = normal, 3 = high
					interRepelMult = 3;
					toggleActiveIcon($("iconDiffusion"), true);
				}

				/* ‚îÄ‚îÄ 2. Blob draw-mode ‚îÄ‚îÄ */
				setDrawMode("blob"); // switches UI + cursor

				/* ‚îÄ‚îÄ 3. Edit tools OFF ‚îÄ‚îÄ */
				slicingMode = dragMode = pinMode =
					freezeMode = deleteMode = false; // clear flags
				$("editToolsSection").classList.remove("edit-on");
				["iconSlice", "iconDrag", "iconPin", "iconFreeze", "iconDelete"]
				.forEach(id => setIconActive($(id), false, "", ""));
				updateCanvasCursor();

				if (!solidFillMode) {
					solidFillMode = true;
					$("iconFill").title = "Solid Fill On";
					toggleActiveIcon($("iconFill"), true);
				}

				toast(`Grid (${count}√ó${count}) added`, 1600);
				$("gridBackdrop").style.display = "none";
			};

			/* === ANTHRO BLOBS PRESET =========================================== */
			$("presetAnthro").onclick = () => {
				$("presetsBackdrop").style.display = "none"; // close gallery
				addAnthroBlobs(8); // draw 8 faces by default
			};

			/* helper: main face + eyes + pupils + mouth ------------------------- */
			function addAnthroBlobs(count = 8) {

				/* clamp Excitability (damping) to 0 % */
				damping = 0;
				$("dampingSlider").value = 0;
				$("dampingValue").textContent = "0%";

				/* step 0 ‚îÄ turn High-Repel ON (keeps blobs apart) */
				if (interRepelMult !== 3) { // 1 = normal, 3 = boosted
					interRepelMult = 3; // physics flag
					toggleActiveIcon($("iconDiffusion"), true); // light the toolbar icon
				}

				const palette = ["#ff3333", "#ffd700", "#0066ff", "#000000"]; // red, yellow, blue, black
				const placed = []; // remember centres

				for (let k = 0; k < count; k++) {

					/* find a free, non-overlapping position (‚â§100 tries) */
					let cx, cy, R, ok, tries = 100;
					do {
						R = 30 + Math.random() * 40; // 30‚Äí70 px radius
						cx = R + Math.random() * (canvas.width - 2 * R);
						cy = R + Math.random() * (canvas.height - 2 * R);

						ok = true;
						for (const p of placed) {
							const minGap = R + p.R + 6; // 6 px padding
							if (Math.hypot(cx - p.cx, cy - p.cy) < minGap) { ok = false; break; }
						}
					} while (!ok && --tries);
					if (!ok) continue; // couldn‚Äôt place

					placed.push({ cx, cy, R });

					/* 1 ‚îÄ base face blob */
					const faceCol = palette[Math.floor(Math.random() * palette.length)];
					const faceArr = hexToRGBA(faceCol);
					chains.push(makeCircleBlob(cx, cy, R, faceArr));
					history.push({ type: "chain" });

					/* 2 ‚îÄ eyes & pupils */
					const eyeDX = R * 0.30,
						eyeDY = -R * 0.20,
						eyeR = R * 0.18;
					const pupilR = eyeR * 0.40;
					const white = hexToRGBA("#ffffff");
					const pupilArr = hexToRGBA("#000000"); // pupils always black

					// left eye
					chains.push(makeCircleBlob(cx - eyeDX, cy + eyeDY, eyeR, white, 10));
					chains.push(makeCircleBlob(cx - eyeDX, cy + eyeDY, pupilR, pupilArr, 8));
					// right eye
					chains.push(makeCircleBlob(cx + eyeDX, cy + eyeDY, eyeR, white, 10));
					chains.push(makeCircleBlob(cx + eyeDX, cy + eyeDY, pupilR, pupilArr, 8));
					history.push({ type: "chain" }, { type: "chain" }, { type: "chain" }, { type: "chain" });

					/* 3 ‚îÄ mouth (more-dots straight line) ----------------------------- */
					const mouthY = cy + R * 0.25,
						mouthW = R * 0.75, // width already bumped
						mouthArr = hexToRGBA(faceCol === "#000000" ? "#ffffff" : "#000000");

					/* roughly 8 points across the span (left ‚Üí right) */
					const mouthPts = [];
					const segments = 7; // 7 gaps ‚áí 8 dots
					for (let i = 0; i <= segments; i++) {
						const t = i / segments; // 0 ‚Ä¶ 1
						mouthPts.push({
							x: cx - mouthW + 2 * mouthW * t, // linear x-interpolation
							y: mouthY, // keep flat (straight line)
							vx: 0,
							vy: 0,
							pinned: false
						});
					}

					chains.push({
						chain: mouthPts,
						color: mouthArr,
						baseDotRadius: R * 0.06,
						isClosed: false,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				/* make sure fill mode + Blob draw-mode are active */
				if (!solidFillMode) {
					solidFillMode = true;
					$("iconFill").title = "Solid Fill On";
					toggleActiveIcon($("iconFill"), true);
				}
				setDrawMode("blob");

				toast(`Anthro blobs (${count}) added`, 1600);
				toast("Raise the Excitability slider to see the blobs come alive!", 3000);
			}

			/* === GRID-OF-BLOBS PRESET ======================================== */
			$("presetBlobGrid").onclick = () => {
				$("presetsBackdrop").style.display = "none"; // ‚ú® hide gallery
				$("blobGridBackdrop").style.display = "flex"; // show blob-dialog
			};

			/* toggle custom size row */
			$("blobAutoSize").onchange = () =>
				$("blobSizeRow").style.display = $("blobAutoSize").checked ? "none" : "block";

			/* helper to create a simple circular blob (you could swap in fancier math) */
			function makeCircleBlob(cx, cy, r, colorArr, steps = 48) {
				const pts = [];
				for (let i = 0; i < steps; i++) {
					const Œ∏ = i / steps * 2 * Math.PI;
					pts.push({
						x: cx + r * Math.cos(Œ∏),
						y: cy + r * Math.sin(Œ∏),
						vx: 0,
						vy: 0,
						pinned: false
					});
				}
				return {
					chain: pts,
					color: colorArr,
					baseDotRadius: r * 0.12,
					isClosed: true,
					frozen: false
				};
			}

			/* Apply button */
			$("applyBlobGrid").onclick = () => {
				/* 1 ‚îÄ grid sizing */
				const cnt = Math.min(10,
					Math.max(1, parseInt($("blobGridCount").value, 10) || 1));
				const maxR = Math.min(canvas.width, canvas.height) / (cnt * 2);

				const baseR = $("blobAutoSize").checked ?
					maxR :
					Math.min(parseFloat($("blobBaseRadius").value) || 4, maxR);

				const spacing = 2 * maxR; // centres stay fixed

				const chosenColor = hexToRGBA($("blobColor").value);
				/* 2 ‚îÄ add blobs */
				for (let r = 0; r < cnt; r++) {
					for (let c = 0; c < cnt; c++) {
						const cx = maxR + c * spacing;
						const cy = maxR + r * spacing;
						const blob = makeCircleBlob(cx, cy, baseR, chosenColor);
						chains.push(blob);
						history.push({ type: "chain" });
					}
				}

				/* 3 ‚îÄ snap UI states exactly like circle-grid did */
				{
					if (interRepelMult !== 3) {
						interRepelMult = 3;
						toggleActiveIcon($("iconDiffusion"), true);
					}
					setDrawMode("blob");
					$("dampingSlider").value = 40;
					$("dampingValue").textContent = "40%";
					setDotScale(12);
					damping = 0.40;
					if (!solidFillMode) {
						solidFillMode = true;
						$("iconFill").title = "Solid Fill On";
						toggleActiveIcon($("iconFill"), true);
					}
					slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;
					$("editToolsSection").classList.remove("edit-on");
					["iconSlice", "iconDrag", "iconPin", "iconFreeze", "iconDelete"]
					.forEach(id => setIconActive($(id), false, "", ""));
					updateCanvasCursor();
				}

				toast(`Blob grid (${cnt}√ó${cnt}) added`, 1600);
				$("blobGridBackdrop").style.display = "none";
			};
			$("cancelBlobGrid").onclick = () =>
				$("blobGridBackdrop").style.display = "none";

			/* -----------------------------------
			   WEBGL CONTEXT
			----------------------------------- */
			const canvas = $("glCanvas");

			// --- Pointer normalization helpers ---
			function getCanvasXY(evt) {
				// Use CSS box but scale into the canvas's internal pixel space
				const rect = canvas.getBoundingClientRect();
				const scaleX = canvas.width / rect.width;
				const scaleY = canvas.height / rect.height;
				const x = (evt.clientX - rect.left) * scaleX;
				const y = (evt.clientY - rect.top) * scaleY;
				return { x, y };
			}

			// Primary pointer test: accept pen/touch, left mouse only
			function isPrimaryPointer(evt) {
				return (evt.isPrimary !== false) && (evt.pointerType !== "mouse" || evt.button === 0);
			}

			// Optional: use pressure for dynamic radius when drawing with Pencil
			function getPressure(evt) {
				// 0..1 on Apple Pencil; mouse is 0 or 0.5+ depending on browser
				return (typeof evt.pressure === "number" && evt.pressure > 0) ? evt.pressure : 1;
			}


			const gl = canvas.getContext("webgl", { stencil: true });
			if (!gl) alert("WebGL not supported by your browser.");
			gl.enable(gl.BLEND);
			gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,
				gl.ONE, gl.ONE_MINUS_SRC_ALPHA);


			// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Unified Pointer Events (mouse + touch + Pencil) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
			let activePointerId = null;

			canvas.addEventListener("pointerdown", (e) => {
				if (!isPrimaryPointer(e)) return;
				e.preventDefault();
				activePointerId = e.pointerId;
				canvas.setPointerCapture(activePointerId);

				const { x, y } = getCanvasXY(e);
				const pressure = getPressure(e);

				currentMouseX = x;
				currentMouseY = y;

				if (drawMode === 'circle') {
					if (dragMode) {
						for (let i = 0; i < circles.length; i++) {
							const c = circles[i];
							if (Math.hypot(x - c.x, y - c.y) < c.radius + 5) { draggingCircleIndex = i; return; }
						}
						return;
					} else {

						// ‚îÄ‚îÄ Long-press to resize an existing circle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
						// ‚îÄ‚îÄ Long-press to resize an existing circle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
						{
							let hitIndex = null;
							for (let i = circles.length - 1; i >= 0; i--) {
								const c = circles[i];
								const d = Math.hypot(x - c.x, y - c.y);
								if (d <= c.radius) { hitIndex = i; break; }
							}

							if (hitIndex !== null) {
								waitingForLongPress = true; // <‚Äî NEW
								longPressTargetIndex = hitIndex;
								longPressStartX = x;
								longPressStartY = y;

								if (longPressTimer) {
									clearTimeout(longPressTimer);
									longPressTimer = null;
								}
								longPressTimer = setTimeout(() => {
									// Activate resize mode after 5s (only if we‚Äôre still waiting)
									if (!waitingForLongPress) return;
									resizingCircleIndex = longPressTargetIndex;
									if (resizingCircleIndex !== null) {
										circles[resizingCircleIndex].__resizing = true;
									}
									isCircleDrawing = false;
									currentCircle = null;
									waitingForLongPress = false; // we‚Äôre no longer waiting
								}, resizeHoldMs);

								return; // Defer decision to move: either resize (after 5s) or start new circle on drift
							}
						}
						// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
						// ‚îÄ‚îÄ‚îÄ


						isCircleDrawing = true;
						currentCircle = { x, y, radius: 0 };
						return;
					}
				}

				if (freezeMode) {
					// find all closed blobs under the pointer
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						const ch = chains[i];
						if (!ch.isClosed) continue;
						if (pointInPolygon(x, y, ch.chain)) hits.push(i);
					}

					// pick the smallest one and toggle frozen/alpha
					if (hits.length) {
						let bestIndex = hits[0];
						let bestArea = polygonArea(chains[bestIndex].chain);
						for (let k = 1; k < hits.length; k++) {
							const idx = hits[k];
							const area = polygonArea(chains[idx].chain);
							if (area < bestArea) {
								bestIndex = idx;
								bestArea = area;
							}
						}
						const obj = chains[bestIndex];
						obj.frozen = !obj.frozen;
						obj.alpha = obj.frozen ? 0.3 : 1.0; //
					}
					return; // stop further handling
				}
				if (deleteMode) {
					// a) delete circles first
					for (let i = 0; i < circles.length; i++) {
						const c = circles[i];
						const dx = x - c.x,
							dy = y - c.y;
						if (Math.hypot(dx, dy) < c.radius) {
							circles.splice(i, 1);
							history.push({ type: "circle" });
							return; // done
						}
					}

					// b) delete open lines if near a segment
					const SEG_TOL = 6;
					for (let k = 0; k < chains.length; k++) {
						const obj = chains[k];
						if (obj.isClosed) continue;
						const pts = obj.chain;
						for (let i = 0; i < pts.length - 1; i++) {
							const a = pts[i],
								b = pts[i + 1];
							const denom = (b.x - a.x) ** 2 + (b.y - a.y) ** 2 || 1; // avoid /0
							const t = ((x - a.x) * (b.x - a.x) + (y - a.y) * (b.y - a.y)) / denom;
							const clamped = Math.max(0, Math.min(1, t));
							const px = a.x + clamped * (b.x - a.x);
							const py = a.y + clamped * (b.y - a.y);
							if (Math.hypot(x - px, y - py) < SEG_TOL) {
								chains.splice(k, 1);
								history.push({ type: "chain" });
								return; // done
							}
						}
					}

					// c) delete the smallest closed blob under the point
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						const ch = chains[i];
						if (!ch.isClosed) continue;
						if (pointInPolygon(x, y, ch.chain)) hits.push(i);
					}
					if (hits.length) {
						let best = hits[0],
							bestArea = polygonArea(chains[best].chain);
						for (let j = 1; j < hits.length; j++) {
							const idx = hits[j];
							const area = polygonArea(chains[idx].chain);
							if (area < bestArea) {
								best = idx;
								bestArea = area;
							}
						}
						chains.splice(best, 1);
						history.push({ type: "chain" });
					}
					return; // stop further handling in delete mode
				}

				if (pinMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20; // same radius you use in mousedown

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dx = x - ch[i].x;
							const dy = y - ch[i].y;
							const d = Math.hypot(dx, dy);
							if (d < pickRadius && d < bestDist) {
								bestDist = d;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const dot = chains[bestChainIndex].chain[bestDotIndex];
						dot.pinned = !dot.pinned; // toggle
					}
					return; // stop further handling
				}

				if (dragMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dx = x - ch[i].x,
								dy = y - ch[i].y;
							const dist = Math.hypot(dx, dy);
							if (dist < pickRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						draggingChainIndex = bestChainIndex;
						draggingDotIndex = bestDotIndex;
						return; // we‚Äôre dragging; stop here
					}
				}



				if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
					isDrawing = true;
					currentPathPoints = [{ x, y, vx: 0, vy: 0, pinned: false }];
				}
				// ‚Üë‚Üë‚Üë END: adapted mousedown body
			}, { passive: false });

			canvas.addEventListener("pointermove", (e) => {
				if (activePointerId !== null && e.pointerId !== activePointerId) return;

				// ‚úÖ Only use the most recent coalesced event (or fall back to e)
				const ce = (e.getCoalescedEvents && e.getCoalescedEvents().pop()) || e;

				const { x, y } = getCanvasXY(ce);
				currentMouseX = x;
				currentMouseY = y;

				// If we were waiting for long-press but the finger moved too much, start drawing a new circle instead
				if (waitingForLongPress && longPressTimer && longPressTargetIndex !== null) {
					const drift = Math.hypot(x - longPressStartX, y - longPressStartY);
					if (drift > LONG_PRESS_MOVE_CANCEL) {
						// Cancel long-press path
						clearTimeout(longPressTimer);
						longPressTimer = null;
						waitingForLongPress = false;
						longPressTargetIndex = null;

						// Start a new circle draw RIGHT HERE (even if inside another circle)
						isCircleDrawing = true;
						// Seed from the original touch-down point for a natural feel
						currentCircle = {
							x: longPressStartX,
							y: longPressStartY,
							radius: drift, // small initial radius based on the first move
						};
					}
				}
				// Cancel pending long-press if finger drifts too far
				if (longPressTimer && longPressTargetIndex !== null) {
					const drift = Math.hypot(x - longPressStartX, y - longPressStartY);
					if (drift > LONG_PRESS_MOVE_CANCEL) {
						clearTimeout(longPressTimer);
						longPressTimer = null;
						longPressTargetIndex = null;
					}
				}

				// Live-resize an active circle
				if (resizingCircleIndex !== null) {
					const c = circles[resizingCircleIndex];
					c.radius = Math.hypot(x - c.x, y - c.y);
					// optional HUD
					if (typeof circleInfo !== 'undefined' && circleInfo) {
						circleInfo.textContent = "r: " + Math.round(c.radius);
						circleInfo.style.left = (e.clientX + 14) + "px";
						circleInfo.style.top = (e.clientY + 18) + "px";
						circleInfo.style.display = "block";
					}
					return; // swallow move while resizing
				}
				// draw path (blob/line)
				if (isDrawing && (drawMode === 'blob' || drawMode === 'line')) {
					const last = currentPathPoints[currentPathPoints.length - 1];
					if (Math.hypot(x - last.x, y - last.y) > 1.5) {
						currentPathPoints.push({ x, y, vx: 0, vy: 0, pinned: false });
					}
				}

				// resize in-progress circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					currentCircle.radius = Math.hypot(x - currentCircle.x, y - currentCircle.y);
				}

				// drag existing circle (when in circle+drag)
				if (drawMode === 'circle' && dragMode && draggingCircleIndex !== null) {
					circles[draggingCircleIndex].x = x;
					circles[draggingCircleIndex].y = y;
				}

				// pin/drag hover highlight
				if ((pinMode || dragMode) && (e.movementX || e.movementY)) {
					pinHoverChainIndex = null;
					pinHoverDotIndex = null;
					let bestDist = Infinity;
					const hoverRad = 20;
					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const d = Math.hypot(x - ch[i].x, y - ch[i].y);
							if (d < hoverRad && d < bestDist) {
								bestDist = d;
								pinHoverChainIndex = c;
								pinHoverDotIndex = i;
							}
						}
					}
				}
			}, { passive: false });

			function finalizePointer(e) {
				if (activePointerId !== null && e.pointerId !== activePointerId) return;

				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					if (currentCircle.radius > 5) {
						circles.push(currentCircle);
						history.push({ type: "circle" });
					}
					isCircleDrawing = false;
					currentCircle = null;
					draggingCircleIndex = null;
					circleInfo.style.display = "none";
				}

				if (isDrawing && currentPathPoints.length > 2 &&
					(drawMode === 'blob' || drawMode === 'line')) {
					let r = globalRadiusAvg + (Math.random() * 2 - 1) * globalRadiusVar;
					if (r < 1) r = 1;
					const chosenColor = hexToRGBA(colorInput.value);
					const isClosed = (drawMode === 'blob');
					if (isClosed) {
						const f = currentPathPoints[0];
						currentPathPoints.push({ ...f });
					}
					chains.push({
						chain: currentPathPoints.slice(),
						color: chosenColor,
						baseDotRadius: r,
						isClosed,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;


				if (longPressTimer) {
					clearTimeout(longPressTimer);
					longPressTimer = null;
				}
				waitingForLongPress = false; // <‚Äî NEW
				longPressTargetIndex = null;

				// If we *were* resizing, turn off highlight and exit resize mode
				if (resizingCircleIndex !== null) {
					circles[resizingCircleIndex].__resizing = false; // remove blue rim
					resizingCircleIndex = null;

					// Hide any radius HUD if you added it
					if (typeof circleInfo !== 'undefined' && circleInfo) {
						circleInfo.style.display = "none";
					}
				}
				try { canvas.releasePointerCapture(activePointerId); } catch {}
				activePointerId = null;
			}

			canvas.addEventListener("pointerup", finalizePointer, { passive: true });
			canvas.addEventListener("pointercancel", finalizePointer, { passive: true });
			canvas.addEventListener("lostpointercapture", () => {
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
				activePointerId = null;
			});

			/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Device/layout toggler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
			const rootWindow = document.querySelector(".window");
			const contentEl = document.querySelector(".content");
			const toolbarEl = document.querySelector(".toolbar");
			const bottomEl = document.querySelector(".bottom-panel");

			/* robust iPad detection (covers iPadOS reporting as Mac) */
			function isIPad() {
				const ua = navigator.userAgent || "";
				const platform = navigator.platform || "";
				const touch = navigator.maxTouchPoints || 0;
				return /iPad/.test(ua) || (platform === "MacIntel" && touch > 1);
			}

			/* move toolbar below the canvas for iPad; put it back for desktop */
			let toolbarHomeParent = toolbarEl.parentElement; // remember original parent
			let toolbarHomeNext = toolbarEl.nextSibling; // remember original position

			function adoptIPadDOM() {
				if (toolbarEl.parentElement !== rootWindow) {
					rootWindow.insertBefore(toolbarEl, bottomEl); // place as row 3
				}
			}

			function restoreDesktopDOM() {
				if (toolbarHomeNext && toolbarHomeNext.parentNode === toolbarHomeParent) {
					toolbarHomeParent.insertBefore(toolbarEl, toolbarHomeNext);
				} else {
					toolbarHomeParent.appendChild(toolbarEl);
				}
			}

			/* square canvas that fits the middle row (cap at 1000) */
			function fitCanvasForIPad() {

				const size = 700; //Math.min(1000, Math.floor(Math.min(availW, availH) * CANVAS_SCALE));

				canvas.style.width = size + "px";
				canvas.style.height = size + "px";
				canvas.width = size;
				canvas.height = size;
				if (gl) gl.viewport(0, 0, size, size);
			}

			/* master switch */
			function applyResponsiveLayout() {
				if (isIPad()) {
					rootWindow.classList.add("ipad");
					adoptIPadDOM();
					document.documentElement.style.overflow = "hidden";
					document.body.style.overflow = "hidden";
					fitCanvasForIPad();
				} else {
					rootWindow.classList.remove("ipad");
					restoreDesktopDOM();
					document.documentElement.style.overflow = "";
					document.body.style.overflow = "";
				}
			}

			applyResponsiveLayout();
			$("splashOverlay").style.display = "flex"; // ‚Üê show splash on load
			window.addEventListener("resize", applyResponsiveLayout);
			window.addEventListener("orientationchange", applyResponsiveLayout);

			/* -----------------------------------
			   GLOBALS & DATA
			----------------------------------- */

			/* 1. Canvas draw-mode */
			let drawMode = 'blob'; // 'blob' | 'line' | 'circle'

			/* 2. Geometry collections */
			const chains = []; // { chain:[‚Ä¶], color, baseDotRadius, isClosed, frozen }
			const circles = []; // { x, y, radius }
			let history = []; // undo stack

			/* 3. Live drawing state */
			let isDrawing = false;
			let isCircleDrawing = false;
			let currentCircle = null;
			let draggingCircleIndex = null;
			// ‚îÄ‚îÄ Circle long-press/resize state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
			let resizeHoldMs = 1000; // 5 seconds to enter resize mode
			let longPressTimer = null; // pending timer id
			let longPressStartX = 0,
				longPressStartY = 0;
			let longPressTargetIndex = null; // which circle we‚Äôre aiming to resize
			let resizingCircleIndex = null; // active circle being resized
			const LONG_PRESS_MOVE_CANCEL = 6; // px tolerance before we cancel press
			// While we‚Äôre waiting to see if this becomes a long-press
			let waitingForLongPress = false;
			/* 4. Active edit-tool flags (mutually exclusive) */
			let slicingMode = false,
				dragMode = false,
				pinMode = false,
				freezeMode = false,
				deleteMode = false;

			/* 5. Drag / hover helpers */
			let draggingChainIndex = null,
				draggingDotIndex = null;
			let pinHoverChainIndex = null,
				pinHoverDotIndex = null;

			/* 6. Render options */
			let solidFillMode = true; // false = outline, true = filled

			/* 7. Physics parameters (defaults) */
			let springConstant = 0.3, // ~30 %
				repulsionConstant = 0.1, // ~10 %
				damping = 0.85, // ~85 %
				timeStep = 1.05, // slider 47 % ‚Üí 0.1‚Äí2
				dotScaleFactor = 2.0, // slider 39 % ‚Üí 0.1‚Äí5
				currentLineThickness = 1;
			applyThicknessUI(); // sync UI immediately
			toggleActiveIcon($("iconFill"), solidFillMode); // add this line
			$("iconFill").title = "Solid Fill On"; // correct tooltip

			let prevDamping = damping; // remembers last non-zero value

			/* 8. Global shape settings */
			let globalRadiusAvg = 4,
				globalRadiusVar = 0;

			/* 9. UI element references */
			const colorInput = $("blobColor");
			const DOT_SCROLL_STEP = 0.01; // lower = finer control
			const DOT_MIN_PERCENT = 0;
			const DOT_MAX_PERCENT = 100;
			/* -----------------------------------b
			   ICON "ON" LABEL HELPER
			----------------------------------- */
			function toggleActiveIcon(iconEl, isActive) {
				iconEl.classList.toggle("icon-active", isActive);
			}

			// A helper to apply the ‚Äúactive‚Äù styling to edit-tool icons
			function setIconActive(iconEl, isActive, activeTitle, inactiveTitle) {
				iconEl.title = isActive ? activeTitle : inactiveTitle;
				iconEl.style.backgroundColor = isActive ? "#D3D3D3" : "";
				iconEl.style.fontWeight = isActive ? "bold" : "normal";
				iconEl.classList.toggle("icon-active", isActive);
			}

			// Ensure only one edit tool is active at a time
			function setEditTool(toolName) {
				// If the requested tool is already active, we‚Äôll toggle it off
				const isAlreadyActive =
					(toolName === "slice" && slicingMode) ||
					(toolName === "drag" && dragMode) ||
					(toolName === "pin" && pinMode) ||
					(toolName === "freeze" && freezeMode) ||
					(toolName === "delete" && deleteMode);

				// First, turn everything off:
				slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;

				// If the requested tool wasn‚Äôt already active, we turn it on:
				if (!isAlreadyActive) {
					if (toolName === "slice") slicingMode = true;
					if (toolName === "drag") dragMode = true;
					if (toolName === "pin") pinMode = true;
					if (toolName === "freeze") freezeMode = true;
					if (toolName === "delete") deleteMode = true;
				}

				const editFrame = $("editToolsSection");
				const anyEditOn = slicingMode || dragMode || pinMode || freezeMode || deleteMode;
				editFrame.classList.toggle("edit-on", anyEditOn);
				// Update icon states accordingly:
				setIconActive($("iconSlice"), slicingMode,
					"Slicing Mode (On)", "Slicing Mode (Off)");
				setIconActive($("iconDrag"), dragMode,
					"Disable Drag Mode", "Enable Drag Mode");
				setIconActive($("iconPin"), pinMode,
					"Disable Pin Mode", "Enable Pin Mode");
				setIconActive($("iconFreeze"), freezeMode,
					"Disable Freeze Mode", "Enable Freeze Mode");
				setIconActive($("iconDelete"), deleteMode,
					"Disable Delete Mode", "Enable Delete Mode");
				// Update the canvas cursor
				updateCanvasCursor();

				const msg = isAlreadyActive ? "Edit tools off" :
					`Edit mode: ${toolName.toUpperCase()}`;
				toast(msg, 1800);
			}

			/* -----------------------------------
			   DRAW MODE: BLOB / LINE / CIRCLE
			----------------------------------- */
			function setDrawMode(mode) {
				toggleActiveIcon($("iconBlob"), false);
				toggleActiveIcon($("iconLine"), false);
				toggleActiveIcon($("iconCircle"), false);

				drawMode = mode;

				toast(`Draw mode: ${mode.toUpperCase()}`, 1800);

				if (mode === 'blob') {
					toggleActiveIcon($("iconBlob"), true);
				} else if (mode === 'line') {
					toggleActiveIcon($("iconLine"), true);
				} else if (mode === 'circle') {
					toggleActiveIcon($("iconCircle"), true);
				}
				updateCanvasCursor();
			}
			// Initialize default draw mode
			setDrawMode('blob');

			/* -----------------------------------
			   EDIT TOOL ICONS (now calling setEditTool)
			----------------------------------- */
			$("iconSlice").onclick = function() {
				setEditTool("slice");
			};
			$("iconDrag").onclick = function() {
				setEditTool("drag");
			};
			$("iconPin").onclick = function() {
				setEditTool("pin");
			};
			$("iconFreeze").onclick = function() {
				setEditTool("freeze");
			};
			$("iconDelete").onclick = function() {
				setEditTool("delete");
			};

			$("iconFill").onclick = () => {
				solidFillMode = !solidFillMode;
				$("iconFill").title = solidFillMode ? "Solid Fill On" : "Solid Fill Off";
				toggleActiveIcon($("iconFill"), solidFillMode);
				toast(solidFillMode ? "Fill: ON" : "Fill: OFF", 1600);
			};
			/* -----------------------------------
			   THICKNESS & UNDO & RESET
			----------------------------------- */

			function applyThicknessUI() {
				const btn = $("iconThickness");
				toggleActiveIcon(btn, currentLineThickness > 1);
			}

			$("iconThickness").onclick = () => {
				currentLineThickness = (currentLineThickness === 1) ? 5 : 1;
				applyThicknessUI();
				toast(currentLineThickness === 1 ? "Stroke: Thin" : "Stroke: Thick", 1600);
			};

			$("iconUndo").onclick = () => {
				if (history.length > 0) {
					const last = history.pop();
					if (last.type === "chain") chains.pop();
					if (last.type === "circle") circles.pop();
				}
				toast("Undo", 1200);
			};

			$("resetIcon").onclick = () => {
				if (confirm("Are you sure you want to clear the entire canvas?")) {
					chains.length = 0;
					circles.length = 0;
					history.length = 0;
				}
				toast("Canvas cleared", 1600);
			};

			let interRepelMult = 1; // 1 = normal, 3 = boosted

			$("iconDiffusion").onclick = () => {
				interRepelMult = interRepelMult === 1 ? 3 : 1;
				toggleActiveIcon($("iconDiffusion"), interRepelMult === 3);
				toast(interRepelMult === 3 ? "High Repel: ON" : "High Repel: OFF", 1600);
			};

			/* -----------------------------------
			   DRAW MODE ICONS
			----------------------------------- */
			$("iconBlob").onclick = () => setDrawMode('blob');
			$("iconLine").onclick = () => {
				if (drawMode === "line") {
					setDrawMode("blob");
				} else {
					setDrawMode("line");
				}
			};
			$("iconCircle").onclick = () => {
				if (drawMode === "circle") {
					setDrawMode("blob");
				} else {
					setDrawMode("circle");
				}
			};

			/* -----------------------------------
			   UPDATE CANVAS CURSOR
			----------------------------------- */
			function updateCanvasCursor() {
				canvas.classList.remove(
					"canvas-blob-mode",
					"canvas-line-mode",
					"canvas-circle-mode",
					"canvas-drag-mode",
					"canvas-pin-mode",
					"canvas-slicing-mode",
					"canvas-freeze-mode",
					"canvas-delete-mode"
				);
				// Draw mode
				if (drawMode === 'blob') canvas.classList.add("canvas-blob-mode");
				if (drawMode === 'line') canvas.classList.add("canvas-line-mode");
				if (drawMode === 'circle') canvas.classList.add("canvas-circle-mode");

				// Edit tools
				if (slicingMode) canvas.classList.add("canvas-slicing-mode");
				if (dragMode) canvas.classList.add("canvas-drag-mode");
				if (pinMode) canvas.classList.add("canvas-pin-mode");
				if (freezeMode) canvas.classList.add("canvas-freeze-mode");
				if (deleteMode) canvas.classList.add("canvas-delete-mode");
			}

			/* -----------------------------------
			   FILE MENU LOGIC (SAVE/LOAD)
			----------------------------------- */
			function getCurrentSettings() {
				return {
					timeStep,
					springConstant,
					repulsionConstant,
					damping,
					dotScaleFactor,
					currentLineThickness,
					globalRadiusAvg,
					globalRadiusVar,
					colorValue: colorInput.value
				};
			}

			function applySettings(obj) {
				if (typeof obj.timeStep === "number") {
					timeStep = obj.timeStep;
					$("timeStepSlider").value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
					$("timeStepValue").textContent = $("timeStepSlider").value + "%";
				}
				if (typeof obj.springConstant === "number") {
					springConstant = obj.springConstant;
					$("springConstantSlider").value = springConstant * 100;
					$("springConstantValue").textContent = $("springConstantSlider").value + "%";
				}
				if (typeof obj.repulsionConstant === "number") {
					repulsionConstant = obj.repulsionConstant;
					$("repulsionConstantSlider").value = repulsionConstant * 100;
					$("repulsionConstantValue").textContent = $("repulsionConstantSlider").value + "%";
				}
				if (typeof obj.damping === "number") {
					damping = obj.damping;
					$("dampingSlider").value = damping * 100;
					$("dampingValue").textContent = $("dampingSlider").value + "%";
				}
				if (typeof obj.dotScaleFactor === "number") {
					dotScaleFactor = obj.dotScaleFactor;
					$("dotScaleSlider").value = ((dotScaleFactor - 0.1) / (5 - 0.1)) * 100;
					$("dotScaleValue").textContent = $("dotScaleSlider").value + "%";
				}
				if (typeof obj.currentLineThickness === "number") {
					currentLineThickness = obj.currentLineThickness;
					$("iconThickness").title = (currentLineThickness === 1) ?
						"Line Thickness: Thin" :
						"Line Thickness: Thick";
					$("iconThickness").style.fontWeight = (currentLineThickness === 5) ? "bold" : "normal";
					$("iconThickness").style.backgroundColor = (currentLineThickness === 5) ? "#D3D3D3" : "";
					toggleActiveIcon($("iconThickness"), currentLineThickness > 1);
				}
				if (typeof obj.globalRadiusAvg === "number") {
					globalRadiusAvg = obj.globalRadiusAvg;
					$("radiusAvgInput").value = obj.globalRadiusAvg;
				}
				if (typeof obj.globalRadiusVar === "number") {
					globalRadiusVar = obj.globalRadiusVar;
					$("radiusVarInput").value = obj.globalRadiusVar;
				}
				if (typeof obj.colorValue === "string") {
					colorInput.value = obj.colorValue;
				}
			}

			function downloadJSON(filename, dataObj) {
				const dataStr = JSON.stringify(dataObj, null, 2);
				const blob = new Blob([dataStr], { type: "application/json" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = filename;
				link.click();
				URL.revokeObjectURL(url);
			}

			/* ---------- SAVE ---------- */
			$("saveBlobsOption").onclick = e => {
				e.stopPropagation();
				$("fileSubmenu").style.display = "none";
				$("saveOptionsBackdrop").style.display = "flex";
			};
			$("cancelSaveBtn").onclick = () =>
				$("saveOptionsBackdrop").style.display = "none";

			$("confirmSaveBtn").onclick = () => {
				const payload = {};
				if ($("saveIncludeChains").checked) payload.chains = chains;
				if ($("saveIncludeCircles").checked) payload.circles = circles;
				if ($("saveIncludeSettings").checked) payload.settings = getCurrentSettings();
				downloadJSON("blobs.json", payload);
				$("saveOptionsBackdrop").style.display = "none";
			};

			/* ---------- IMPORT (file ‚ûú dialog) ---------- */
			let pendingImport = null; // temp storage

			$("loadBlobsOption").onclick = e => {
				e.stopPropagation();
				$("fileSubmenu").style.display = "none";





				const fi = document.createElement("input");
				fi.type = "file";
				fi.accept = ".json,application/json"; // broader accept

				fi.style.display = "none";
				document.body.appendChild(fi);

				fi.onchange = ev => {
					const file = ev.target.files && ev.target.files[0];
					if (!file) { fi.remove(); return; }

					const reader = new FileReader();
					reader.onload = evt => {
						try {
							pendingImport = JSON.parse(evt.target.result);
							$("importIncludeChains").disabled = !pendingImport.chains;
							$("importIncludeCircles").disabled = !pendingImport.circles;
							$("importIncludeSettings").disabled = !pendingImport.settings;
							$("importIncludeChains").checked = !!pendingImport.chains;
							$("importIncludeCircles").checked = !!pendingImport.circles;
							$("importIncludeSettings").checked = !!pendingImport.settings;
							$("importOptionsBackdrop").style.display = "flex";
							$("importOptionsBackdrop").style.pointerEvents = "auto";
						} catch {
							alert("Error parsing JSON file!");
						} finally {
							fi.remove(); // clean up
						}
					};
					reader.readAsText(file);
				};

				fi.value = ""; // lets you import the same file twice
				fi.click();
			};

			/* user clicks Import / Cancel */
			$("confirmImportBtn").onclick = () => {
				if (!pendingImport) return;

				// Close NOW so iPad can paint the hide
				const b = $("importOptionsBackdrop");
				if (b) {
					b.style.display = "none";
					b.style.pointerEvents = "none"; // prevents any ‚Äúghost‚Äù hitbox
					void document.body.offsetHeight; // iOS paint nudge
				}

				// Defer heavy import/physics so the hide actually commits
				setTimeout(() => {
					try {
						if ($("importIncludeChains")?.checked && pendingImport.chains)
							pendingImport.chains.forEach(c => chains.push(c));

						if ($("importIncludeCircles")?.checked && pendingImport.circles)
							pendingImport.circles.forEach(c => circles.push(c));

						if ($("importIncludeSettings")?.checked && pendingImport.settings) {
							try { applySettings(pendingImport.settings); } catch (e) { console.warn(e); }
						}

						if ($("importIncludePhysics")?.checked) {
							applyImportedPhysics?.(pendingImport) ?? startPhysicsFromImport?.(pendingImport);
						}
					} finally {
						pendingImport = null;
					}
				}, 0);
			};
			$("cancelImportBtn").onclick = () => {
				pendingImport = null;
				$("importOptionsBackdrop").style.display = "none";
			};



			/* -----------------------------------
			   MOUSE EVENTS & DRAWING
			----------------------------------- */
			let currentPathPoints = [];
			let currentMouseX = 0,
				currentMouseY = 0;

			const dotSlider = $("dotScaleSlider");

			/* Wheel on canvas */
			canvas.addEventListener("wheel", handleDotWheel, { passive: false });
			/* Wheel directly on the slider (nice for trackpads) */
			dotSlider.addEventListener("wheel", handleDotWheel, { passive: false });

			function handleDotWheel(e) {
				e.preventDefault(); // stop page scroll
				const delta = e.deltaY; // +120, ‚àí120, etc.
				const current = parseFloat(dotSlider.value);
				const next = current - delta * DOT_SCROLL_STEP;
				setDotScale(next);
			}

			canvas.addEventListener("mousemove", e => {
				const rect = canvas.getBoundingClientRect();
				currentMouseX = e.clientX - rect.left;
				currentMouseY = e.clientY - rect.top;

				// If drawing a blob or line
				if (isDrawing && (drawMode === 'blob' || drawMode === 'line')) {
					const last = currentPathPoints[currentPathPoints.length - 1];
					const dx = currentMouseX - last.x,
						dy = currentMouseY - last.y;
					if (Math.sqrt(dx * dx + dy * dy) > 1.5) {
						currentPathPoints.push({
							x: currentMouseX,
							y: currentMouseY,
							vx: 0,
							vy: 0,
							pinned: false
						});
					}
				}

				// If resizing a new circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					const r = Math.sqrt(
						(currentMouseX - currentCircle.x) ** 2 +
						(currentMouseY - currentCircle.y) ** 2
					);
					currentCircle.radius = r;

					circleInfo.textContent = "r: " + Math.round(r);
					circleInfo.style.left = (e.clientX + 14) + "px";
					circleInfo.style.top = (e.clientY + 18) + "px";
					circleInfo.style.display = "block";
				} else {
					circleInfo.style.display = "none";
				}

				// If dragging an existing circle
				if (drawMode === 'circle' && dragMode && draggingCircleIndex !== null) {
					circles[draggingCircleIndex].x = currentMouseX;
					circles[draggingCircleIndex].y = currentMouseY;
				}

				// Highlight nearest dot if pinMode/dragMode
				if ((pinMode || dragMode) && (e.movementX || e.movementY)) {
					pinHoverChainIndex = null;
					pinHoverDotIndex = null;

					let bestDist = Infinity;
					const hoverRad = 20; // hover radius in px

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = currentMouseX - dot.x;
							const dy = currentMouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < hoverRad && dist < bestDist) {
								bestDist = dist;
								pinHoverChainIndex = c;
								pinHoverDotIndex = i;
							}
						}
					}
				}

			});

			function polygonArea(points) {
				let sum = 0;
				for (let i = 0; i < points.length; i++) {
					const j = (i + 1) % points.length;
					sum += points[i].x * points[j].y -
						points[j].x * points[i].y;
				}
				return Math.abs(sum) / 2;
			}
			/**
			 * Ray-casting test for point-in-polygon
			 */
			function pointInPolygon(px, py, polygon) {
				let inside = false;
				for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
					const xi = polygon[i].x,
						yi = polygon[i].y;
					const xj = polygon[j].x,
						yj = polygon[j].y;
					const intersect = ((yi > py) !== (yj > py)) &&
						(px < (xj - xi) * (py - yi) / (yj - yi) + xi);
					if (intersect) inside = !inside;
				}
				return inside;
			}

			canvas.addEventListener("mousedown", e => {
				if (e.button !== 0) return;
				const rect = canvas.getBoundingClientRect();
				const mouseX = e.clientX - rect.left;
				const mouseY = e.clientY - rect.top;

				if (dragMode && drawMode !== "circle") {
					for (let i = 0; i < circles.length; i++) {
						const c = circles[i],
							dx = mouseX - c.x,
							dy = mouseY - c.y;
						if (Math.hypot(dx, dy) < c.radius + 5) { // inside any circle?
							toast("Hint: turn Circle draw mode ON to move circles.",
								3000);
							break;
						}
					}
				}

				// Circle creation or circle dragging
				if (drawMode === 'circle') {
					if (dragMode) {
						// If we're in dragMode AND circle draw mode, we only do circle dragging:
						// (Try to pick up an existing circle but do NOT create a new one)
						for (let i = 0; i < circles.length; i++) {
							const c = circles[i];
							const dx = mouseX - c.x;
							const dy = mouseY - c.y;
							if (Math.sqrt(dx * dx + dy * dy) < c.radius + 5) {
								draggingCircleIndex = i;
								return;
							}
						}

						// If we didn‚Äôt find a circle to drag, just return without creating one:
						return;

					} else {
						// Otherwise (dragMode is OFF), start a new circle
						isCircleDrawing = true;
						currentCircle = { x: mouseX, y: mouseY, radius: 0 };
						return;
					}
				}

				// Slicing mode
				if (slicingMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const sliceRadius = 15;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = mouseX - dot.x;
							const dy = mouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < sliceRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const ch = chains[bestChainIndex].chain;
						if (bestDotIndex > 0 && bestDotIndex < ch.length - 1) {
							const firstHalf = ch.slice(0, bestDotIndex);
							const secondHalf = ch.slice(bestDotIndex);
							chains[bestChainIndex].chain = firstHalf;
							chains.push({
								...chains[bestChainIndex],
								chain: secondHalf
							});
							history.push({ type: "chain" });
						}
					}
					return;
				}

				// Freeze mode
				if (freezeMode) {
					// 1) find all blobs under the mouse
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						const ch = chains[i];
						if (!ch.isClosed) continue;
						if (pointInPolygon(mouseX, mouseY, ch.chain)) {
							hits.push(i);
						}
					}

					if (hits.length) {
						// 2) pick the smallest one
						let bestIndex = hits[0];
						let bestArea = polygonArea(chains[bestIndex].chain);

						for (let k = 1; k < hits.length; k++) {
							const idx = hits[k];
							const area = polygonArea(chains[idx].chain);
							if (area < bestArea) {
								bestArea = area;
								bestIndex = idx;
							}
						}

						// 3) toggle only that blob
						chains[bestIndex].frozen = !chains[bestIndex].frozen;
						chains[bestIndex].alpha = chains[bestIndex].frozen ? 0.3 : 1.0;
					}
					return;
				}
				// ----- DELETE MODE: remove the smallest blob under cursor -----
				if (deleteMode) {

					/* a) test circles first */
					for (let i = 0; i < circles.length; i++) {
						const c = circles[i],
							dx = mouseX - c.x,
							dy = mouseY - c.y;
						if (Math.hypot(dx, dy) < c.radius) {
							circles.splice(i, 1);
							history.push({ type: "circle" });
							return;
						}
					}

					/* b) test open lines: nearest segment within 6‚ÄØpx */
					const SEG_TOL = 6;
					for (let k = 0; k < chains.length; k++) {
						const obj = chains[k];
						if (obj.isClosed) continue; // skip blobs (do later)
						const pts = obj.chain;
						for (let i = 0; i < pts.length - 1; i++) {
							const a = pts[i],
								b = pts[i + 1];
							const t = ((mouseX - a.x) * (b.x - a.x) + (mouseY - a.y) * (b.y - a.y)) /
								((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
							const clamped = Math.max(0, Math.min(1, t));
							const px = a.x + clamped * (b.x - a.x);
							const py = a.y + clamped * (b.y - a.y);
							if (Math.hypot(mouseX - px, mouseY - py) < SEG_TOL) {
								chains.splice(k, 1);
								history.push({ type: "chain" });
								return;
							}
						}
					}

					/* c) fall back to old ‚Äúblob‚Äù logic (smallest closed shape) */
					const hits = [];
					for (let i = 0; i < chains.length; i++) {
						if (!chains[i].isClosed) continue;
						if (pointInPolygon(mouseX, mouseY, chains[i].chain)) hits.push(i);
					}
					if (hits.length) {
						let best = hits[0],
							bestArea = polygonArea(chains[best].chain);
						for (let j = 1; j < hits.length; j++) {
							const area = polygonArea(chains[hits[j]].chain);
							if (area < bestArea) {
								best = hits[j];
								bestArea = area;
							}
						}
						chains.splice(best, 1);
						history.push({ type: "chain" });
					}
					return;
				}
				// Pin mode
				if (pinMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = mouseX - dot.x;
							const dy = mouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < pickRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						const dot = chains[bestChainIndex].chain[bestDotIndex];
						dot.pinned = !dot.pinned;
						return;
					}
					return;
				}

				// Drag mode
				if (dragMode) {
					let bestChainIndex = null;
					let bestDotIndex = null;
					let bestDist = Infinity;
					const pickRadius = 20;

					for (let c = 0; c < chains.length; c++) {
						const ch = chains[c].chain;
						for (let i = 0; i < ch.length; i++) {
							const dot = ch[i];
							const dx = mouseX - dot.x;
							const dy = mouseY - dot.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							if (dist < pickRadius && dist < bestDist) {
								bestDist = dist;
								bestChainIndex = c;
								bestDotIndex = i;
							}
						}
					}
					if (bestChainIndex !== null) {
						draggingChainIndex = bestChainIndex;
						draggingDotIndex = bestDotIndex;
						return;
					}
				}

				// Otherwise, if in blob or line mode, start freehand
				if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
					isDrawing = true;
					currentPathPoints = [{
						x: mouseX,
						y: mouseY,
						vx: 0,
						vy: 0,
						pinned: false
					}];
				}
			});

			window.addEventListener("mouseup", e => {
				if (e.button !== 0) return;

				// Finalize circle
				if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
					if (currentCircle.radius > 5) {
						circles.push(currentCircle);
						history.push({ type: "circle" });
					}
					isCircleDrawing = false;
					currentCircle = null;
					draggingCircleIndex = null;

					circleInfo.style.display = "none"; // ‚Üê hide the live radius overlay
					return;
				}

				// Finalize blob/line
				if (isDrawing && currentPathPoints.length > 2 && (drawMode === 'blob' || drawMode === 'line')) {
					let r = globalRadiusAvg + (Math.random() * 2 - 1) * globalRadiusVar;
					if (r < 1) r = 1;
					const chosenColor = hexToRGBA(colorInput.value);

					const isClosed = (drawMode === 'blob');
					if (isClosed) {
						// close shape
						const f = currentPathPoints[0];
						currentPathPoints.push({ ...f });
					}

					chains.push({
						chain: currentPathPoints.slice(),
						color: chosenColor,
						baseDotRadius: r,
						isClosed,
						frozen: false
					});
					history.push({ type: "chain" });
				}

				// End all "mouseDown" states
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
			});

			window.addEventListener("mouseleave", () => {
				isDrawing = false;
				draggingChainIndex = null;
				draggingDotIndex = null;
				draggingCircleIndex = null;
			});

			/* -----------------------------------
			   SHADERS & PROGRAM
			----------------------------------- */
			function compileShader(type, src) {
				const s = gl.createShader(type);
				gl.shaderSource(s, src);
				gl.compileShader(s);
				if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
					console.error("Shader compile error:", gl.getShaderInfoLog(s));
					gl.deleteShader(s);
					return null;
				}
				return s;
			}

			function createProgram(vsSrc, fsSrc) {
				const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
				const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
				const p = gl.createProgram();
				gl.attachShader(p, vs);
				gl.attachShader(p, fs);
				gl.linkProgram(p);
				if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
					console.error("Program link error:", gl.getProgramInfoLog(p));
					return null;
				}
				return p;
			}
			const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    void main(){
      vec2 clipSpace = (a_position / u_resolution)*2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace,0,1);
    }
  `;
			const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main(){
      gl_FragColor = u_color;
    }
  `;
			const lineProgram = createProgram(vsSource, fsSource);
			const linePosLoc = gl.getAttribLocation(lineProgram, "a_position");
			const lineResLoc = gl.getUniformLocation(lineProgram, "u_resolution");
			const lineColorLoc = gl.getUniformLocation(lineProgram, "u_color");
			const positionBuffer = gl.createBuffer();
			let thickScratch = new Float32Array(0);
			/* -----------------------------------
			   CATMULL‚ÄìROM SPLINE HELPERS
			----------------------------------- */
			function getClosedSmoothCurve(points, seg = 10) {
				const n = points.length;
				if (n < 2) return new Float32Array([]);
				let out = [];
				for (let i = 0; i < n; i++) {
					const p0 = points[(i - 1 + n) % n],
						p1 = points[i],
						p2 = points[(i + 1) % n],
						p3 = points[(i + 2) % n];
					for (let s = 0; s < seg; s++) {
						const t = s / seg,
							t2 = t * t,
							t3 = t2 * t;
						const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
						const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
						out.push(x, y);
					}
				}
				out.push(points[0].x, points[0].y);
				return new Float32Array(out);
			}

			function getOpenSmoothCurve(points, seg = 10) {
				const n = points.length;
				if (n < 2) return new Float32Array([]);
				let out = [];
				for (let i = 0; i < n - 1; i++) {
					const p0 = (i === 0 ? points[0] : points[i - 1]),
						p1 = points[i],
						p2 = points[i + 1],
						p3 = (i === n - 2 ? points[n - 1] : points[i + 2]);
					for (let s = 0; s < seg; s++) {
						const t = s / seg,
							t2 = t * t,
							t3 = t2 * t;
						const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
						const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
						out.push(x, y);
					}
				}
				out.push(points[n - 1].x, points[n - 1].y);
				return new Float32Array(out);
			}

			function buildStencilTris(flat, outX, outY) {
				// flat = [x0,y0,x1,y1, ... ,xn,yn]  (closed, last!=first)
				const segs = flat.length / 2;
				const arr = new Float32Array(segs * 3 * 2); // 3 verts √ó 2 coords
				let p = 0;
				for (let i = 0; i < segs; i++) {
					const i2 = (i + 1) % segs;
					arr[p++] = flat[i * 2];
					arr[p++] = flat[i * 2 + 1];
					arr[p++] = flat[i2 * 2];
					arr[p++] = flat[i2 * 2 + 1];
					arr[p++] = outX;
					arr[p++] = outY; // far point
				}
				return arr;
			}

			function getThickLineVertices(splinePts, thickness) {
				const n = splinePts.length >> 1; // points count
				const needed = n * 4; // 2 verts per point
				if (thickScratch.length < needed) thickScratch = new Float32Array(needed);

				const half = thickness * 0.5;
				for (let i = 0; i < n; i++) {
					const currX = splinePts[i * 2],
						currY = splinePts[i * 2 + 1];
					const prevX = splinePts[((i - 1 + n) % n) * 2],
						prevY = splinePts[((i - 1 + n) % n) * 2 + 1];
					const nextX = splinePts[((i + 1) % n) * 2],
						nextY = splinePts[((i + 1) % n) * 2 + 1];

					// tangential = next - prev
					const tx = nextX - prevX,
						ty = nextY - prevY;
					const invLen = 1 / Math.hypot(tx, ty || 1); // avoid /0
					const nx = -ty * invLen,
						ny = tx * invLen; // normal

					const base = i * 4;
					thickScratch[base] = currX + nx * half;
					thickScratch[base + 1] = currY + ny * half;
					thickScratch[base + 2] = currX - nx * half;
					thickScratch[base + 3] = currY - ny * half;
				}
				return thickScratch.subarray(0, needed);
			}

			/* -----------------------------------
			   "DASHED" RENDER FOR FROZEN
			----------------------------------- */
			function drawDashedSpline(spline, color) {
				gl.useProgram(lineProgram);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.uniform4fv(lineColorLoc, color);
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

				const pts = spline;
				for (let i = 0; i < pts.length - 3; i += 4) {
					const sub = new Float32Array([
						pts[i], pts[i + 1],
						pts[i + 2], pts[i + 3]
					]);
					gl.bufferData(gl.ARRAY_BUFFER, sub, gl.DYNAMIC_DRAW);
					gl.enableVertexAttribArray(linePosLoc);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.drawArrays(gl.LINE_STRIP, 0, 2);
				}
			}

			/* -----------------------------------
			   PHYSICS
			----------------------------------- */
			function applySpring(chain, forces, i, j, restDist) {
				const a = chain[i],
					b = chain[j];
				let dx = b.x - a.x,
					dy = b.y - a.y,
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < 1e-4) dist = 1e-4;
				const f = springConstant * (dist - restDist),
					nx = dx / dist,
					ny = dy / dist;
				forces[i].x += f * nx;
				forces[i].y += f * ny;
				forces[j].x -= f * nx;
				forces[j].y -= f * ny;
			}

			function simulateChain(chainObj, cIndex) {
				if (chainObj.frozen) return; // skip frozen

				const arr = chainObj.chain;
				let forces = chainObj._forces;
				// (re‚Äëcreate if first time or if the point count changed)
				if (!forces || forces.length !== arr.length) {
					forces = chainObj._forces = Array.from({ length: arr.length },
						() => ({ x: 0, y: 0 }));
				}
				// zero the existing vectors instead of allocating new objects
				for (let i = 0; i < forces.length; i++) {
					forces[i].x = 0;
					forces[i].y = 0;
				}
				const dotR = chainObj.baseDotRadius * dotScaleFactor;
				const restDist = dotR * 0.7;

				// Springs
				if (chainObj.isClosed) {
					for (let i = 0; i < arr.length; i++) {
						const j = (i + 1) % arr.length;
						applySpring(arr, forces, i, j, restDist);
					}
				} else {
					for (let i = 0; i < arr.length - 1; i++) {
						applySpring(arr, forces, i, i + 1, restDist);
					}
				}

				// Self repulsion
				for (let i = 0; i < arr.length; i++) {
					for (let j = i + 1; j < arr.length; j++) {
						const a = arr[i],
							b = arr[j];
						const minD = dotR * 2,
							dx = b.x - a.x,
							dy = b.y - a.y,
							dist = Math.sqrt(dx * dx + dy * dy);
						if (dist > 0 && dist < minD) {
							const overlap = (minD - dist),
								nx = dx / dist,
								ny = dy / dist;
							const f = repulsionConstant * overlap;
							forces[i].x -= f * nx;
							forces[i].y -= f * ny;
							forces[j].x += f * nx;
							forces[j].y += f * ny;
						}
					}
				}

				// Boundary push-back
				for (let i = 0; i < arr.length; i++) {
					const a = arr[i];
					if (a.x < dotR) forces[i].x += (dotR - a.x) * 0.5;
					else if (a.x > canvas.width - dotR) forces[i].x -= (a.x - (canvas.width - dotR)) * 0.5;

					if (a.y < dotR) forces[i].y += (dotR - a.y) * 0.5;
					else if (a.y > canvas.height - dotR) forces[i].y -= (a.y - (canvas.height - dotR)) * 0.5;
				}

				// If this chain is currently being dragged
				if (dragMode && cIndex === draggingChainIndex && draggingDotIndex !== null) {
					const dot = arr[draggingDotIndex],
						dx = currentMouseX - dot.x,
						dy = currentMouseY - dot.y,
						dist = Math.sqrt(dx * dx + dy * dy);
					if (dist > 1e-4) {
						const nx = dx / dist,
							ny = dy / dist,
							f = 0.2 * dist;
						forces[draggingDotIndex].x += f * nx;
						forces[draggingDotIndex].y += f * ny;
					}
				}

				// Integrate
				for (let i = 0; i < arr.length; i++) {
					const d = arr[i];
					const isDraggingThisDot = (dragMode && cIndex === draggingChainIndex && i === draggingDotIndex);
					if (d.pinned && !isDraggingThisDot) {
						d.vx = 0;
						d.vy = 0;
						continue;
					}
					d.vx = (d.vx + forces[i].x * timeStep) * damping;
					d.vy = (d.vy + forces[i].y * timeStep) * damping;
					d.x += d.vx * timeStep;
					d.y += d.vy * timeStep;
				}
			}

			function simulateInterChainRepulsion() {
				buildSpatialHash();

				for (let [key, points] of spatialHash) {
					const [cx, cy] = key.split(',').map(Number);

					for (let pt of points) {
						const A = chains[pt.c];
						if (A.frozen) continue;
						const dotA = pt.p;
						const rA = pt.r;

						// Check neighbor cells
						for (let [ox, oy] of neighborOffsets) {
							const nKey = hashKey(cx + ox, cy + oy);
							const neighborPoints = spatialHash.get(nKey);
							if (!neighborPoints) continue;

							for (let nPt of neighborPoints) {
								if (nPt.c === pt.c) continue; // skip same chain here
								const B = chains[nPt.c];
								if (B.frozen) continue;
								const dotB = nPt.p;
								const rB = nPt.r;
								const minD = rA + rB;

								const dx = dotB.x - dotA.x;
								const dy = dotB.y - dotA.y;
								const dist = Math.hypot(dx, dy);

								if (dist > 0 && dist < minD) {
									const overlap = (minD - dist);
									const nx = dx / dist;
									const ny = dy / dist;
									const f = repulsionConstant * interRepelMult * overlap;
									if (!dotA.pinned) {
										dotA.vx -= f * nx * timeStep;
										dotA.vy -= f * ny * timeStep;
									}
									if (!dotB.pinned) {
										dotB.vx += f * nx * timeStep;
										dotB.vy += f * ny * timeStep;
									}
								}
							}
						}
					}
				}
			}

			function simulateCircleRepulsion() {
				for (let c = 0; c < circles.length; c++) {
					const circle = circles[c];
					for (let ch = 0; ch < chains.length; ch++) {
						if (chains[ch].frozen) continue;
						const arr = chains[ch].chain;
						for (let i = 0; i < arr.length; i++) {
							const d = arr[i];
							const dx = d.x - circle.x,
								dy = d.y - circle.y,
								dist = Math.sqrt(dx * dx + dy * dy);
							const hardWall = (interRepelMult === 3); // button ON ‚Üí hard wall
							if (hardWall) { // ‚îÄ‚îÄ‚îÄ HARD mode ‚îÄ‚îÄ‚îÄ
								const dotR = chains[ch].baseDotRadius * dotScaleFactor;
								const minD = circle.radius + dotR;
								if (dist < minD) {
									const nx = dx / dist,
										ny = dy / dist;
									d.x = circle.x + nx * minD;
									d.y = circle.y + ny * minD;
									d.vx = d.vy = 0;
								}
							} else { // ‚îÄ‚îÄ‚îÄ SOFT mode ‚îÄ‚îÄ‚îÄ
								if (dist > 1e-4 && dist < circle.radius) {
									const f = repulsionConstant * (circle.radius - dist);
									if (!d.pinned) {
										d.vx += f * (dx / dist);
										d.vy += f * (dy / dist);
									}
								}
							}
						}
					}
				}
			}

			/* -----------------------------------
			   RENDERING
			----------------------------------- */
			function drawGrid(size = 20) {
				const w = canvas.width,
					h = canvas.height;
				let gridVerts = [];
				for (let x = 0; x <= w; x += size) {
					gridVerts.push(x, 0, x, h);
				}
				for (let y = 0; y <= h; y += size) {
					gridVerts.push(0, y, w, y);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVerts), gl.STATIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, w, h);
				gl.uniform4fv(lineColorLoc, [0.8, 0.8, 0.8, 1]);
				gl.drawArrays(gl.LINES, 0, gridVerts.length / 2);
			}

			function drawPinnedIndicator(x, y) {
				const seg = 12,
					rad = 4;
				let verts = [];
				for (let i = 0; i < seg; i++) {
					const t = i * (2 * Math.PI / seg);
					const cx = x + rad * Math.cos(t),
						cy = y + rad * Math.sin(t);
					verts.push(cx, cy);
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform4fv(lineColorLoc, [1.0, 0.0, 0.0, 1.0]); // red ring
				gl.drawArrays(gl.LINE_LOOP, 0, seg);
			}

			function drawHoverIndicator(dot, isPinned) {
				const seg = 12,
					radius = 8;
				let verts = [];
				for (let i = 0; i < seg; i++) {
					const t = i * (2 * Math.PI / seg);
					verts.push(dot.x + radius * Math.cos(t),
						dot.y + radius * Math.sin(t));
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				const color = isPinned ? [1.0, 0.2, 0.2, 1.0] : [0.00, 1.00, 0.50, 1];
				gl.uniform4fv(lineColorLoc, color);
				gl.drawArrays(gl.LINE_LOOP, 0, seg);
			}

			function drawChain(chainObj, chainIndex) {
				const ch = chainObj.chain;
				if (ch.length < 2) return;

				const spline = chainObj.isClosed ?
					getClosedSmoothCurve(ch, 10) :
					getOpenSmoothCurve(ch, 10);
				if (spline.length < 4) return;

				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.uniform4fv(lineColorLoc, chainObj.color);

				/* NEW ‚Äî solid-fill branch */
				if (solidFillMode && chainObj.isClosed) {
					gl.clear(gl.STENCIL_BUFFER_BIT);
					// 1) toggle stencil wherever an edge wedge passes
					gl.enable(gl.STENCIL_TEST);
					gl.colorMask(false, false, false, false);
					gl.stencilFunc(gl.ALWAYS, 0, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);

					const OUT_X = -9999,
						OUT_Y = -9999; // any point off-canvas
					const tris = buildStencilTris(spline, OUT_X, OUT_Y);

					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, tris, gl.DYNAMIC_DRAW);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.uniform4fv(lineColorLoc, chainObj.color); // colour doesn‚Äôt matter
					gl.drawArrays(gl.TRIANGLES, 0, tris.length / 2);

					const rgba = chainObj.color.slice(); // copy
					rgba[3] = chainObj.alpha ?? 1.0; // use 0.3 if frozen
					gl.uniform4fv(lineColorLoc, rgba);

					// 2) draw one big quad wherever stencil==1  (the filled blob)
					gl.colorMask(true, true, true, true);
					gl.stencilFunc(gl.EQUAL, 1, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

					const quad = new Float32Array([
						0, 0, canvas.width, 0, canvas.width, canvas.height,
						0, 0, canvas.width, canvas.height, 0, canvas.height
					]);
					gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
					gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
					gl.drawArrays(gl.TRIANGLES, 0, 6);

					gl.disable(gl.STENCIL_TEST);

					/* --- overlays drawn on top of the filled blob ----------------- */
					// pinned dots
					for (let i = 0; i < ch.length; i++) {
						if (ch[i].pinned) {
							gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
							drawPinnedIndicator(ch[i].x, ch[i].y);
						}
					}
					// hover ring in drag / pin mode
					if ((pinMode || dragMode) &&
						chainIndex === pinHoverChainIndex &&
						pinHoverDotIndex !== null) {
						const hoverDot = ch[pinHoverDotIndex];
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						drawHoverIndicator(hoverDot, hoverDot.pinned);
					}
					/* ---------------------------------------------------------------- */
					return; // done with this blob
					// done with this blob
				}

				/* --- existing outline code below --- */
				if (chainObj.frozen) {
					drawDashedSpline(spline, chainObj.color);
				} else {
					if (currentLineThickness === 1) {
						gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.LINE_STRIP, 0, spline.length / 2);
					} else {
						const thickVerts = getThickLineVertices(spline, currentLineThickness);
						gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
					}
				}

				if (chainObj.frozen) {
					// dashed style
					drawDashedSpline(spline, chainObj.color);
				} else {
					// normal stroke
					gl.uniform4fv(lineColorLoc, chainObj.color);
					if (currentLineThickness === 1) {
						gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.LINE_STRIP, 0, spline.length / 2);
					} else {
						const thickVerts = getThickLineVertices(spline, currentLineThickness);
						gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
						gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
					}
				}

				// pinned dots
				for (let i = 0; i < ch.length; i++) {
					if (ch[i].pinned) {
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						drawPinnedIndicator(ch[i].x, ch[i].y);
					}
				}

				// hover ring if this chain/dot is hovered in pinMode/dragMode
				if ((pinMode || dragMode) && chainIndex === pinHoverChainIndex && pinHoverDotIndex !== null) {
					const hoverDot = ch[pinHoverDotIndex];
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					drawHoverIndicator(hoverDot, hoverDot.pinned);
				}
			}

			function drawCircle(circle) {
				const seg = 32;
				let verts = [];
				for (let i = 0; i < seg; i++) {
					const t = i * (2 * Math.PI / seg);
					verts.push(
						circle.x + circle.radius * Math.cos(t),
						circle.y + circle.radius * Math.sin(t)
					);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				const rim = circle.__resizing ? [0.1, 0.6, 1.0, 1] : [0, 0, 0, 1];
				gl.uniform4fv(lineColorLoc, rim);
				gl.drawArrays(gl.LINE_LOOP, 0, seg);
			}

			function drawInProgressPath() {
				if (!isDrawing || currentPathPoints.length < 2) return;
				const arr = [];
				for (let i = 0; i < currentPathPoints.length; i++) {
					arr.push(currentPathPoints[i].x, currentPathPoints[i].y);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.DYNAMIC_DRAW);
				gl.useProgram(lineProgram);
				gl.enableVertexAttribArray(linePosLoc);
				gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
				gl.uniform2f(lineResLoc, canvas.width, canvas.height);
				gl.uniform4fv(lineColorLoc, hexToRGBA(colorInput.value));
				gl.drawArrays(gl.LINE_STRIP, 0, currentPathPoints.length);
			}

			function drawCurrentCircle() {
				if (!isCircleDrawing || !currentCircle) return;
				drawCircle(currentCircle);
			}

			/* -----------------------------------
			   ANIMATION LOOP
			----------------------------------- */
			function animate() {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
				// Physics
				chains.forEach((c, i) => simulateChain(c, i));
				simulateInterChainRepulsion();
				simulateCircleRepulsion();

				// Clear & draw
				gl.clearColor(1, 1, 1, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);

				drawGrid(20);

				chains.forEach((chainObj, chainIndex) => {
					drawChain(chainObj, chainIndex);
				});
				drawInProgressPath();
				circles.forEach(drawCircle);
				if (drawMode === 'circle') drawCurrentCircle();

				requestAnimationFrame(animate);
			}
			animate();


			/* ---------- guided tour engine ---------- */
			const tourSteps = [
				/* 0 ‚îÄ Title-bar */
				{
					el: "#splashOverlay + .title-bar",
					text: "Title bar: File (save/load), Export (SVG/JPG), About, Help."
				},

				/* 1 ‚îÄ Draw Tools */
				{
					el: ".toolbar-section:first-of-type",
					text: "Choose what you create on the canvas: Blobs, Lines, or Repulsion Circles. Select which one you'd like then click-drag on the canvas to draw."
				},

				/* 2 ‚îÄ Edit Tools */
				{
					el: "#editToolsSection",
					text: "Edit items on the canvas with these tools: Drag, Freeze, Pin, or Delete existing items. Only one edit mode can be active at a time."
				},

				/* 3 ‚îÄ Shape Settings */
				{
					el: ".toolbar-section:nth-of-type(3)",
					text: "Set colour, average blob size, and variation before each draw."
				},

				/* 4 ‚îÄ Canvas Tools */
				{
					el: ".toolbar-section:nth-of-type(4)",
					text: "The canvas tools toggle stroke thickness, solid fill, high repulsion mode, or undo the last action."
				},

				/* 5 ‚îÄ Main Canvas */
				{
					el: "#glCanvas",
					text: "Canvas: the main playground: draw, drag, and experiment here."
				},

				/* 6 ‚îÄ Physics Sliders */
				{
					el: ".bottom-panel",
					text: "Physics Sliders: fine-tune the blob behaviour. Hover the ‚ìò buttons to see what each slider does."
				}
			];

			let tourIndex = -1;

			function startTour() {
				if (tourIndex !== -1) return; // already running
				tourIndex = 0;
				$("tourOverlay").style.display = $("tourTip").style.display = "block";
				document.addEventListener("keydown", tourKey);
				showStep();
			}

			function endTour() {
				clearHighlight();
				$("tourOverlay").style.display = $("tourTip").style.display = "none";
				document.removeEventListener("keydown", tourKey);
				tourIndex = -1;
			}

			function showStep() {
				clearHighlight();
				const step = tourSteps[tourIndex];
				const el = document.querySelector(step.el);
				if (!el) { nextStep(); return; }
				el.classList.add("tour-highlight");
				$("tourText").textContent = step.text;
				positionTip(el);
				$("tourPrev").disabled = tourIndex === 0;
				$("tourNext").textContent = tourIndex === tourSteps.length - 1 ? "Done ‚úî" : "Next ‚ñ∂";
			}

			function positionTip(target) {
				const rect = target.getBoundingClientRect();
				const tip = $("tourTip");
				const left = rect.right + 12 < window.innerWidth - 330 ?
					rect.right + 12 : rect.left - 332;
				tip.style.left = (left < 8 ? 8 : left) + "px";
				tip.style.top = rect.top + "px";
			}

			function clearHighlight() {
				document.querySelectorAll(".tour-highlight").forEach(e => e.classList.remove("tour-highlight"));
			}

			function nextStep() {
				if (tourIndex < tourSteps.length - 1) {
					tourIndex++;
					showStep();
				} else endTour();
			}

			function prevStep() {
				if (tourIndex > 0) {
					tourIndex--;
					showStep();
				}
			}

			function tourKey(e) {
				if (e.key === "Escape") endTour();
				else if (e.key === "ArrowRight") nextStep();
				else if (e.key === "ArrowLeft") prevStep();
			}
			$("tourNext").onclick = nextStep;
			$("tourPrev").onclick = prevStep;
			$("tourExit").onclick = endTour;

			/* -----------------------------------
			   EXPORT HELPERS
			----------------------------------- */
			function exportSVG(isFilled) {
				const w = canvas.width,
					h = canvas.height;
				const parts = [`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" style="background:white;">`];
				chains.forEach(obj => {
					if (obj.chain.length < 2) return;
					const spline = obj.isClosed ? getClosedSmoothCurve(obj.chain, 10) :
						getOpenSmoothCurve(obj.chain, 10);
					if (spline.length < 4) return;
					const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
					let d = `M ${spline[0]} ${spline[1]}`;
					for (let i = 2; i < spline.length; i += 2) {
						d += ` L ${spline[i]} ${spline[i+1]}`;
					}
					if (obj.isClosed) d += " Z";

					if (isFilled) {
						parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" ${obj.isClosed?`fill="rgb(${rr},${gg},${bb})"`:'fill="none"'} stroke-width="${currentLineThickness}" stroke-linecap="round" stroke-linejoin="round" />`);
					} else {
						parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" fill="none" stroke-width="${currentLineThickness}" stroke-linecap="round" stroke-linejoin="round" />`);
					}
				});
				parts.push("</svg>");
				const blob = new Blob([parts.join("")], { type: "image/svg+xml" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = isFilled ? "blobs_filled.svg" : "blobs_stroked.svg";
				link.click();
				URL.revokeObjectURL(url);
			}

			function exportJPG(isFilled) {
				const size = 1500;
				const offscreen = document.createElement("canvas");
				offscreen.width = size;
				offscreen.height = size;
				const ctx = offscreen.getContext("2d");
				ctx.fillStyle = "#fff";
				ctx.fillRect(0, 0, size, size);
				const scale = size / canvas.width;

				chains.forEach(obj => {
					const ch = obj.chain;
					if (ch.length < 2) return;
					const spline = obj.isClosed ? getClosedSmoothCurve(ch, 10) :
						getOpenSmoothCurve(ch, 10);
					if (spline.length < 4) return;
					const [rr, gg, bb] = obj.color.map(c => Math.floor(c * 255));
					ctx.lineCap = "round";
					ctx.lineJoin = "round";
					ctx.beginPath();
					ctx.moveTo(spline[0] * scale, spline[1] * scale);
					for (let i = 2; i < spline.length; i += 2) {
						ctx.lineTo(spline[i] * scale, spline[i + 1] * scale);
					}
					if (obj.isClosed) ctx.closePath();
					if (isFilled && obj.isClosed) {
						ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
						ctx.fill();
					} else {
						ctx.strokeStyle = `rgb(${rr},${gg},${bb})`;
						ctx.lineWidth = currentLineThickness * scale;
						ctx.stroke();
					}
				});

				const url = offscreen.toDataURL("image/jpeg", 1.0);
				const link = document.createElement("a");
				link.href = url;
				link.download = isFilled ? "blobs_filled.jpg" : "blobs_stroked.jpg";
				link.click();
			}

			$("exportStrokedOption").onclick = e => {
				e.stopPropagation();
				exportSVG(false);
				$("exportSubmenu").style.display = "none";
			};
			$("exportFilledOption").onclick = e => {
				e.stopPropagation();
				exportSVG(true);
				$("exportSubmenu").style.display = "none";
			};
			$("exportStrokedJPGOption").onclick = e => {
				e.stopPropagation();
				exportJPG(false);
				$("exportSubmenu").style.display = "none";
			};
			$("exportFilledJPGOption").onclick = e => {
				e.stopPropagation();
				exportJPG(true);
				$("exportSubmenu").style.display = "none";
			};

			/* -----------------------------------
			   SLIDER SETUP
			----------------------------------- */

			// 1) Blob Scale slider (0..100 => 0.1..5)
			{
				const s = $("dotScaleSlider");
				const v = $("dotScaleValue");
				s.value = ((dotScaleFactor - 0.1) / (5 - 0.1)) * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					setDotScale(parseFloat(s.value));
				});
			}

			// 2) Damping slider (0..100 => 0..1)
			{
				const s = $("dampingSlider");
				const v = $("dampingValue");
				s.value = damping * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					damping = parseFloat(s.value) / 100;
					v.textContent = Math.round(s.value) + "%";
				});
			}

			// 3) Spring Constant slider (0..100 => 0..1)
			{
				const s = $("springConstantSlider");
				const v = $("springConstantValue");
				s.value = springConstant * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					springConstant = parseFloat(s.value) / 100;
					v.textContent = Math.round(s.value) + "%";
				});
			}

			// 4) Repulsion slider (0..100 => 0..1)
			{
				const s = $("repulsionConstantSlider");
				const v = $("repulsionConstantValue");
				s.value = repulsionConstant * 200;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					repulsionConstant = parseFloat(s.value) / 200;
					v.textContent = s.value + "%";
				});
			}

			// 5) Simulation Speed slider (0..100 => 0.1..2)
			{
				const s = $("timeStepSlider");
				const v = $("timeStepValue");
				s.value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
				v.textContent = s.value + "%";
				s.addEventListener("input", () => {
					const percent = parseFloat(s.value);
					timeStep = mapRange(percent, 0, 100, 0.1, 2);
					v.textContent = s.value + "%";
				});
			}

			window.addEventListener("keydown", e => {
				// ignore ‚áß/‚å•/‚åò combos and when user is typing in an input / textarea
				if (e.ctrlKey || e.metaKey || e.altKey) return;
				const tgt = e.target;
				if (tgt && (tgt.tagName === "INPUT" || tgt.tagName === "TEXTAREA")) return;

				switch (e.key.toLowerCase()) {
					/* draw modes */
					case "q":
						setDrawMode("blob");
						break; // Blob
					case "w":
						setDrawMode("line");
						break; // Line
					case "e":
						setDrawMode("circle");
						break; // Circle

						/* edit tools (toggle off if already on) */
					case "a":
						setEditTool("drag");
						break; // Drag
					case "s":
						setEditTool("freeze");
						break; // Freeze
					case "d":
						setEditTool("pin");
						break; // Pin
					case "z":
						setEditTool("slice");
						break; // Slice
					case "x":
						setEditTool("delete");
						break; // Delete
				}
			});

			window.addEventListener("keydown", e => {
				if (e.code === "Space" && !e.repeat) { // Space toggles
					if (damping !== 0) { // turn OFF
						prevDamping = damping; // remember
						damping = 0;
					} else { // turn ON
						damping = prevDamping || 0.85; // fallback default
					}

					// keep the UI slider in sync
					const s = $("dampingSlider"),
						v = $("dampingValue");
					s.value = damping * 100;
					v.textContent = Math.round(s.value) + "%";

					e.preventDefault(); // stop the page from scrolling
				}
			});
			// 6) Gap & ŒîSize
			$("radiusAvgInput").oninput = e => {
				globalRadiusAvg = parseFloat(e.target.value);
			};
			$("radiusVarInput").oninput = e => {
				globalRadiusVar = parseFloat(e.target.value);
			};
		});
	</script>
</body>

</html>
