<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>blobSketch version 1.12</title>
  <style>
  /* ───────── 1. Base / Reset ───────── */
body {
  margin: 0;
  padding: 0;
  font-family: "Courier New", monospace;
  background-color: #efefef;
  color: #000;
}

/* ───────── 2. Global Containers ──── */
.window {
  width: 800px;
  margin: 40px auto;
  border: 2px solid #000;
  background-color: #fff;
  box-shadow: 4px 4px 0px #000;
  position: relative;
}

.content {
  display: flex;
}

/* ───────── 3. Title-bar & Menu ───── */
.title-bar {
  background-color: #c0c0c0;
  border-bottom: 2px solid #000;
  padding: 4px 8px;
  display: flex;
  gap: 12px;
  align-items: center;
  position: relative;
}

.menu-bar {
  display: flex;
  gap: 16px;
}
.menu-bar span {
  font-weight: bold;
  cursor: pointer;
  position: relative;
}
.menu-bar span:hover {
  text-decoration: underline;
}

.submenu {
  display: none;
  position: absolute;
  top: 24px;
  left: 0;
  background-color: #c0c0c0;
  border: 2px solid #000;
  padding: 4px;
  flex-direction: column;
  gap: 4px;
  z-index: 999;
}
.submenu span {
  display: block;
  padding: 2px 6px;
  cursor: pointer;
}
.submenu span:hover {
  background-color: #d9d9d9;
}
#exportSubmenu { width: 160px; }
#fileSubmenu   { width: 200px; }

.reset-icon {
  margin-left: auto;
  font-weight: bold;
  font-size: 18px;
  cursor: pointer;
  user-select: none;
  text-decoration: none;
  padding: 0 8px;
}
.reset-icon:hover {
  background-color: #d9d9d9;
}

/* ───────── 4. Workspace Layout ───── */
/* 4-A  Toolbar shell */
.toolbar {
  width: 150px;
  border-right: 2px solid #000;
  background-color: #d9d9d9;
  padding: 6px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* 4-B  Toolbar sections */
.toolbar-section {
  border: 1px solid #000;
  background-color: #efefef;
  padding: 4px;
  margin: 2px 0;
}
.toolbar-section h4 {
  margin: 0 0 4px;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  background-color: #b0b0b0;
  color: #000;
  border: 1px solid #000;
  padding: 2px;
}
.toolbar-section .icon-group {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  justify-content: center;
}

/* glowing outline when any edit mode is engaged */
#editToolsSection.edit-on {
  outline: 3px solid #ff3b3b;                  /* neon red */
  box-shadow: 0 0 6px 2px #ff3b3b inset,
              0 0 6px 2px #ff3b3b;             /* subtle outer glow */
  transition: outline-color .2s, box-shadow .2s;
}

/* 4-C  Icon buttons */
.icon {
  width: 32px;
  height: 32px;
  border: 2px solid #000;
  background-color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  user-select: none;
  font-weight: normal;
  position: relative;
  /* rounded corners */
border-radius: 6px;        /* or 50% for perfect circles */
overflow: visible;         /* ← allow the ON badge to stick out */
}
.icon img {
  width: 32px;
  height: 32px;
  border-radius: inherit;
}
#iconFill.icon-active {
  background-color: #D3D3D3;
  font-weight: bold;
}
/* “ON” label */
.icon.icon-active::after {
  content: "ON";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #ff0;
  color: #000;
  font-size: 10px;
  font-weight: bold;
  border: 1px solid #000;
  padding: 2px 4px;
  border-radius: 4px;
  box-shadow: 2px 2px 0px #000;
  z-index: 5;
}

/* 4-D  Shape-settings mini-panel */
.shape-settings {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}
.shape-settings label {
  font-size: 12px;
  text-align: center;
  display: block;
}
.shape-settings input[type="color"],
.shape-settings input[type="number"] {
  margin-top: 2px;
  width: 70px;
}

/* ───────── 5. Main Drawing Area ──── */
.main-area {
  flex: 1;
  padding: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
#glCanvas {
  width: 500px;
  height: 500px;
  border: 2px solid #000;
  background-color: #fff;
  display: block;
  margin-bottom: 16px;
}

/* ───────── 6. Bottom Slider Panel ─ */
.bottom-panel {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  border-top: 2px solid #000;
  padding: 8px;
  background-color: #c0c0c0;
  text-align: center;
}
#sliders > div {
  display: flex;
  align-items: center;
  margin: 8px 0;
}
#sliders label {
  width: 250px;
  text-align: center;
  margin-right: 8px;
}
#sliders label span {
  display: inline-block;
  font-weight: bold;
  vertical-align: middle;
}
input[type="range"] {
  -webkit-appearance: none;
  width: 300px;
  background: #fff;
  border: 1px solid #000;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 20px;
  background: #c0c0c0;
  border: 1px solid #000;
  cursor: pointer;
  margin-top: -7px;
}
input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 20px;
  background: #c0c0c0;
  border: 1px solid #000;
  cursor: pointer;
}

/* ───────── 7. Dialogs & Modals ───── */
.dialog-backdrop {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.4);
  justify-content: center;
  align-items: center;
  z-index: 99;
}
.dialog-content {
  background-color: #fff;
  border: 2px solid #000;
  padding: 16px;
  min-width: 200px;
  text-align: center;
  box-shadow: 4px 4px 0px #000;
  font-family: "Courier New", monospace;
}
.dialog-content button {
  margin-top: 12px;
  font-family: inherit;
  cursor: pointer;
}

/* ───────── 8. Splash Overlay ─────── */
#splashOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  cursor: pointer;
}
#splashOverlay img {
  max-width: 50%;
  max-height: 50%;
  pointer-events: none;
  margin-bottom: 50px;
  border: 2px solid #000;
  border-radius: 6px;
  padding: 0px;
}
.splashText {
  font-family: "Courier New", monospace;
  font-size: 18px;
  font-weight: bold;
  color: #000;
  background-color: #c0c0c0;
  padding: 8px 12px;
  border: 2px solid #000;
  box-shadow: 4px 4px 0px #000;
  user-select: none;
}

/* ───────── 9. Help Icon & Tooltip ─ */
.inline-icon {
  width: 16px;
  height: 16px;
  vertical-align: middle;
  margin: 0 4px;
}
.help-icon-container {
  position: relative;
  display: inline-block;
}
.help-icon {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-color: #c0c0c0;
  border: 1px solid #000;
  color: #000;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  line-height: 16px;
  cursor: help;
  user-select: none;
}
.help-tooltip {
  display: none;
  position: absolute;
  bottom: 20px;
  left: 0;
  min-width: 120px;
  background-color: #efefef;
  color: #000;
  border: 1px solid #000;
  padding: 4px;
  font-size: 12px;
  box-shadow: 4px 4px 0 #000;
  z-index: 9999;
}
.help-icon-container:hover .help-tooltip {
  display: block;
}



/* ───────── 10. Cursor Modes ──────── */
.canvas-blob-mode    { cursor: url("images/pencil.png"), auto; }
.canvas-line-mode    { cursor: url("images/pencil.png"), auto; }
.canvas-circle-mode  { cursor: url("images/CircleCursor.png"), auto; }
.canvas-drag-mode    { cursor: url("images/glove.png"), auto; }
.canvas-pin-mode     { cursor: url("images/PinCursor.png"), auto; }
.canvas-slicing-mode { cursor: url("images/trim.png"), auto; }
.canvas-freeze-mode  { cursor: url("images/FreezeCursor.png"), auto; }
.canvas-delete-mode  { cursor: url("images/DeleteCursor.png"), auto; }

/* ───────── 11. Mobile-only Warning ─ */
#mobileWarning {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #fff;
  color: #000;
  font-family: sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  z-index: 10000;
  padding: 20px;
}

.icon:focus-visible { outline: 3px solid #ffbf00; }

.icon[data-label]::before {
  content: attr(data-label);
  position: absolute;
  bottom: -24px;                /* small gap below the icon */
  left: 50%;
  translate: -50% 0;
  font: 12px "Courier New", monospace;
  background: #000;
  color: #fff;
  padding: 2px 6px;
  border-radius: 4px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity .15s;
  z-index: 50;                  /* sit above everything in the toolbar */
}
.icon:hover::before,
.icon:focus-visible::before { opacity: 1; }

/* ---------- toast notifications ---------- */
#toastStack {
  position: absolute;
  top: 48px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
  pointer-events: none;         /* clicks fall through */
  z-index: 2000;
}
.toast {
  font: 14px "Courier New", monospace;
  background: #000;
  color: #fff;
  padding: 6px 10px;
  border-radius: 6px;
  opacity: 0;
  transform: translateY(-8px);
  transition: opacity .2s, transform .2s;
}
.toast.show {
  opacity: .9;
  transform: translateY(0);
}

.title-actions {
  margin-left: auto;            /* pushes the pair to the far right */
  display: flex;
  gap: 6px;                     /* neat 6-px gap between the two icons */
}

/* ---------- guided tour ---------- */
#tourOverlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  z-index:3000; pointer-events:none;
}
#tourTip{
  position:fixed; z-index:3001;
  max-width:320px; font:13px "Courier New",monospace;
  background:#fff; color:#000;
  border:2px solid #000; border-radius:6px;
  padding:10px 12px; box-shadow:4px 4px 0 #000;
}
#tourCtrls{ margin-top:8px; text-align:right; }
#tourCtrls button{
  font:inherit; margin-left:4px; cursor:pointer;
}
.tour-highlight{
  outline:3px solid #ffe600 !important;
  box-shadow:0 0 8px 3px #ffe600 !important;
}

/* --- prettier Presets gallery ---------------------------------- */
.presets-gallery{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(120px,1fr));
  gap:12px;
  padding:4px;
  max-height:60vh;              /* scroll if many presets */
  overflow-y:auto;
}

.preset-card{
  aspect-ratio:1/1;             /* always square */
  background:#fafafa;
  border:2px solid #000;
  box-shadow:3px 3px 0 #000;
  position:relative;
  transition:transform .15s, box-shadow .15s;
}
.preset-card:hover{
  transform:translateY(-3px);
  box-shadow:5px 5px 0 #000;
}
.preset-card:active{ transform:translateY(0); }

.preset-card img,
.preset-card svg{ width:100%; height:100%; object-fit:cover; display:block; }

.preset-card figcaption{
  position:absolute; inset:0;
  background:rgba(0,0,0,.58);
  color:#fff; font:12px "Courier New",monospace;
  display:flex; align-items:center; justify-content:center;
  text-align:center; padding:4px;
  opacity:0; transition:opacity .15s;
}
.preset-card:hover figcaption{ opacity:1; }

/* highlight the card the user just applied */
.preset-card.card-selected{
  outline:3px solid #ffe600;
  box-shadow:0 0 10px 3px #ffe600;
  transform:none;
}

  </style>
</head>
<body>
<div class="window">
  <!-- Splash Overlay -->
  <div id="splashOverlay">
    <img src="images/splash.png" alt="Splash Image" />
    <div class="splashText">Click and Drag to Start Blobbing</div>
  </div>
<div id="toastStack"></div>
<div id="tourOverlay" style="display:none;"></div>
<div id="tourTip" style="display:none;">
  <div id="tourText"></div>
  <div id="tourCtrls">
    <button id="tourPrev">◀ Prev</button>
    <button id="tourNext">Next ▶</button>
    <button id="tourExit">End ✖</button>
  </div>
</div>
  <!-- Title Bar -->
  <div class="title-bar">
    <div class="menu-bar">
      <span id="menuFile">File
        <div class="submenu" id="fileSubmenu">
          <span id="saveBlobsOption">Save Blobs (JSON)</span>
          <span id="loadBlobsOption">Load Blobs (JSON)</span>
        </div>
      </span>
      <span id="menuExport">Export
        <div class="submenu" id="exportSubmenu">
          <span id="exportStrokedOption">...Lines&gt;SVG</span>
          <span id="exportStrokedJPGOption">...Lines&gt;JPG</span>
          <span id="exportFilledOption">...Fill&gt;SVG</span>
          <span id="exportFilledJPGOption">...Fill&gt;JPG</span>
        </div>
      </span>
      <span id="menuPresets">Presets</span>
      <span id="menuAbout">About</span>
      <span id="menuHelp">Help</span>
    </div>
    <div class="title-actions">
      <span id="resetIcon" class="reset-icon" title="Reset Canvas">🗑️</span>
      <span id="notifToggle" class="reset-icon" title="Disable tips">🔔</span>
    </div>
  </div>

  <!-- Main Content -->
  <div class="content">
    <!-- Toolbar: grouped into Draw Tools, Edit Tools, Canvas Tools, and now Shape Settings -->
    <div class="toolbar">
      <!-- DRAW TOOLS -->
      <div class="toolbar-section">
        <h4>Draw Tools</h4>
        <div class="icon-group">
          <div class="icon" id="iconBlob" data-label="Blob (Q)">
            <img src="images/blob.png" alt="Blob Mode" />
          </div>
          <div class="icon" id="iconLine" data-label="Line (W)">
            <img src="images/line.png" alt="Line Mode" />
          </div>
          <div class="icon" id="iconCircle" data-label="Circle (E)">
            <img src="images/wrap.png" alt="Circle Mode" />
          </div>
        </div>
      </div>

      <!-- EDIT TOOLS -->
      <div class="toolbar-section"  id="editToolsSection">
        <h4>Edit Tools</h4>
        <div class="icon-group">
          <div class="icon" id="iconDrag" data-label="Drag (A)">
            <img src="images/gloveIcon.png" alt="Drag Mode" />
          </div>
          <div class="icon" id="iconFreeze" data-label="Freeze (S)">
            <img src="images/freeze.png" alt="Freeze Mode" />
          </div>
          <div class="icon" id="iconPin" data-label="Pin (D)">
            <img src="images/pin.png" alt="Pin Mode" />
          </div>
          <div class="icon" id="iconSlice" data-label="Slice (Z)">
            <img src="images/cut.png" alt="Cut Mode" />
          </div>
          <div class="icon" id="iconDelete" data-label="Delete (X)">
            <img src="images/delete.png" alt="Delete">
          </div>
        </div>
      </div>

      <!-- SHAPE SETTINGS (Color, Gap, ΔSize) -->
      <div class="toolbar-section">
        <h4>Shape Settings</h4>
        <div class="shape-settings">
          <div>
            <label for="blobColor">Color</label>
            <input type="color" id="blobColor" value="#0066ff">
          </div>
          <div>
            <label for="radiusAvgInput">Size</label>
            <input type="number" id="radiusAvgInput" min="0.0" max="20" step="0.2" value="5">
          </div>
          <div>
            <label for="radiusVarInput">Variation</label>
            <input type="number" id="radiusVarInput" min="0" max="10" step="0.5" value="2">
          </div>
        </div>
      </div>

      <!-- CANVAS TOOLS -->
      <div class="toolbar-section">
        <h4>Canvas</h4>
        <div class="icon-group">
          <div class="icon" id="iconThickness" data-label="Line Thickness">T</div>
          <div class="icon" id="iconFill" data-label="Solid Fill">▣</div>
          <div class="icon" id="iconDiffusion" data-label="High Blob Repel"><img src="images/repel.png" alt="Overlap Guard" /></div>
          <div class="icon" id="iconUndo" data-label="Undo Last Item">⎌</div>
        </div>
      </div>
    </div>

    <!-- Main Drawing Area -->
    <div class="main-area">
      <canvas id="glCanvas" width="500" height="500"></canvas>
    </div>
  </div>

  <!-- Bottom Panel: Sliders -->
  <div class="bottom-panel">
    <div id="sliders">
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
             Higher = bigger blobs/lines.
          </div>
        </div>
        <label for="dotScaleSlider" class="slider-label">Blob Size: <span id="dotScaleValue">39%</span></label>
        <input type="range" id="dotScaleSlider" min="0" max="100" value="39" step="0.5">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = more wobble.
          </div>
        </div>
        <label for="dampingSlider">Excitability: <span id="dampingValue">85%</span></label>
        <input type="range" id="dampingSlider" min="0" max="100" value="85" step="0.5">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = tighter shapes.
          </div>
        </div>
        <label for="springConstantSlider">Rigidity: <span id="springConstantValue">30%</span></label>
        <input type="range" id="springConstantSlider" min="0" max="100" value="30" step="1">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Higher = more expansion.
          </div>
        </div>
        <label for="repulsionConstantSlider">Turmoil: <span id="repulsionConstantValue">10%</span></label>
        <input type="range" id="repulsionConstantSlider" min="0" max="100" value="10" step="1">
      </div>
      <div>
        <div class="help-icon-container">
          <span class="help-icon">i</span>
          <div class="help-tooltip">
            Shapes animate faster when higher.
          </div>
        </div>
        <label for="timeStepSlider">Animation Speed: <span id="timeStepValue">47%</span></label>
        <input type="range" id="timeStepSlider" min="0" max="100" value="47" step="1">
      </div>
    </div>
  </div>

  <!-- ░ PRESETS DIALOG ░ -->
  <div class="dialog-backdrop" id="presetsBackdrop">
    <div class="dialog-content presets-dialog">
      <h3>Select a Preset</h3>

      <div id="presetsGallery" class="presets-gallery">
        <!-- Grid preset card -->
        <div class="preset-card" id="presetGrid">
          <svg viewBox="0 0 100 100" width="100%" height="100%">
            <rect width="100" height="100" fill="#fff"/>
            <g stroke="#000" stroke-width="2" fill="none">
              <!-- 5 × 5 grid preview -->
              <circle cx="10" cy="10" r="8"/>
              <circle cx="30" cy="10" r="8"/>
              <circle cx="50" cy="10" r="8"/>
              <circle cx="70" cy="10" r="8"/>
              <circle cx="90" cy="10" r="8"/>

              <circle cx="10" cy="30" r="8"/>
              <circle cx="30" cy="30" r="8"/>
              <circle cx="50" cy="30" r="8"/>
              <circle cx="70" cy="30" r="8"/>
              <circle cx="90" cy="30" r="8"/>

              <circle cx="10" cy="50" r="8"/>
              <circle cx="30" cy="50" r="8"/>
              <circle cx="50" cy="50" r="8"/>
              <circle cx="70" cy="50" r="8"/>
              <circle cx="90" cy="50" r="8"/>

              <circle cx="10" cy="70" r="8"/>
              <circle cx="30" cy="70" r="8"/>
              <circle cx="50" cy="70" r="8"/>
              <circle cx="70" cy="70" r="8"/>
              <circle cx="90" cy="70" r="8"/>

              <circle cx="10" cy="90" r="8"/>
              <circle cx="30" cy="90" r="8"/>
              <circle cx="50" cy="90" r="8"/>
              <circle cx="70" cy="90" r="8"/>
              <circle cx="90" cy="90" r="8"/>
            </g>
          </svg>
          <figcaption>Grid of Circles</figcaption>
        </div>
        <div class="preset-card" id="presetBlobGrid">
        <img src="images/grid_of_blobs.png" alt="Grid of Blobs">
        <figcaption>Grid of Blobs</figcaption>
</div>
      </div>

      <button id="closePresets">Close</button>
    </div>
  </div>

  <div class="dialog-backdrop" id="gridBackdrop">
    <div class="dialog-content">
      <h3>Grid of Circles</h3>

      <label>Count
        <input type="number" id="gridCount" value="5" min="1" max="12">
      </label><br>

      <label>
        <input type="checkbox" id="autoRadius" checked>
        Fit circles to canvas
      </label><br>

      <div id="radiusRow" style="display:none;">
        <label>Radius
          <input type="number" id="gridRadius" value="20" min="2" max="200">
        </label><br>
      </div>

      <button id="applyGrid">Apply</button>
      <button id="cancelGrid">Cancel</button>
    </div>

</div>
<div class="dialog-backdrop" id="blobGridBackdrop">
  <div class="dialog-content">
    <h3>Grid of Blobs</h3>

    <label>Count (rows = cols)
      <input type="number" id="blobGridCount" value="5" min="1" max="10">
    </label><br>

    <label>
      <input type="checkbox" id="blobAutoSize" checked>
      Fit blobs to canvas
    </label><br>

    <div id="blobSizeRow" style="display:none;">
      <label>Base Radius
        <input type="number" id="blobBaseRadius" value="20" min="4" max="120">
      </label><br>
    </div>

    <button id="applyBlobGrid">Apply</button>
    <button id="cancelBlobGrid">Cancel</button>
  </div>
  </div>

  <!-- Modals/Dialogs: About and Help -->
  <div class="dialog-backdrop" id="aboutBackdrop">
    <div class="dialog-content">
      <p>blobSketch version 1.12</p>
      <p>by Colin Reid</p>
      <button id="closeAbout">OK</button>
    </div>
  </div>

  <!-- ░ SAVE / IMPORT OPTION DIALOGS ░ -->
<div class="dialog-backdrop" id="saveOptionsBackdrop">
  <div class="dialog-content">
    <h3>Save Options</h3>
    <label><input type="checkbox" id="saveIncludeChains" checked> Blobs / Lines</label><br>
    <label><input type="checkbox" id="saveIncludeCircles" checked> Circles</label><br>
    <label><input type="checkbox" id="saveIncludeSettings"> Physics & UI Settings</label><br>
    <button id="confirmSaveBtn">Save</button>
    <button id="cancelSaveBtn">Cancel</button>
  </div>
</div>

<div class="dialog-backdrop" id="importOptionsBackdrop">
  <div class="dialog-content">
    <h3>Import Options</h3>
    <label><input type="checkbox" id="importIncludeChains" checked> Blobs / Lines</label><br>
    <label><input type="checkbox" id="importIncludeCircles" checked> Circles</label><br>
    <label><input type="checkbox" id="importIncludeSettings" checked> Physics & UI Settings</label><br>
    <button id="confirmImportBtn">Import</button>
    <button id="cancelImportBtn">Cancel</button>
  </div>
</div>

<!-- ░ END DIALOGS ░ -->
</div>
<div id="circleInfo" style="
     position:fixed; display:none; z-index:10000;
     pointer-events:none; font:12px 'Courier New',monospace;
     padding:3px 6px; background:#ffffcc;
     border:1px solid #000; box-shadow:3px 3px 0 #000;">
</div>
<script>
if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  document.addEventListener("DOMContentLoaded", function() {
    var warningDiv = document.createElement("div");
    warningDiv.id = "mobileWarning";
    warningDiv.innerHTML = '<h1>Desktop Only</h1><p>This application is best experienced on a desktop browser. Please switch to a desktop device.</p>';
    document.body.appendChild(warningDiv);
  });
}

document.addEventListener("DOMContentLoaded", () => {
  /* -----------------------------------
     SHORTCUTS & UTILITIES
  ----------------------------------- */
  const $ = id => document.getElementById(id);
  const circleInfo = $("circleInfo");
  // Helper for converting from one numeric range to another
  function mapRange(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  }

  const hexToRGBA = hex => {
    if (hex[0] === "#") hex = hex.slice(1);
    const r = parseInt(hex.slice(0,2),16)/255,
          g = parseInt(hex.slice(2,4),16)/255,
          b = parseInt(hex.slice(4,6),16)/255;
    return [r,g,b,1.0];
  };

  function setDotScale(percent) {
    percent = Math.max(DOT_MIN_PERCENT,
              Math.min(DOT_MAX_PERCENT, percent));

    $("dotScaleSlider").value     = percent;
    $("dotScaleValue").textContent= Math.round(percent) + "%";

    dotScaleFactor = mapRange(percent, 0, 100, 0.1, 5);
  }

  /* ---------- toast notifications ---------- */
let tipsEnabled = false;
$("notifToggle").onclick = () => {
  tipsEnabled = !tipsEnabled;
  $("notifToggle").textContent = tipsEnabled ? "🔔" : "🔕";
  $("notifToggle").title       = tipsEnabled ? "Disable tips" : "Enable tips";
};
/* 2 ▸ ensure the bell shows the muted state on first load */
$("notifToggle").textContent = "🔕";
$("notifToggle").title       = "Enable tips";
function toast(msg, ms = 2200) {
  if (!tipsEnabled) return;
  const el = document.createElement("div");
  el.className = "toast";
  el.textContent = msg;
  $("toastStack").appendChild(el);
  requestAnimationFrame(() => el.classList.add("show"));   // fade in
  setTimeout(() => {
    el.classList.remove("show");                           // fade out
    el.addEventListener("transitionend", () => el.remove(), { once:true });
  }, ms);
}

  /* -----------------------------------
     SPLASH OVERLAY
  ----------------------------------- */
  $("splashOverlay").onclick = () => {
    $("splashOverlay").style.display = "none";
  };

  /* -----------------------------------
     DIALOG SETUP (ABOUT, HELP)
  ----------------------------------- */
  function setupDialog(openBtnId, backdropId, closeBtnId) {
    const openBtn = $(openBtnId),
          backdrop= $(backdropId),
          closeBtn= $(closeBtnId);
    openBtn.addEventListener("click", () => (backdrop.style.display = "flex"));
    closeBtn.addEventListener("click", () => (backdrop.style.display = "none"));
  }
  setupDialog("menuAbout", "aboutBackdrop", "closeAbout");
  $("menuHelp").addEventListener("click", startTour);
  window.addEventListener("keydown", e => { if (e.key==="h"||e.key==="H") startTour(); });

  /* -----------------------------------
     FILE & EXPORT MENU
  ----------------------------------- */
  function setupSubmenu(menuId, submenuId) {
    const menu = $(menuId), submenu = $(submenuId);
    let visible = false;
    menu.addEventListener("click", (e) => {
      e.stopPropagation();
      visible = !visible;
      submenu.style.display = visible ? "flex" : "none";
    });
    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && visible) {
        visible = false;
        submenu.style.display = "none";
      }
    });
  }
  setupSubmenu("menuFile", "fileSubmenu");
  setupSubmenu("menuExport", "exportSubmenu");


  /* ---------- PRESETS ---------- */
  $("menuPresets").onclick = () => {
    $("presetsBackdrop").style.display = "flex";
  };

  /* close gallery */
  $("closePresets").onclick = () =>
    $("presetsBackdrop").style.display = "none";

  /* show the Grid-options dialog when the card is clicked */
  $("presetGrid").onclick = () => {
    $("presetsBackdrop").style.display = "none";
    $("gridBackdrop").style.display    = "flex";
  };

  /* cancel grid dialog */
  $("cancelGrid").onclick = () =>
    $("gridBackdrop").style.display = "none";

    /* show / hide the custom-radius row */
    $("autoRadius").onchange = () =>
      $("radiusRow").style.display = $("autoRadius").checked ? "none" : "block";

  /* apply grid */
  $("applyGrid").onclick = () => {
    const count = Math.min(12,
                  Math.max(1, parseInt($("gridCount").value, 10) || 1));
    /* this radius would make circles kiss each other and the edges */
    const maxR = Math.min(canvas.width, canvas.height) / (count * 2);

    /* the actual radius – either maxR or a user-supplied smaller one */
    const radius = $("autoRadius").checked
      ? maxR
      : Math.min(parseFloat($("gridRadius").value) || 2, maxR);

    /* IMPORTANT:  spacing is based on maxR so the centres never move   */
    const spacing = 2 * maxR;

    for (let r = 0; r < count; r++) {
      for (let c = 0; c < count; c++) {
        circles.push({
          x: maxR + c * spacing,
          y: maxR + r * spacing,
          radius                      // may be < maxR ⇒ nice margin
        });
        history.push({ type: "circle" });
      }
    }

    /* set Blob Size slider to 0 % and Excitability to 85 % */
    setDotScale(0);                            // updates UI + dotScaleFactor
    damping = 0.85;
    $("dampingSlider").value = 85;
    $("dampingValue").textContent = "85%";
    /* ── 1. High Repulsion ON ── */
    if (interRepelMult !== 3) {               // 1 = normal, 3 = high
      interRepelMult = 3;
      toggleActiveIcon($("iconDiffusion"), true);
    }

    /* ── 2. Blob draw-mode ── */
    setDrawMode("blob");                      // switches UI + cursor

    /* ── 3. Edit tools OFF ── */
    slicingMode = dragMode = pinMode =
    freezeMode  = deleteMode = false;         // clear flags
    $("editToolsSection").classList.remove("edit-on");
    ["iconSlice","iconDrag","iconPin","iconFreeze","iconDelete"]
      .forEach(id=>setIconActive($(id),false,"",""));
    updateCanvasCursor();

    if (!solidFillMode) {
      solidFillMode = true;
      $("iconFill").title = "Solid Fill On";
      toggleActiveIcon($("iconFill"), true);
    }

    toast(`Grid (${count}×${count}) added`, 1600);
    $("gridBackdrop").style.display = "none";
  };


  /* === GRID-OF-BLOBS PRESET ======================================== */
  $("presetBlobGrid").onclick = () => {
    $("presetsBackdrop").style.display = "none";   // ✨ hide gallery
    $("blobGridBackdrop").style.display = "flex";  // show blob-dialog
  };

  /* toggle custom size row */
  $("blobAutoSize").onchange = () =>
    $("blobSizeRow").style.display = $("blobAutoSize").checked ? "none" : "block";

  /* helper to create a simple circular blob (you could swap in fancier math) */
  function makeCircleBlob(cx, cy, r, colorArr) {
    const steps = 48;
    const pts = [];
    for (let i = 0; i < steps; i++) {
      const θ = i / steps * 2 * Math.PI;
      pts.push({
        x: cx + r * Math.cos(θ),
        y: cy + r * Math.sin(θ),
        vx: 0, vy: 0, pinned: false
      });
    }
    return {
      chain: pts,
      color: colorArr,
      baseDotRadius: r * 0.12,
      isClosed: true,
      frozen: false
    };
  }

  /* Apply button */
  $("applyBlobGrid").onclick = () => {
    /* 1 ─ grid sizing */
    const cnt = Math.min(10,
                Math.max(1, parseInt($("blobGridCount").value, 10) || 1));
    const maxR = Math.min(canvas.width, canvas.height) / (cnt * 2);

    const baseR = $("blobAutoSize").checked
        ? maxR
        : Math.min(parseFloat($("blobBaseRadius").value) || 4, maxR);

    const spacing = 2 * maxR;           // centres stay fixed

    const chosenColor = hexToRGBA($("blobColor").value);
    /* 2 ─ add blobs */
    for (let r = 0; r < cnt; r++) {
      for (let c = 0; c < cnt; c++) {
        const cx = maxR + c * spacing;
        const cy = maxR + r * spacing;
        const blob = makeCircleBlob(cx, cy, baseR, chosenColor);
        chains.push(blob);
        history.push({ type: "chain" });
      }
    }

    /* 3 ─ snap UI states exactly like circle-grid did */
    {
      if (interRepelMult !== 3) {
        interRepelMult = 3;
        toggleActiveIcon($("iconDiffusion"), true);
      }
      setDrawMode("blob");
      $("dampingSlider").value = 40;
      $("dampingValue").textContent = "40%";
      setDotScale(12);
      damping = 0.40;
      if (!solidFillMode) {
        solidFillMode = true;
        $("iconFill").title = "Solid Fill On";
        toggleActiveIcon($("iconFill"), true);
      }
      slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;
      $("editToolsSection").classList.remove("edit-on");
      ["iconSlice","iconDrag","iconPin","iconFreeze","iconDelete"]
        .forEach(id=>setIconActive($(id),false,"",""));
      updateCanvasCursor();
    }

    toast(`Blob grid (${cnt}×${cnt}) added`, 1600);
    $("blobGridBackdrop").style.display = "none";
  };
  $("cancelBlobGrid").onclick = () =>
    $("blobGridBackdrop").style.display = "none";

  /* -----------------------------------
     WEBGL CONTEXT
  ----------------------------------- */
  const canvas = $("glCanvas");
  const gl = canvas.getContext("webgl", { stencil: true });
  if (!gl) alert("WebGL not supported by your browser.");
  gl.enable(gl.BLEND);
  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,
                       gl.ONE,         gl.ONE_MINUS_SRC_ALPHA);
  /* -----------------------------------
     GLOBALS & DATA
  ----------------------------------- */

  /* 1. Canvas draw-mode */
  let drawMode = 'blob';           // 'blob' | 'line' | 'circle'

  /* 2. Geometry collections */
  const chains   = [];             // { chain:[…], color, baseDotRadius, isClosed, frozen }
  const circles  = [];             // { x, y, radius }
  let   history  = [];             // undo stack

  /* 3. Live drawing state */
  let isDrawing            = false;
  let isCircleDrawing      = false;
  let currentCircle        = null;
  let draggingCircleIndex  = null;

  /* 4. Active edit-tool flags (mutually exclusive) */
  let slicingMode = false,
      dragMode    = false,
      pinMode     = false,
      freezeMode  = false,
      deleteMode  = false;

  /* 5. Drag / hover helpers */
  let draggingChainIndex = null,
      draggingDotIndex   = null;
  let pinHoverChainIndex = null,
      pinHoverDotIndex   = null;

  /* 6. Render options */
  let solidFillMode = true;       // false = outline, true = filled

  /* 7. Physics parameters (defaults) */
  let springConstant       = 0.3,  // ~30 %
      repulsionConstant    = 0.1,  // ~10 %
      damping              = 0.85, // ~85 %
      timeStep             = 1.05, // slider 47 % → 0.1‒2
      dotScaleFactor       = 2.0,  // slider 39 % → 0.1‒5
      currentLineThickness = 1;
  applyThicknessUI();              // sync UI immediately
  toggleActiveIcon($("iconFill"), solidFillMode);   // add this line
  $("iconFill").title = "Solid Fill On";            // correct tooltip

  let prevDamping = damping;       // remembers last non-zero value

  /* 8. Global shape settings */
  let globalRadiusAvg = 4,
      globalRadiusVar = 2;

  /* 9. UI element references */
  const colorInput = $("blobColor");
  const DOT_SCROLL_STEP   = 0.01;   // lower = finer control
  const DOT_MIN_PERCENT   = 0;
  const DOT_MAX_PERCENT   = 100;
  /* -----------------------------------
     ICON "ON" LABEL HELPER
  ----------------------------------- */
  function toggleActiveIcon(iconEl, isActive) {
    iconEl.classList.toggle("icon-active", isActive);
  }

  // A helper to apply the “active” styling to edit-tool icons
  function setIconActive(iconEl, isActive, activeTitle, inactiveTitle) {
    iconEl.title = isActive ? activeTitle : inactiveTitle;
    iconEl.style.backgroundColor = isActive ? "#D3D3D3" : "";
    iconEl.style.fontWeight      = isActive ? "bold" : "normal";
    iconEl.classList.toggle("icon-active", isActive);
  }

  // Ensure only one edit tool is active at a time
  function setEditTool(toolName) {
    // If the requested tool is already active, we’ll toggle it off
    const isAlreadyActive =
          (toolName === "slice"  && slicingMode) ||
          (toolName === "drag"   && dragMode)    ||
          (toolName === "pin"    && pinMode)     ||
          (toolName === "freeze" && freezeMode)  ||
          (toolName === "delete" && deleteMode);

    // First, turn everything off:
    slicingMode = dragMode = pinMode = freezeMode = deleteMode = false;

    // If the requested tool wasn’t already active, we turn it on:
    if (!isAlreadyActive) {
      if (toolName === "slice")  slicingMode = true;
      if (toolName === "drag")   dragMode    = true;
      if (toolName === "pin")    pinMode     = true;
      if (toolName === "freeze") freezeMode  = true;
      if (toolName === "delete") deleteMode  = true;
    }

    const editFrame = $("editToolsSection");
    const anyEditOn = slicingMode || dragMode || pinMode || freezeMode || deleteMode;
    editFrame.classList.toggle("edit-on", anyEditOn);
    // Update icon states accordingly:
    setIconActive($("iconSlice"),  slicingMode,
                  "Slicing Mode (On)", "Slicing Mode (Off)");
    setIconActive($("iconDrag"),   dragMode,
                  "Disable Drag Mode", "Enable Drag Mode");
    setIconActive($("iconPin"),    pinMode,
                  "Disable Pin Mode", "Enable Pin Mode");
    setIconActive($("iconFreeze"), freezeMode,
                  "Disable Freeze Mode", "Enable Freeze Mode");
    setIconActive($("iconDelete"), deleteMode,
                  "Disable Delete Mode", "Enable Delete Mode");
  // Update the canvas cursor
    updateCanvasCursor();

    const msg = isAlreadyActive ? "Edit tools off"
                            : `Edit mode: ${toolName.toUpperCase()}`;
  toast(msg, 1800);
  }

  /* -----------------------------------
     DRAW MODE: BLOB / LINE / CIRCLE
  ----------------------------------- */
  function setDrawMode(mode) {
    toggleActiveIcon($("iconBlob"),   false);
    toggleActiveIcon($("iconLine"),   false);
    toggleActiveIcon($("iconCircle"), false);

    drawMode = mode;

    toast(`Draw mode: ${mode.toUpperCase()}`, 1800);

    if (mode === 'blob') {
      toggleActiveIcon($("iconBlob"), true);
    } else if (mode === 'line') {
      toggleActiveIcon($("iconLine"), true);
    } else if (mode === 'circle') {
      toggleActiveIcon($("iconCircle"), true);
    }
    updateCanvasCursor();
  }
  // Initialize default draw mode
  setDrawMode('blob');

  /* -----------------------------------
     EDIT TOOL ICONS (now calling setEditTool)
  ----------------------------------- */
  $("iconSlice").onclick = function() {
    setEditTool("slice");
  };
  $("iconDrag").onclick = function() {
    setEditTool("drag");
  };
  $("iconPin").onclick = function() {
    setEditTool("pin");
  };
  $("iconFreeze").onclick = function() {
    setEditTool("freeze");
  };
  $("iconDelete").onclick = function() {
    setEditTool("delete");
  };

  $("iconFill").onclick = () => {
  solidFillMode = !solidFillMode;
  $("iconFill").title = solidFillMode ? "Solid Fill On" : "Solid Fill Off";
  toggleActiveIcon($("iconFill"), solidFillMode);
  toast(solidFillMode ? "Fill: ON" : "Fill: OFF", 1600);
};
  /* -----------------------------------
     THICKNESS & UNDO & RESET
  ----------------------------------- */

  function applyThicknessUI() {
    const btn = $("iconThickness");
    toggleActiveIcon(btn, currentLineThickness > 1);
  }

  $("iconThickness").onclick = () => {
    currentLineThickness = (currentLineThickness === 1) ? 5 : 1;
    applyThicknessUI();
      toast(currentLineThickness === 1 ? "Stroke: Thin" : "Stroke: Thick", 1600);
  };

  $("iconUndo").onclick = () => {
    if (history.length > 0) {
      const last = history.pop();
      if (last.type === "chain")  chains.pop();
      if (last.type === "circle") circles.pop();
    }
    toast("Undo", 1200);
  };

  $("resetIcon").onclick = () => {
    if (confirm("Are you sure you want to clear the entire canvas?")) {
      chains.length = 0;
      circles.length = 0;
      history.length = 0;
    }
  toast("Canvas cleared", 1600);
  };

  let interRepelMult = 1;  // 1 = normal, 3 = boosted

  $("iconDiffusion").onclick = () => {
    interRepelMult = interRepelMult === 1 ? 3 : 1;
    toggleActiveIcon($("iconDiffusion"), interRepelMult === 3);
    toast(interRepelMult === 3 ? "High Repel: ON" : "High Repel: OFF", 1600);
  };

  /* -----------------------------------
     DRAW MODE ICONS
  ----------------------------------- */
  $("iconBlob").onclick = () => setDrawMode('blob');
  $("iconLine").onclick = () => {
    if (drawMode === "line") {
      setDrawMode("blob");
    } else {
      setDrawMode("line");
    }
  };
  $("iconCircle").onclick = () => {
    if (drawMode === "circle") {
      setDrawMode("blob");
    } else {
      setDrawMode("circle");
    }
  };

  /* -----------------------------------
     UPDATE CANVAS CURSOR
  ----------------------------------- */
  function updateCanvasCursor() {
    canvas.classList.remove(
      "canvas-blob-mode",
      "canvas-line-mode",
      "canvas-circle-mode",
      "canvas-drag-mode",
      "canvas-pin-mode",
      "canvas-slicing-mode",
      "canvas-freeze-mode",
      "canvas-delete-mode"
    );
    // Draw mode
    if (drawMode === 'blob')   canvas.classList.add("canvas-blob-mode");
    if (drawMode === 'line')   canvas.classList.add("canvas-line-mode");
    if (drawMode === 'circle') canvas.classList.add("canvas-circle-mode");

    // Edit tools
    if (slicingMode) canvas.classList.add("canvas-slicing-mode");
    if (dragMode)    canvas.classList.add("canvas-drag-mode");
    if (pinMode)     canvas.classList.add("canvas-pin-mode");
    if (freezeMode)  canvas.classList.add("canvas-freeze-mode");
    if (deleteMode)  canvas.classList.add("canvas-delete-mode");
  }

  /* -----------------------------------
     FILE MENU LOGIC (SAVE/LOAD)
  ----------------------------------- */
  function getCurrentSettings() {
    return {
      timeStep,
      springConstant,
      repulsionConstant,
      damping,
      dotScaleFactor,
      currentLineThickness,
      globalRadiusAvg,
      globalRadiusVar,
      colorValue: colorInput.value
    };
  }
  function applySettings(obj) {
    if (typeof obj.timeStep === "number") {
      timeStep = obj.timeStep;
      $("timeStepSlider").value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
      $("timeStepValue").textContent = $("timeStepSlider").value + "%";
    }
    if (typeof obj.springConstant === "number") {
      springConstant = obj.springConstant;
      $("springConstantSlider").value = springConstant * 100;
      $("springConstantValue").textContent = $("springConstantSlider").value + "%";
    }
    if (typeof obj.repulsionConstant === "number") {
      repulsionConstant = obj.repulsionConstant;
      $("repulsionConstantSlider").value = repulsionConstant * 100;
      $("repulsionConstantValue").textContent = $("repulsionConstantSlider").value + "%";
    }
    if (typeof obj.damping === "number") {
      damping = obj.damping;
      $("dampingSlider").value = damping * 100;
      $("dampingValue").textContent = $("dampingSlider").value + "%";
    }
    if (typeof obj.dotScaleFactor === "number") {
      dotScaleFactor = obj.dotScaleFactor;
      $("dotScaleSlider").value = ((dotScaleFactor - 0.1)/(5 - 0.1))*100;
      $("dotScaleValue").textContent = $("dotScaleSlider").value + "%";
    }
    if (typeof obj.currentLineThickness === "number") {
      currentLineThickness = obj.currentLineThickness;
      $("iconThickness").title = (currentLineThickness === 1)
        ? "Line Thickness: Thin"
        : "Line Thickness: Thick";
      $("iconThickness").style.fontWeight      = (currentLineThickness === 5) ? "bold" : "normal";
      $("iconThickness").style.backgroundColor = (currentLineThickness === 5) ? "#D3D3D3" : "";
      toggleActiveIcon($("iconThickness"), currentLineThickness > 1);
    }
    if (typeof obj.globalRadiusAvg === "number") {
      globalRadiusAvg = obj.globalRadiusAvg;
      $("radiusAvgInput").value = obj.globalRadiusAvg;
    }
    if (typeof obj.globalRadiusVar === "number") {
      globalRadiusVar = obj.globalRadiusVar;
      $("radiusVarInput").value = obj.globalRadiusVar;
    }
    if (typeof obj.colorValue === "string") {
      colorInput.value = obj.colorValue;
    }
  }
  function downloadJSON(filename, dataObj) {
    const dataStr = JSON.stringify(dataObj, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url  = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
  }

  /* ---------- SAVE ---------- */
  $("saveBlobsOption").onclick = e => {
    e.stopPropagation();
    $("fileSubmenu").style.display = "none";
    $("saveOptionsBackdrop").style.display = "flex";
  };
  $("cancelSaveBtn").onclick = () =>
    $("saveOptionsBackdrop").style.display = "none";

  $("confirmSaveBtn").onclick = () => {
    const payload = {};
    if ($("saveIncludeChains").checked)  payload.chains  = chains;
    if ($("saveIncludeCircles").checked) payload.circles = circles;
    if ($("saveIncludeSettings").checked) payload.settings = getCurrentSettings();
    downloadJSON("blobs.json", payload);
    $("saveOptionsBackdrop").style.display = "none";
  };

  /* ---------- IMPORT (file ➜ dialog) ---------- */
let pendingImport = null;   // temp storage

$("loadBlobsOption").onclick = e => {
  e.stopPropagation();
  $("fileSubmenu").style.display = "none";

  const fi = document.createElement("input");
  fi.type = "file";
  fi.accept = "application/json";

  fi.onchange = ev => {
    const file = ev.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = evt => {
      try {
        pendingImport = JSON.parse(evt.target.result);

        /* pre‑select / disable boxes based on what the file actually contains */
        $("importIncludeChains").disabled   = !pendingImport.chains;
        $("importIncludeCircles").disabled  = !pendingImport.circles;
        $("importIncludeSettings").disabled = !pendingImport.settings;

        $("importIncludeChains").checked   = !!pendingImport.chains;
        $("importIncludeCircles").checked  = !!pendingImport.circles;
        $("importIncludeSettings").checked = !!pendingImport.settings;

        $("importOptionsBackdrop").style.display = "flex";
      } catch {
        alert("Error parsing JSON file!");
      }
    };
    reader.readAsText(file);
  };
  fi.click();
};

/* user clicks Import / Cancel */
$("confirmImportBtn").onclick = () => {
  if (!pendingImport) return;

  if ($("importIncludeChains").checked   && pendingImport.chains)
    pendingImport.chains.forEach(c => chains.push(c));

  if ($("importIncludeCircles").checked  && pendingImport.circles)
    pendingImport.circles.forEach(c => circles.push(c));

  if ($("importIncludeSettings").checked && pendingImport.settings)
    applySettings(pendingImport.settings);

  pendingImport = null;
  $("importOptionsBackdrop").style.display = "none";
};
$("cancelImportBtn").onclick = () => {
  pendingImport = null;
  $("importOptionsBackdrop").style.display = "none";
};



  /* -----------------------------------
     MOUSE EVENTS & DRAWING
  ----------------------------------- */
  let currentPathPoints = [];
  let currentMouseX = 0, currentMouseY = 0;

  const dotSlider = $("dotScaleSlider");

  /* Wheel on canvas */
  canvas.addEventListener("wheel", handleDotWheel, { passive:false });
  /* Wheel directly on the slider (nice for trackpads) */
  dotSlider.addEventListener("wheel", handleDotWheel, { passive:false });

  function handleDotWheel(e) {
    e.preventDefault();                    // stop page scroll
    const delta = e.deltaY;                // +120, −120, etc.
    const current = parseFloat(dotSlider.value);
    const next    = current - delta * DOT_SCROLL_STEP;
    setDotScale(next);
  }

  canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    currentMouseX = e.clientX - rect.left;
    currentMouseY = e.clientY - rect.top;

    // If drawing a blob or line
    if (isDrawing && (drawMode === 'blob' || drawMode === 'line')) {
      const last = currentPathPoints[currentPathPoints.length - 1];
      const dx = currentMouseX - last.x,
            dy = currentMouseY - last.y;
      if (Math.sqrt(dx*dx + dy*dy) > 1.5) {
        currentPathPoints.push({
          x: currentMouseX, y: currentMouseY,
          vx:0, vy:0,
          pinned:false
        });
      }
    }

    // If resizing a new circle
    if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
      const r = Math.sqrt(
        (currentMouseX - currentCircle.x) ** 2 +
        (currentMouseY - currentCircle.y) ** 2
      );
      currentCircle.radius = r;

      circleInfo.textContent = "r: " + Math.round(r);
      circleInfo.style.left  = (e.clientX + 14) + "px";
      circleInfo.style.top   = (e.clientY + 18) + "px";
      circleInfo.style.display = "block";
    } else {
      circleInfo.style.display = "none";
    }

    // If dragging an existing circle
    if (drawMode === 'circle' && dragMode && draggingCircleIndex !== null) {
      circles[draggingCircleIndex].x = currentMouseX;
      circles[draggingCircleIndex].y = currentMouseY;
    }

    // Highlight nearest dot if pinMode/dragMode
    if ((pinMode || dragMode) && (e.movementX || e.movementY)) {
      pinHoverChainIndex = null;
      pinHoverDotIndex   = null;

      let bestDist    = Infinity;
      const hoverRad  = 20; // hover radius in px

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = currentMouseX - dot.x;
          const dy  = currentMouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < hoverRad && dist < bestDist) {
            bestDist           = dist;
            pinHoverChainIndex = c;
            pinHoverDotIndex   = i;
          }
        }
      }
    }

  });

  function polygonArea(points) {
  let sum = 0;
  for (let i = 0; i < points.length; i++) {
    const j = (i + 1) % points.length;
    sum += points[i].x * points[j].y
         - points[j].x * points[i].y;
  }
  return Math.abs(sum) / 2;
 }
  /**
   * Ray-casting test for point-in-polygon
   */
  function pointInPolygon(px, py, polygon) {
    let inside = false;
    for (let i=0, j=polygon.length-1; i<polygon.length; j=i++) {
      const xi = polygon[i].x, yi = polygon[i].y;
      const xj = polygon[j].x, yj = polygon[j].y;
      const intersect = ((yi>py) !== (yj>py)) &&
        (px < (xj - xi)*(py - yi)/(yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX= e.clientX - rect.left;
    const mouseY= e.clientY - rect.top;

    // Circle creation or circle dragging
    if (drawMode === 'circle') {
      if (dragMode) {
        // If we're in dragMode AND circle draw mode, we only do circle dragging:
        // (Try to pick up an existing circle but do NOT create a new one)
        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];
          const dx = mouseX - c.x;
          const dy = mouseY - c.y;
          if (Math.sqrt(dx * dx + dy * dy) < c.radius + 5) {
            draggingCircleIndex = i;
            return;
          }
        }

        // If we didn’t find a circle to drag, just return without creating one:
        return;

      } else {
        // Otherwise (dragMode is OFF), start a new circle
        isCircleDrawing = true;
        currentCircle = { x: mouseX, y: mouseY, radius: 0 };
        return;
      }
    }

    // Slicing mode
    if (slicingMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const sliceRadius  = 15;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < sliceRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        const ch = chains[bestChainIndex].chain;
        if (bestDotIndex > 0 && bestDotIndex < ch.length - 1) {
          const firstHalf = ch.slice(0, bestDotIndex);
          const secondHalf= ch.slice(bestDotIndex);
          chains[bestChainIndex].chain = firstHalf;
          chains.push({
            ...chains[bestChainIndex],
            chain: secondHalf
          });
          history.push({ type: "chain" });
        }
      }
      return;
    }

    // Freeze mode
    if (freezeMode) {
      // 1) find all blobs under the mouse
      const hits = [];
      for (let i = 0; i < chains.length; i++) {
        const ch = chains[i];
        if (!ch.isClosed) continue;
        if (pointInPolygon(mouseX, mouseY, ch.chain)) {
          hits.push(i);
        }
      }

      if (hits.length) {
        // 2) pick the smallest one
        let bestIndex = hits[0];
        let bestArea  = polygonArea(chains[bestIndex].chain);

        for (let k = 1; k < hits.length; k++) {
          const idx = hits[k];
          const area = polygonArea(chains[idx].chain);
          if (area < bestArea) {
            bestArea = area;
            bestIndex = idx;
          }
        }

    // 3) toggle only that blob
    chains[bestIndex].frozen = !chains[bestIndex].frozen;
    chains[bestIndex].alpha  = chains[bestIndex].frozen ? 0.3 : 1.0;
  }
  return;
  }
  // ----- DELETE MODE: remove the smallest blob under cursor -----
  if (deleteMode) {

    /* a) test circles first */
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i],
            dx = mouseX - c.x,
            dy = mouseY - c.y;
      if (Math.hypot(dx, dy) < c.radius) {
        circles.splice(i, 1);
        history.push({ type: "circle" });
        return;
      }
    }

    /* b) test open lines: nearest segment within 6 px */
    const SEG_TOL = 6;
    for (let k = 0; k < chains.length; k++) {
      const obj = chains[k];
      if (obj.isClosed) continue;              // skip blobs (do later)
      const pts = obj.chain;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i],  b = pts[i + 1];
        const t = ((mouseX - a.x)*(b.x - a.x) + (mouseY - a.y)*(b.y - a.y)) /
                  ((b.x - a.x)**2 + (b.y - a.y)**2);
        const clamped = Math.max(0, Math.min(1, t));
        const px = a.x + clamped*(b.x - a.x);
        const py = a.y + clamped*(b.y - a.y);
        if (Math.hypot(mouseX - px, mouseY - py) < SEG_TOL) {
          chains.splice(k, 1);
          history.push({ type: "chain" });
          return;
        }
      }
    }

    /* c) fall back to old “blob” logic (smallest closed shape) */
    const hits = [];
    for (let i = 0; i < chains.length; i++) {
      if (!chains[i].isClosed) continue;
      if (pointInPolygon(mouseX, mouseY, chains[i].chain)) hits.push(i);
    }
    if (hits.length) {
      let best = hits[0], bestArea = polygonArea(chains[best].chain);
      for (let j = 1; j < hits.length; j++) {
        const area = polygonArea(chains[hits[j]].chain);
        if (area < bestArea) { best = hits[j]; bestArea = area; }
      }
      chains.splice(best, 1);
      history.push({ type: "chain" });
    }
    return;
  }
    // Pin mode
    if (pinMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const pickRadius   = 20;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < pickRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        const dot = chains[bestChainIndex].chain[bestDotIndex];
        dot.pinned = !dot.pinned;
        return;
      }
      return;
    }

    // Drag mode
    if (dragMode) {
      let bestChainIndex = null;
      let bestDotIndex   = null;
      let bestDist       = Infinity;
      const pickRadius   = 20;

      for (let c=0; c<chains.length; c++) {
        const ch = chains[c].chain;
        for (let i=0; i<ch.length; i++) {
          const dot = ch[i];
          const dx  = mouseX - dot.x;
          const dy  = mouseY - dot.y;
          const dist= Math.sqrt(dx*dx + dy*dy);
          if (dist < pickRadius && dist < bestDist) {
            bestDist       = dist;
            bestChainIndex = c;
            bestDotIndex   = i;
          }
        }
      }
      if (bestChainIndex !== null) {
        draggingChainIndex = bestChainIndex;
        draggingDotIndex   = bestDotIndex;
        return;
      }
    }

    // Otherwise, if in blob or line mode, start freehand
    if ((drawMode === 'blob' || drawMode === 'line') && !dragMode) {
      isDrawing = true;
      currentPathPoints = [{
        x: mouseX, y: mouseY,
        vx:0, vy:0,
        pinned:false
      }];
    }
  });

  window.addEventListener("mouseup", e => {
    if (e.button !== 0) return;

    // Finalize circle
    if (drawMode === 'circle' && isCircleDrawing && currentCircle) {
      if (currentCircle.radius > 5) {
        circles.push(currentCircle);
        history.push({ type: "circle" });
      }
      isCircleDrawing     = false;
      currentCircle       = null;
      draggingCircleIndex = null;

      circleInfo.style.display = "none";   // ← hide the live radius overlay
      return;
    }

    // Finalize blob/line
    if (isDrawing && currentPathPoints.length > 2 && (drawMode === 'blob' || drawMode === 'line')) {
      let r = globalRadiusAvg + (Math.random()*2 - 1)*globalRadiusVar;
      if (r < 1) r = 1;
      const chosenColor = hexToRGBA(colorInput.value);

      const isClosed = (drawMode === 'blob');
      if (isClosed) {
        // close shape
        const f = currentPathPoints[0];
        currentPathPoints.push({...f});
      }

      chains.push({
        chain: currentPathPoints.slice(),
        color: chosenColor,
        baseDotRadius: r,
        isClosed,
        frozen: false
      });
      history.push({ type: "chain" });
    }

    // End all "mouseDown" states
    isDrawing          = false;
    draggingChainIndex = null;
    draggingDotIndex   = null;
    draggingCircleIndex= null;
  });

  window.addEventListener("mouseleave", () => {
    isDrawing=false;
    draggingChainIndex=null;
    draggingDotIndex=null;
    draggingCircleIndex=null;
  });

  /* -----------------------------------
     SHADERS & PROGRAM
  ----------------------------------- */
  function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error("Shader compile error:", gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }
  function createProgram(vsSrc, fsSrc) {
    const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
    const p  = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error("Program link error:", gl.getProgramInfoLog(p));
      return null;
    }
    return p;
  }
  const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    void main(){
      vec2 clipSpace = (a_position / u_resolution)*2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace,0,1);
    }
  `;
  const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main(){
      gl_FragColor = u_color;
    }
  `;
  const lineProgram   = createProgram(vsSource, fsSource);
  const linePosLoc    = gl.getAttribLocation(lineProgram, "a_position");
  const lineResLoc    = gl.getUniformLocation(lineProgram, "u_resolution");
  const lineColorLoc  = gl.getUniformLocation(lineProgram, "u_color");
  const positionBuffer= gl.createBuffer();
  let thickScratch = new Float32Array(0);
  /* -----------------------------------
     CATMULL–ROM SPLINE HELPERS
  ----------------------------------- */
  function getClosedSmoothCurve(points, seg=10) {
    const n=points.length; if(n<2) return new Float32Array([]);
    let out=[];
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i],
            p2=points[(i+1)%n],   p3=points[(i+2)%n];
      for(let s=0;s<seg;s++){
        const t=s/seg, t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t2 + (-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t2 + (-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push(x,y);
      }
    }
    out.push(points[0].x, points[0].y);
    return new Float32Array(out);
  }
  function getOpenSmoothCurve(points, seg=10) {
    const n=points.length; if(n<2) return new Float32Array([]);
    let out=[];
    for(let i=0;i<n-1;i++){
      const p0=(i===0 ? points[0] : points[i-1]),
            p1=points[i],   p2=points[i+1],
            p3=(i===n-2 ? points[n-1] : points[i+2]);
      for(let s=0;s<seg;s++){
        const t=s/seg, t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*t2 + (-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*t2 + (-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push(x,y);
      }
    }
    out.push(points[n-1].x, points[n-1].y);
    return new Float32Array(out);
  }

  function buildStencilTris(flat, outX, outY) {
    // flat = [x0,y0,x1,y1, ... ,xn,yn]  (closed, last!=first)
    const segs = flat.length / 2;
    const arr  = new Float32Array(segs * 3 * 2);   // 3 verts × 2 coords
    let p = 0;
    for (let i = 0; i < segs; i++) {
      const i2 = (i + 1) % segs;
      arr[p++] = flat[i*2];     arr[p++] = flat[i*2+1];
      arr[p++] = flat[i2*2];    arr[p++] = flat[i2*2+1];
      arr[p++] = outX;          arr[p++] = outY;          // far point
    }
    return arr;
  }

  function getThickLineVertices(splinePts, thickness) {
    const n = splinePts.length >> 1;          // points count
    const needed = n * 4;                     // 2 verts per point
    if (thickScratch.length < needed) thickScratch = new Float32Array(needed);

    const half = thickness * 0.5;
    for (let i = 0; i < n; i++) {
      const currX = splinePts[i*2],   currY = splinePts[i*2+1];
      const prevX = splinePts[((i-1+n)%n)*2], prevY = splinePts[((i-1+n)%n)*2+1];
      const nextX = splinePts[((i+1)%n)*2],   nextY = splinePts[((i+1)%n)*2+1];

      // tangential = next - prev
      const tx = nextX - prevX, ty = nextY - prevY;
      const invLen = 1 / Math.hypot(tx, ty || 1);   // avoid /0
      const nx = -ty * invLen, ny = tx * invLen;    // normal

      const base = i * 4;
      thickScratch[base    ] = currX + nx * half;
      thickScratch[base + 1] = currY + ny * half;
      thickScratch[base + 2] = currX - nx * half;
      thickScratch[base + 3] = currY - ny * half;
    }
    return thickScratch.subarray(0, needed);
  }

  /* -----------------------------------
     "DASHED" RENDER FOR FROZEN
  ----------------------------------- */
  function drawDashedSpline(spline, color) {
    gl.useProgram(lineProgram);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, color);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    const pts = spline;
    for (let i=0; i<pts.length-3; i+=4) {
      const sub = new Float32Array([
        pts[i],   pts[i+1],
        pts[i+2], pts[i+3]
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, sub, gl.DYNAMIC_DRAW);
      gl.enableVertexAttribArray(linePosLoc);
      gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
      gl.drawArrays(gl.LINE_STRIP, 0, 2);
    }
  }

  /* -----------------------------------
     PHYSICS
  ----------------------------------- */
  function applySpring(chain, forces, i, j, restDist) {
    const a=chain[i], b=chain[j];
    let dx=b.x-a.x, dy=b.y-a.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<1e-4) dist=1e-4;
    const f = springConstant*(dist-restDist), nx=dx/dist, ny=dy/dist;
    forces[i].x+=f*nx; forces[i].y+=f*ny;
    forces[j].x-=f*nx; forces[j].y-=f*ny;
  }

  function simulateChain(chainObj, cIndex) {
    if (chainObj.frozen) return; // skip frozen

    const arr = chainObj.chain;
    let forces = chainObj._forces;
    // (re‑create if first time or if the point count changed)
    if (!forces || forces.length !== arr.length) {
      forces = chainObj._forces = Array.from({ length: arr.length },
                                             () => ({ x: 0, y: 0 }));
    }
    // zero the existing vectors instead of allocating new objects
    for (let i = 0; i < forces.length; i++) {
      forces[i].x = 0;
      forces[i].y = 0;
    }
    const dotR = chainObj.baseDotRadius*dotScaleFactor;
    const restDist = dotR*0.7;

    // Springs
    if(chainObj.isClosed){
      for(let i=0;i<arr.length;i++){
        const j=(i+1)%arr.length;
        applySpring(arr, forces, i, j, restDist);
      }
    } else {
      for(let i=0;i<arr.length-1;i++){
        applySpring(arr, forces, i, i+1, restDist);
      }
    }

    // Self repulsion
    for(let i=0;i<arr.length;i++){
      for(let j=i+1;j<arr.length;j++){
        const a=arr[i], b=arr[j];
        const minD=dotR*2, dx=b.x-a.x, dy=b.y-a.y, dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>0 && dist<minD){
          const overlap = (minD-dist), nx=dx/dist, ny=dy/dist;
          const f=repulsionConstant*overlap;
          forces[i].x-=f*nx; forces[i].y-=f*ny;
          forces[j].x+=f*nx; forces[j].y+=f*ny;
        }
      }
    }

    // Boundary push-back
    for(let i=0;i<arr.length;i++){
      const a=arr[i];
      if(a.x<dotR) forces[i].x += (dotR-a.x)*0.5;
      else if(a.x>canvas.width-dotR)  forces[i].x-= (a.x - (canvas.width-dotR))*0.5;

      if(a.y<dotR) forces[i].y += (dotR-a.y)*0.5;
      else if(a.y>canvas.height-dotR) forces[i].y-= (a.y - (canvas.height-dotR))*0.5;
    }

    // If this chain is currently being dragged
    if(dragMode && cIndex===draggingChainIndex && draggingDotIndex!==null){
      const dot=arr[draggingDotIndex],
            dx=currentMouseX-dot.x,
            dy=currentMouseY-dot.y,
            dist=Math.sqrt(dx*dx + dy*dy);
      if(dist>1e-4){
        const nx=dx/dist, ny=dy/dist, f=0.2*dist;
        forces[draggingDotIndex].x+=f*nx;
        forces[draggingDotIndex].y+=f*ny;
      }
    }

    // Integrate
    for(let i=0;i<arr.length;i++){
      const d=arr[i];
      const isDraggingThisDot = (dragMode && cIndex === draggingChainIndex && i === draggingDotIndex);
      if(d.pinned && !isDraggingThisDot){
        d.vx=0; d.vy=0;
        continue;
      }
      d.vx = (d.vx + forces[i].x*timeStep) * damping;
      d.vy = (d.vy + forces[i].y*timeStep) * damping;
      d.x  += d.vx*timeStep;
      d.y  += d.vy*timeStep;
    }
  }

  function simulateInterChainRepulsion() {
    for(let a=0;a<chains.length;a++){
      for(let b=a+1;b<chains.length;b++){
        const A=chains[a], B=chains[b];
        if(A.frozen && B.frozen) continue;

        const rA=A.baseDotRadius*dotScaleFactor, rB=B.baseDotRadius*dotScaleFactor;
        const minD=rA+rB;
        for(let i=0;i<A.chain.length;i++){
          for(let j=0;j<B.chain.length;j++){
            const dA=A.chain[i], dB=B.chain[j];
            const dx=dB.x-dA.x, dy=dB.y-dA.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist>0 && dist<minD){
              const overlap=(minD-dist), nx=dx/dist, ny=dy/dist, f = repulsionConstant * interRepelMult * overlap;
              if(!dA.pinned && !A.frozen){
                dA.vx-=f*nx*timeStep; dA.vy-=f*ny*timeStep;
              }
              if(!dB.pinned && !B.frozen){
                dB.vx+=f*nx*timeStep; dB.vy+=f*ny*timeStep;
              }
            }
          }
        }
      }
    }
  }

  function simulateCircleRepulsion() {
    for(let c=0;c<circles.length;c++){
      const circle=circles[c];
      for(let ch=0;ch<chains.length;ch++){
        if(chains[ch].frozen) continue;
        const arr=chains[ch].chain;
        for(let i=0;i<arr.length;i++){
          const d=arr[i];
          const dx=d.x-circle.x, dy=d.y-circle.y, dist=Math.sqrt(dx*dx+dy*dy);
          const hardWall = (interRepelMult === 3);          // button ON → hard wall
          if (hardWall) {                                   // ─── HARD mode ───
            const dotR = chains[ch].baseDotRadius * dotScaleFactor;
            const minD = circle.radius + dotR;
            if (dist < minD) {
              const nx = dx / dist, ny = dy / dist;
              d.x = circle.x + nx * minD;
              d.y = circle.y + ny * minD;
              d.vx = d.vy = 0;
            }
          } else {                                          // ─── SOFT mode ───
            if (dist > 1e-4 && dist < circle.radius) {
              const f = repulsionConstant * (circle.radius - dist);
              if (!d.pinned) {
                d.vx += f * (dx / dist);
                d.vy += f * (dy / dist);
              }
            }
          }
        }
      }
    }
  }

  /* -----------------------------------
     RENDERING
  ----------------------------------- */
  function drawGrid(size=20) {
    const w=canvas.width, h=canvas.height;
    let gridVerts=[];
    for(let x=0;x<=w;x+=size) {
      gridVerts.push(x,0, x,h);
    }
    for(let y=0;y<=h;y+=size) {
      gridVerts.push(0,y, w,y);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVerts), gl.STATIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform2f(lineResLoc, w,h);
    gl.uniform4fv(lineColorLoc, [0.8,0.8,0.8,1]);
    gl.drawArrays(gl.LINES, 0, gridVerts.length/2);
  }

  function drawPinnedIndicator(x, y) {
    const seg=12, rad=4;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      const cx=x + rad*Math.cos(t), cy=y + rad*Math.sin(t);
      verts.push(cx,cy);
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform4fv(lineColorLoc, [1.0,0.0,0.0,1.0]); // red ring
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawHoverIndicator(dot, isPinned) {
    const seg=12, radius=8;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      verts.push(dot.x + radius*Math.cos(t),
                 dot.y + radius*Math.sin(t));
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
    const color = isPinned ? [1.0, 0.2, 0.2, 1.0] :	[0.00, 1.00, 0.50, 1];
    gl.uniform4fv(lineColorLoc, color);
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawChain(chainObj, chainIndex) {
    const ch = chainObj.chain;
    if (ch.length < 2) return;

    const spline = chainObj.isClosed
        ? getClosedSmoothCurve(ch, 10)
        : getOpenSmoothCurve(ch, 10);
    if (spline.length < 4) return;

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, chainObj.color);

    /* NEW — solid-fill branch */
    if (solidFillMode && chainObj.isClosed) {
        gl.clear(gl.STENCIL_BUFFER_BIT);
      // 1) toggle stencil wherever an edge wedge passes
      gl.enable(gl.STENCIL_TEST);
      gl.colorMask(false, false, false, false);
      gl.stencilFunc(gl.ALWAYS, 0, 1);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);

      const OUT_X = -9999, OUT_Y = -9999;          // any point off-canvas
      const tris  = buildStencilTris(spline, OUT_X, OUT_Y);

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tris, gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
      gl.uniform4fv(lineColorLoc, chainObj.color);  // colour doesn’t matter
      gl.drawArrays(gl.TRIANGLES, 0, tris.length / 2);

      const rgba = chainObj.color.slice();              // copy
      rgba[3] = chainObj.alpha ?? 1.0;                  // use 0.3 if frozen
      gl.uniform4fv(lineColorLoc, rgba);

      // 2) draw one big quad wherever stencil==1  (the filled blob)
      gl.colorMask(true, true, true, true);
      gl.stencilFunc(gl.EQUAL, 1, 1);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

      const quad = new Float32Array([
         0,0,  canvas.width,0,  canvas.width,canvas.height,
         0,0,  canvas.width,canvas.height,  0,canvas.height
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
      gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      gl.disable(gl.STENCIL_TEST);

      /* --- overlays drawn on top of the filled blob ----------------- */
      // pinned dots
      for (let i = 0; i < ch.length; i++) {
        if (ch[i].pinned) {
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          drawPinnedIndicator(ch[i].x, ch[i].y);
        }
      }
      // hover ring in drag / pin mode
      if ((pinMode || dragMode) &&
          chainIndex === pinHoverChainIndex &&
          pinHoverDotIndex !== null) {
        const hoverDot = ch[pinHoverDotIndex];
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        drawHoverIndicator(hoverDot, hoverDot.pinned);
      }
      /* ---------------------------------------------------------------- */
      return;                                // done with this blob
                                // done with this blob
    }

    /* --- existing outline code below --- */
    if (chainObj.frozen) {
      drawDashedSpline(spline, chainObj.color);
    } else {
      if (currentLineThickness === 1) {
        gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINE_STRIP, 0, spline.length / 2);
      } else {
        const thickVerts = getThickLineVertices(spline, currentLineThickness);
        gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, thickVerts.length / 2);
      }
    }

    if(chainObj.frozen) {
      // dashed style
      drawDashedSpline(spline, chainObj.color);
    } else {
      // normal stroke
      gl.uniform4fv(lineColorLoc, chainObj.color);
      if(currentLineThickness===1){
        gl.bufferData(gl.ARRAY_BUFFER, spline, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.LINE_STRIP,0, spline.length/2);
      } else {
        const thickVerts = getThickLineVertices(spline, currentLineThickness);
        gl.bufferData(gl.ARRAY_BUFFER, thickVerts, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0, thickVerts.length/2);
      }
    }

    // pinned dots
    for(let i=0;i<ch.length;i++){
      if(ch[i].pinned){
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        drawPinnedIndicator(ch[i].x, ch[i].y);
      }
    }

    // hover ring if this chain/dot is hovered in pinMode/dragMode
    if((pinMode || dragMode) && chainIndex === pinHoverChainIndex && pinHoverDotIndex!==null){
      const hoverDot = ch[pinHoverDotIndex];
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      drawHoverIndicator(hoverDot, hoverDot.pinned);
    }
  }

  function drawCircle(circle) {
    const seg=32;
    let verts=[];
    for(let i=0;i<seg;i++){
      const t=i*(2*Math.PI/seg);
      verts.push(
        circle.x + circle.radius*Math.cos(t),
        circle.y + circle.radius*Math.sin(t)
      );
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc,2,gl.FLOAT,false,0,0);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, [0,0,0,1]);
    gl.drawArrays(gl.LINE_LOOP, 0, seg);
  }

  function drawInProgressPath() {
    if(!isDrawing || currentPathPoints.length<2) return;
    const arr=[];
    for(let i=0;i<currentPathPoints.length;i++){
      arr.push(currentPathPoints[i].x, currentPathPoints[i].y);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.DYNAMIC_DRAW);
    gl.useProgram(lineProgram);
    gl.enableVertexAttribArray(linePosLoc);
    gl.vertexAttribPointer(linePosLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(lineResLoc, canvas.width, canvas.height);
    gl.uniform4fv(lineColorLoc, hexToRGBA(colorInput.value));
    gl.drawArrays(gl.LINE_STRIP, 0, currentPathPoints.length);
  }

  function drawCurrentCircle() {
    if(!isCircleDrawing || !currentCircle) return;
    drawCircle(currentCircle);
  }

  /* -----------------------------------
     ANIMATION LOOP
  ----------------------------------- */
  function animate() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    // Physics
    chains.forEach((c,i)=>simulateChain(c,i));
    simulateInterChainRepulsion();
    simulateCircleRepulsion();

    // Clear & draw
    gl.clearColor(1,1,1,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    drawGrid(20);

    chains.forEach((chainObj, chainIndex) => {
      drawChain(chainObj, chainIndex);
    });
    drawInProgressPath();
    circles.forEach(drawCircle);
    if(drawMode==='circle') drawCurrentCircle();

    requestAnimationFrame(animate);
  }
  animate();


  /* ---------- guided tour engine ---------- */
  const tourSteps = [
    /* 0 ─ Title-bar */
    {
      el: "#splashOverlay + .title-bar",
      text: "Title bar: File (save/load), Export (SVG/JPG), About, Help."
    },

    /* 1 ─ Draw Tools */
    {
      el: ".toolbar-section:first-of-type",
      text: "Choose what you create on the canvas: Blobs, Lines, or Repulsion Circles. Select which one you'd like then click-drag on the canvas to draw."
    },

    /* 2 ─ Edit Tools */
    {
      el: "#editToolsSection",
      text: "Edit items on the canvas with these tools: Drag, Freeze, Pin, Slice, or Delete existing items. Only one edit mode can be active at a time."
    },

    /* 3 ─ Shape Settings */
    {
      el: ".toolbar-section:nth-of-type(3)",
      text: "Set colour, average blob size, and variation before each draw."
    },

    /* 4 ─ Canvas Tools */
    {
      el: ".toolbar-section:nth-of-type(4)",
      text: "The canvas tools toggle stroke thickness, solid fill, high repulsion mode, or undo the last action."
    },

    /* 5 ─ Main Canvas */
    {
      el: "#glCanvas",
      text: "Canvas: the main playground: draw, drag, and experiment here."
    },

    /* 6 ─ Physics Sliders */
    {
      el: ".bottom-panel",
      text: "Physics Sliders: fine-tune the blob behaviour. Hover the ⓘ buttons to see what each slider does."
    }
  ];

  let tourIndex = -1;

  function startTour(){
    if (tourIndex !== -1) return;              // already running
    tourIndex = 0;
    $("tourOverlay").style.display = $("tourTip").style.display = "block";
    document.addEventListener("keydown", tourKey);
    showStep();
  }
  function endTour(){
    clearHighlight();
    $("tourOverlay").style.display = $("tourTip").style.display = "none";
    document.removeEventListener("keydown", tourKey);
    tourIndex = -1;
  }
  function showStep(){
    clearHighlight();
    const step = tourSteps[tourIndex];
    const el = document.querySelector(step.el);
    if (!el){ nextStep(); return; }
    el.classList.add("tour-highlight");
    $("tourText").textContent = step.text;
    positionTip(el);
    $("tourPrev").disabled = tourIndex===0;
    $("tourNext").textContent = tourIndex===tourSteps.length-1 ? "Done ✔" : "Next ▶";
  }
  function positionTip(target){
    const rect = target.getBoundingClientRect();
    const tip  = $("tourTip");
    const left = rect.right + 12 < window.innerWidth-330
               ? rect.right + 12 : rect.left - 332;
    tip.style.left = (left<8?8:left) + "px";
    tip.style.top  = rect.top + "px";
  }
  function clearHighlight(){
    document.querySelectorAll(".tour-highlight").forEach(e=>e.classList.remove("tour-highlight"));
  }
  function nextStep(){
    if (tourIndex < tourSteps.length-1){ tourIndex++; showStep(); }
    else endTour();
  }
  function prevStep(){
    if (tourIndex>0){ tourIndex--; showStep(); }
  }
  function tourKey(e){
    if (e.key==="Escape") endTour();
    else if (e.key==="ArrowRight") nextStep();
    else if (e.key==="ArrowLeft")  prevStep();
  }
  $("tourNext").onclick = nextStep;
  $("tourPrev").onclick = prevStep;
  $("tourExit").onclick = endTour;

  /* -----------------------------------
     EXPORT HELPERS
  ----------------------------------- */
  function exportSVG(isFilled) {
    const w=canvas.width, h=canvas.height;
    const parts=[`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" style="background:white;">`];
    chains.forEach(obj=>{
      if(obj.chain.length<2) return;
      const spline = obj.isClosed ? getClosedSmoothCurve(obj.chain,10)
                                  : getOpenSmoothCurve(obj.chain,10);
      if(spline.length<4) return;
      const [rr,gg,bb] = obj.color.map(c=>Math.floor(c*255));
      let d=`M ${spline[0]} ${spline[1]}`;
      for(let i=2;i<spline.length;i+=2) {
        d+=` L ${spline[i]} ${spline[i+1]}`;
      }
      if(obj.isClosed) d+=" Z";

      if(isFilled){
        parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" ${obj.isClosed?`fill="rgb(${rr},${gg},${bb})"`:'fill="none"'} stroke-width="${currentLineThickness}" stroke-linecap="round" stroke-linejoin="round" />`);
      } else {
        parts.push(`<path d="${d}" stroke="rgb(${rr},${gg},${bb})" fill="none" stroke-width="${currentLineThickness}" stroke-linecap="round" stroke-linejoin="round" />`);
      }
    });
    parts.push("</svg>");
    const blob=new Blob([parts.join("")],{type:"image/svg+xml"});
    const url=URL.createObjectURL(blob);
    const link=document.createElement("a");
    link.href=url;
    link.download = isFilled ? "blobs_filled.svg" : "blobs_stroked.svg";
    link.click();
    URL.revokeObjectURL(url);
  }

  function exportJPG(isFilled) {
    const size=1500;
    const offscreen=document.createElement("canvas");
    offscreen.width=size;
    offscreen.height=size;
    const ctx=offscreen.getContext("2d");
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,size,size);
    const scale=size/canvas.width;

    chains.forEach(obj=>{
      const ch=obj.chain;
      if(ch.length<2) return;
      const spline = obj.isClosed ? getClosedSmoothCurve(ch,10)
                                  : getOpenSmoothCurve(ch,10);
      if(spline.length<4) return;
      const [rr,gg,bb] = obj.color.map(c=>Math.floor(c*255));
      ctx.lineCap="round";
      ctx.lineJoin="round";
      ctx.beginPath();
      ctx.moveTo(spline[0]*scale, spline[1]*scale);
      for(let i=2;i<spline.length;i+=2){
        ctx.lineTo(spline[i]*scale, spline[i+1]*scale);
      }
      if(obj.isClosed) ctx.closePath();
      if(isFilled && obj.isClosed){
        ctx.fillStyle=`rgb(${rr},${gg},${bb})`;
        ctx.fill();
      } else {
        ctx.strokeStyle=`rgb(${rr},${gg},${bb})`;
        ctx.lineWidth = currentLineThickness*scale;
        ctx.stroke();
      }
    });

    const url=offscreen.toDataURL("image/jpeg",1.0);
    const link=document.createElement("a");
    link.href=url;
    link.download = isFilled ? "blobs_filled.jpg" : "blobs_stroked.jpg";
    link.click();
  }

  $("exportStrokedOption").onclick = e => {
    e.stopPropagation();
    exportSVG(false);
    $("exportSubmenu").style.display="none";
  };
  $("exportFilledOption").onclick = e => {
    e.stopPropagation();
    exportSVG(true);
    $("exportSubmenu").style.display="none";
  };
  $("exportStrokedJPGOption").onclick = e => {
    e.stopPropagation();
    exportJPG(false);
    $("exportSubmenu").style.display="none";
  };
  $("exportFilledJPGOption").onclick = e => {
    e.stopPropagation();
    exportJPG(true);
    $("exportSubmenu").style.display="none";
  };

  /* -----------------------------------
     SLIDER SETUP
  ----------------------------------- */

  // 1) Blob Scale slider (0..100 => 0.1..5)
  {
    const s = $("dotScaleSlider");
    const v = $("dotScaleValue");
    s.value = ((dotScaleFactor - 0.1)/(5 - 0.1)) * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      setDotScale(parseFloat(s.value));
    });
  }

  // 2) Damping slider (0..100 => 0..1)
  {
    const s = $("dampingSlider");
    const v = $("dampingValue");
    s.value = damping * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      damping = parseFloat(s.value)/100;
      v.textContent = Math.round(s.value) + "%";
    });
  }

  // 3) Spring Constant slider (0..100 => 0..1)
  {
    const s = $("springConstantSlider");
    const v = $("springConstantValue");
    s.value = springConstant * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      springConstant = parseFloat(s.value)/100;
      v.textContent = Math.round(s.value) + "%";
    });
  }

  // 4) Repulsion slider (0..100 => 0..1)
  {
    const s = $("repulsionConstantSlider");
    const v = $("repulsionConstantValue");
    s.value = repulsionConstant * 200;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      repulsionConstant = parseFloat(s.value)/200;
      v.textContent = s.value + "%";
    });
  }

  // 5) Simulation Speed slider (0..100 => 0.1..2)
  {
    const s = $("timeStepSlider");
    const v = $("timeStepValue");
    s.value = ((timeStep - 0.1) / (2 - 0.1)) * 100;
    v.textContent = s.value + "%";
    s.addEventListener("input", () => {
      const percent = parseFloat(s.value);
      timeStep = mapRange(percent, 0, 100, 0.1, 2);
      v.textContent = s.value + "%";
    });
  }

  window.addEventListener("keydown", e => {
    // ignore ⇧/⌥/⌘ combos and when user is typing in an input / textarea
    if (e.ctrlKey || e.metaKey || e.altKey) return;
    const tgt = e.target;
    if (tgt && (tgt.tagName === "INPUT" || tgt.tagName === "TEXTAREA")) return;

    switch (e.key.toLowerCase()) {
      /* draw modes */
      case "q": setDrawMode("blob");   break;   // Blob
      case "w": setDrawMode("line");   break;   // Line
      case "e": setDrawMode("circle"); break;   // Circle

      /* edit tools (toggle off if already on) */
      case "a": setEditTool("drag");   break;   // Drag
      case "s": setEditTool("freeze"); break;   // Freeze
      case "d": setEditTool("pin");    break;   // Pin
      case "z": setEditTool("slice");  break;   // Slice
      case "x": setEditTool("delete"); break;   // Delete
    }
  });

  window.addEventListener("keydown", e => {
    if (e.code === "Space" && !e.repeat) {           // Space toggles
      if (damping !== 0) {                           // turn OFF
        prevDamping = damping;     // remember
        damping = 0;
      } else {                                       // turn ON
        damping = prevDamping || 0.85;               // fallback default
      }

      // keep the UI slider in sync
      const s = $("dampingSlider"),
            v = $("dampingValue");
      s.value = damping * 100;
      v.textContent = Math.round(s.value) + "%";

      e.preventDefault();            // stop the page from scrolling
    }
  });
  // 6) Gap & ΔSize
  $("radiusAvgInput").oninput = e => {
    globalRadiusAvg = parseFloat(e.target.value);
  };
  $("radiusVarInput").oninput = e => {
    globalRadiusVar = parseFloat(e.target.value);
  };
});
</script>
</body>
</html>
